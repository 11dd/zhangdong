<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zhangdong]]></title>
  <link href="www.freefook.com/atom.xml" rel="self"/>
  <link href="www.freefook.com/"/>
  <updated>2017-12-26T17:38:10+08:00</updated>
  <id>www.freefook.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[建项-快速开发->各个三方使用地址]]></title>
    <link href="www.freefook.com/15142755262305.html"/>
    <updated>2017-12-26T16:05:26+08:00</updated>
    <id>www.freefook.com/15142755262305.html</id>
    <content type="html"><![CDATA[
<p>极光推送：<br/>
<a href="https://docs.jiguang.cn/jpush/client/iOS/ios_sdk/">https://docs.jiguang.cn/jpush/client/iOS/ios_sdk/</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 1 ->TabBar]]></title>
    <link href="www.freefook.com/15142722458623.html"/>
    <updated>2017-12-26T15:10:45+08:00</updated>
    <id>www.freefook.com/15142722458623.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">学习优秀的封装</h4>

<p>CYLTabBarController</p>

<pre><code>【中国特色 TabBar】最低只需传两个数组即可完成主流App框架搭建【iPhoneX supported】 

 （转载 https://github.com/ChenYilong）

</code></pre>

<h5 id="toc_1">CYLTabBarController【低耦合集成TabBarController】</h5>

<h5 id="toc_2">集成后的效果：</h5>

<table>
<thead>
<tr>
<th>既支持默认样式</th>
<th>同时也支持创建自定义的形状不规则加号按钮</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i62.tinypic.com/rvcbit.jpg?192x251_130" alt="enter image description here"/></td>
<td><img src="http://i58.tinypic.com/24d4t3p.jpg?192x251_130" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>支持横竖屏<br/>
 <img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_3">使用<a href="https://github.com/ChenYilong/CYLTabBarController">CYLTabBarController</a></h4>

<p>四步完成主流App框架搭建：</p>

<ol>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8cocoapods%E5%AF%BC%E5%85%A5cyltabbarcontroller"> 第一步：使用CocoaPods导入CYLTabBarController </a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E8%AE%BE%E7%BD%AEcyltabbarcontroller%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E7%BB%84%E5%92%8Ctabbar%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%B0%86cyltabbarcontroller%E8%AE%BE%E7%BD%AE%E4%B8%BAwindow%E7%9A%84rootviewcontroller">第三步：将CYLTabBarController设置为window的RootViewController</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E5%8F%AF%E9%80%89%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BD%A2%E7%8A%B6%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A0%E5%8F%B7%E6%8C%89%E9%92%AE">第四步（可选）：创建自定义的形状不规则加号按钮</a> </li>
</ol>

<h5 id="toc_4">第一步：省略使用CocoaPods导入CYLTabBarController</h5>

<h5 id="toc_5">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</h5>

<pre><code class="language-Objective-C"> - (void)setupViewControllers {
    CYLHomeViewController *firstViewController = [[CYLHomeViewController alloc] init];
    UIViewController *firstNavigationController = [[UINavigationController alloc]
                                                   initWithRootViewController:firstViewController];
    
    CYLSameFityViewController *secondViewController = [[CYLSameFityViewController alloc] init];
    UIViewController *secondNavigationController = [[UINavigationController alloc]
                                                    initWithRootViewController:secondViewController];
    

    CYLTabBarController *tabBarController = [[CYLTabBarController alloc] init];
    [self customizeTabBarForController:tabBarController];
    
    [tabBarController setViewControllers:@[
                                           firstNavigationController,
                                           secondNavigationController,
                                           ]];
    self.tabBarController = tabBarController;
}

/*
 *
 在`-setViewControllers:`之前设置TabBar的属性，
 *
 */
- (void)customizeTabBarForController:(CYLTabBarController *)tabBarController {
    
    NSDictionary *dict1 = @{
                            CYLTabBarItemTitle : @&quot;首页&quot;,
                            CYLTabBarItemImage : @&quot;home_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;home_highlight&quot;,
                            };
    NSDictionary *dict2 = @{
                            CYLTabBarItemTitle : @&quot;同城&quot;,
                            CYLTabBarItemImage : @&quot;mycity_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;mycity_highlight&quot;,
                            };

    NSArray *tabBarItemsAttributes = @[ dict1, dict2 ];
    tabBarController.tabBarItemsAttributes = tabBarItemsAttributes;
}
</code></pre>

<p>在这个字典中，<code>CYLTabBarItemImage</code> 和 <code>CYLTabBarItemSelectedImage</code> 支持 <code>NSString</code>、<code>UIImage</code><br/>
两种格式。<code>CYLTabBarItemTitle</code> 不设置将只展示图标，并会对布局作出居中处理。</p>

<h5 id="toc_6">第三步：将CYLTabBarController设置为window的RootViewController</h5>

<pre><code class="language-Objective-C"> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window setRootViewController:self.tabBarController];
 /* *省略部分：   * */
    return YES;
}
</code></pre>

<h5 id="toc_7">第四步（可选）：创建自定义的形状不规则加号按钮</h5>

<p>创建一个继承于 CYLPlusButton 的类，要求和步骤：</p>

<ol>
<li><p>实现  <code>CYLPlusButtonSubclassing</code>  协议 </p></li>
<li><p>子类将自身类型进行注册，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C">+ (void)load {
[super registerPlusButton];
}
</code></pre></li>
</ol>

<p>协议提供了可选方法：</p>

<pre><code class="language-Objective-C">+ (NSUInteger)indexOfPlusButtonInTabBar;
+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
+ (UIViewController *)plusChildViewController;
+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>作用分别是：</p>

<pre><code class="language-Objective-C"> + (NSUInteger)indexOfPlusButtonInTabBar;
</code></pre>

<p>用来自定义加号按钮的位置，如果不实现默认居中，但是如果 <code>tabbar</code> 的个数是奇数则必须实现该方法，否则 <code>CYLTabBarController</code> 会抛出 <code>exception</code> 来进行提示。</p>

<p>主要适用于如下情景：</p>

<p><img src="http://a64.tinypic.com/2mo0h.jpg" alt="enter image description here"/></p>

<p>Airbnb-app效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<pre><code class="language-Objective-C">+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>该方法是为了调整自定义按钮中心点Y轴方向的位置，建议在按钮超出了 <code>tabbar</code> 的边界时实现该方法。返回值是自定义按钮中心点Y轴方向的坐标除以 <code>tabbar</code> 的高度，如果不实现，会自动进行比对，预设一个较为合适的位置，如果实现了该方法，预设的逻辑将失效。</p>

<p>内部实现时，会使用该返回值来设置 PlusButton 的 centerY 坐标，公式如下：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说：如果 constantOfPlusButtonCenterYOffset 为0，同时 multiplierOfTabBarHeight 的值是0.5，表示 PlusButton 居中，小于0.5表示 PlusButton 偏上，大于0.5则表示偏下。</p>

<pre><code class="language-Objective-C">+ (CGFloat)constantOfPlusButtonCenterYOffsetForTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>参考 <code>+multiplierOfTabBarHeight:</code> 中的公式：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说： constantOfPlusButtonCenterYOffset 大于0会向下偏移，小于0会向上偏移。</p>

<p>注意：实现了该方法，但没有实现 <code>+multiplierOfTabBarHeight:</code> 方法，在这种情况下，会在预设逻辑的基础上进行偏移。</p>

<p>详见Demo中的 <code>CYLPlusButtonSubclass</code> 类的实现。</p>

<pre><code class="language-Objective-C">+ (UIViewController *)plusChildViewController;
</code></pre>

<p>详见： <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%82%B9%E5%87%BB-plusbutton-%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A-uiviewcontroller">点击 PlusButton 跳转到指定 UIViewController</a> </p>

<p>另外，如果加号按钮超出了边界，一般需要手动调用如下代码取消 tabbar 顶部默认的阴影，可在 AppDelegate 类中调用：</p>

<pre><code class="language-Objective-C">    //去除 TabBar 自带的顶部阴影
    [[UITabBar appearance] setShadowImage:[[UIImage alloc] init]];        
</code></pre>

<p>// iOS10 后 需要使用 <code>-[CYLTabBarController hideTabBadgeBackgroundSeparator]</code> 见 AppDelegate 类中的演示;</p>

<p>如何调整、自定义 <code>PlusButton</code> 与其它 <code>TabBarItem</code> 的宽度？</p>

<p><code>CYLTabBarController</code> 规定：</p>

<pre><code class="language-Objective-C"> TabBarItem 宽度 ＝  ( TabBar 总宽度 －  PlusButton 宽度  ) / (TabBarItem 个数)
</code></pre>

<p>所以想自定义宽度，只需要修改 <code>PlusButton</code> 的宽度即可。</p>

<p>比如你就可以在 Demo中的 <code>CYLPlusButtonSubclass.m</code> 类里：</p>

<p>把</p>

<pre><code class="language-Objective-C"> [button sizeToFit]; 
</code></pre>

<p>改为</p>

<pre><code class="language-Objective-C"> button.frame = CGRectMake(0.0, 0.0, 250, 100);
 button.backgroundColor = [UIColor redColor];
</code></pre>

<p>效果如下，<br/>
1.17.4<br/>
<img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>同时你也可以顺便测试下 <code>CYLTabBarController</code> 的这一个特性：</p>

<blockquote>
<p>即使加号按钮超出了tabbar的区域，超出部分依然能响应点击事件</p>
</blockquote>

<p>并且你可以在项目中的任意位置读取到 <code>PlusButton</code> 的宽度，借助 <code>CYLTabBarController.h</code> 定义的 <code>CYLPlusButtonWidth</code> 这个extern。可参考 <code>+[CYLTabBarControllerConfig customizeTabBarAppearance:]</code> 里的用法。</p>

<h3 id="toc_8">补充说明</h3>

<h4 id="toc_9">自定义 <code>TabBar</code> 样式</h4>

<p>如果想更进一步的自定义 <code>TabBar</code> 样式可在 <code>-application:didFinishLaunchingWithOptions:</code> 方法中设置</p>

<pre><code class="language-Objective-C"> /**
 *  tabBarItem 的选中和不选中文字属性、背景图片
 */
- (void)customizeInterface {
    
    // 普通状态下的文字属性
    NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];
    normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];
    
    // 选中状态下的文字属性
    NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];
    selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];
    
    // 设置文字属性
    UITabBarItem *tabBar = [UITabBarItem appearance];
    [tabBar setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];
    [tabBar setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];
    
    // 设置背景图片
    UITabBar *tabBarAppearance = [UITabBar appearance];
    [tabBarAppearance setBackgroundImage:[UIImage imageNamed:@&quot;tabbar_background&quot;]];
}

 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window makeKeyAndVisible];
    [self customizeInterface];
    return YES;
}
</code></pre>

<h4 id="toc_10">捕获 TabBar 点击事件</h4>

<p>实现 CYLTabBarController 的如下几个代理方法即可捕获点击事件。 </p>

<p>下面这个方法能捕获当前点击的 <code>TabBar</code> 上的控件，可以是 <code>UITabBarButton</code>、也可以 <code>PlusButton</code>、也可以是添加到 <code>TabBar</code> 上的任意 <code>UIControl</code> 的子类。但是如果 <code>PlusButton</code> 也添加了点击事件，那么点击 <code>PlusButton</code> 将不会被触发这个代理方法。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 * @attention If PlusButton also add an action, then this delegate method will not be invoked when the PlusButton is selected.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>下面这个方法能捕获跳转前所在的控制器，以及跳转到的目标控制器。</p>

<pre><code class="language-Objective-C">//UITabBarController.h
@protocol UITabBarControllerDelegate &lt;NSObject&gt;
@optional
- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController NS_AVAILABLE_IOS(3_0);
@end

</code></pre>

<p>注意：在调用该方法时应该始终调用<br/>
<code>[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];</code> 来确保 <code>PlusButton</code> 的选中状态。示例如下：</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
    [[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
    return YES;
}
</code></pre>

<p>相关用法已经在 Demo 中展示。</p>

<p>遵循协议的方式如下：</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //...
        tabBarControllerConfig.tabBarController.delegate = self;
    //...
    return YES;
}
</code></pre>

<h4 id="toc_11">点击 TabBarButton 时添加动画</h4>

<p>Demo 演示的效果图：</p>

<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fg9hu6qnwbg308v0gctcc.gif" alt=""/></p>

<p>实现如下代理方法，就能得到对应的选中控件，可以在控件上直接添加动画。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>Demo 中示例代码如下：</p>

<p>遵循协议</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end
</code></pre>

<pre><code class="language-Objective-C"> //AppDelegate.m
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control {
    UIView *animationView;
    // 如果 PlusButton 也添加了点击事件，那么点击 PlusButton 后不会触发该代理方法。
    if ([control isKindOfClass:[CYLExternPlusButton class]]) {
        UIButton *button = CYLExternPlusButton;
        animationView = button.imageView;
    } else if ([control isKindOfClass:NSClassFromString(@&quot;UITabBarButton&quot;)]) {
        for (UIView *subView in control.subviews) {
            if ([subView isKindOfClass:NSClassFromString(@&quot;UITabBarSwappableImageView&quot;)]) {
                animationView = subView;
            }
        }
    }
    
    if ([self cyl_tabBarController].selectedIndex % 2 == 0) {
        [self addScaleAnimationOnView:animationView];
    } else {
        [self addRotateAnimationOnView:animationView];
    }
}

//缩放动画
- (void)addScaleAnimationOnView:(UIView *)animationView {
    //需要实现的帧动画，这里根据需求自定义
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;transform.scale&quot;;
    animation.values = @[@1.0,@1.3,@0.9,@1.15,@0.95,@1.02,@1.0];
    animation.duration = 1;
    animation.calculationMode = kCAAnimationCubic;
    [animationView.layer addAnimation:animation forKey:nil];
}

//旋转动画
- (void)addRotateAnimationOnView:(UIView *)animationView {
    [UIView animateWithDuration:0.32 delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{
        animationView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
    } completion:nil];
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [UIView animateWithDuration:0.70 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0.2 options:UIViewAnimationOptionCurveEaseOut animations:^{
            animationView.layer.transform = CATransform3DMakeRotation(2 * M_PI, 0, 1, 0);
        } completion:nil];
    });
}
</code></pre>

<h4 id="toc_12">横竖屏适配</h4>

<p><code>TabBar</code> 横竖屏适配时，如果你添加了 <code>PlusButton</code>，且适配时用到了 <code>TabBarItem</code> 的宽度, 不建议使用系统的<code>UIDeviceOrientationDidChangeNotification</code> , 请使用库里的 <code>CYLTabBarItemWidthDidChangeNotification</code> 来更新 <code>TabBar</code> 布局，最典型的场景就是，根据 <code>TabBarItem</code> 在不同横竖屏状态下的宽度变化来切换选中的<code>TabBarItem</code> 的背景图片。Demo 里 <code>CYLTabBarControllerConfig.m</code> 给出了这一场景的用法:</p>

<p><code>CYLTabBarController.h</code>  中提供了 <code>CYLTabBarItemWidth</code> 这一extern常量，并且会在 <code>TabBarItem</code> 的宽度发生变化时，及时更新该值，所以用法就如下所示：</p>

<pre><code class="language-Objective-C">- (void)updateTabBarCustomizationWhenTabBarItemWidthDidUpdate {
    void (^deviceOrientationDidChangeBlock)(NSNotification *) = ^(NSNotification *notification) {
        [self tabBarItemWidthDidUpdate];
};
    [[NSNotificationCenter defaultCenter] addObserverForName:CYLTabBarItemWidthDidChangeNotification
                                                      object:nil
                                                       queue:[NSOperationQueue mainQueue]
                                                  usingBlock:deviceOrientationDidChangeBlock];
}

- (void)tabBarItemWidthDidUpdate {
    UIDeviceOrientation orientation = [[UIDevice currentDevice] orientation];
    if ((orientation == UIDeviceOrientationLandscapeLeft) || (orientation == UIDeviceOrientationLandscapeRight)) {
        NSLog(@&quot;Landscape Left or Right !&quot;);
    } else if (orientation == UIDeviceOrientationPortrait){
        NSLog(@&quot;Landscape portrait!&quot;);
    }
    CGSize selectionIndicatorImageSize = CGSizeMake(CYLTabBarItemWidth, [self cyl_tabBarController].tabBar.bounds.size.height);
    [[self cyl_tabBarController].tabBar setSelectionIndicatorImage:[[self class]
                                                                    imageFromColor:[UIColor yellowColor]
                                                                    forSize:selectionIndicatorImageSize
                                                                    withCornerRadius:0]];
}
</code></pre>

<p><img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_13">访问初始化好的 CYLTabBarController 对象</h4>

<p>对于任意 <code>NSObject</code> 对象：</p>

<p><code>CYLTabBarController.h</code>  中为 <code>NSObject</code> 提供了分类方法 <code>-cyl_tabBarController</code> ，所以在任意对象中，一行代码就可以访问到一个初始化好的  <code>CYLTabBarController</code>  对象，<code>-cyl_tabBarController</code> 的作用你可以这样理解：与获取单例对象的  <code>+shareInstance</code> 方法作用一样。</p>

<p>接口如下：</p>

<pre><code class="language-Objective-C">// CYLTabBarController.h

@interface NSObject (CYLTabBarController)

/**
 * If `self` is kind of `UIViewController`, this method will return the nearest ancestor in the view controller hierarchy that is a tab bar controller. If `self` is not kind of `UIViewController`, it will return the `rootViewController` of the `rootWindow` as long as you have set the `CYLTabBarController` as the  `rootViewController`. Otherwise return nil. (read-only)
 */
@property (nonatomic, readonly) CYLTabBarController *cyl_tabBarController;

@end
</code></pre>

<p>用法：</p>

<pre><code class="language-Objective-C">//导入 CYLTabBarController.h
#import &quot;CYLTabBarController.h&quot;

- (void)viewDidLoad {
    [super viewDidLoad];
    CYLTabBarController *tabbarController = [self cyl_tabBarController];
    /*...*/
}
</code></pre>

<h4 id="toc_14">点击 PlusButton 跳转到指定 UIViewController</h4>

<p>提供了一个协议方法来完成本功能：</p>

<p><img src="http://i68.tinypic.com/2who9rs.jpg" alt="enter image description here"/></p>

<p>实现该方法后，能让 PlusButton 的点击效果与跟点击其他 TabBar 按钮效果一样，跳转到该方法指定的 UIViewController 。</p>

<p>注意：必须同时实现 <code>+indexOfPlusButtonInTabBar</code> 来指定 PlusButton 的位置。</p>

<p>遵循几个协议：</p>

<p><img src="http://i64.tinypic.com/14jw5zt.jpg" alt="enter image description here"/></p>

<p>另外你可以通过下面这个方法获取到 <code>PlusButton</code> 的点击事件：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>用法如下：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController {
    BOOL isSelected = CYLExternPlusButton.selected;
    if (isSelected) {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is selected&quot;);
    } else {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is not selected&quot;);
    }
    return YES;
}

</code></pre>

<h4 id="toc_15">让TabBarItem仅显示图标，并使图标垂直居中</h4>

<p>要想实现该效果，只需要在设置 <code>tabBarItemsAttributes</code>该属性时不传 title 即可。</p>

<p>比如：在Demo的基础上，注释掉图中红框部分：<br/>
<img src="http://i64.tinypic.com/2cwu8ok.jpg" alt="enter image description here"/></p>

<table>
<thead>
<tr>
<th>注释前</th>
<th>注释后</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i66.tinypic.com/2z3rj0z.jpg" alt="enter image description here"/></td>
<td><img src="http://i65.tinypic.com/29cp1r9.jpg" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>可以通过这种方式来达到 Airbnb-app 的效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<p>如果想手动设置偏移量来达到该效果：<br/>
可以在 <code>-setViewControllers:</code> 方法前设置 <code>CYLTabBarController</code> 的 <code>imageInsets</code> 和 <code>titlePositionAdjustment</code> 属性</p>

<p>这里注意：设置这两个属性后，<code>TabBar</code> 中所有的 <code>TabBarItem</code> 都将被设置。并且第一种做法的逻辑将不会执行，也就是说该做法优先级要高于第一种做法。</p>

<p>做法如下：<br/>
<img src="http://i66.tinypic.com/4rq8ap.jpg" alt="enter image description here"/></p>

<p>但是想达到Airbnb-app的效果只有这个接口是不行的，还需要自定义下 <code>TabBar</code> 的高度，你需要设置 <code>CYLTabBarController</code> 的 <code>tabBarHeight</code> 属性。你可以在Demo的 <code>CYLTabBarControllerConfig.m</code> 中的 <code>-customizeTabBarAppearance:</code> 方法中设置。</p>

<p>注：“仅显示图标，并使图标垂直居中”这里所指的“图标”，其所属的类是私有类： <code>UITabBarSwappableImageView</code>，所以 <code>CYLTabBarController</code> 在相关的接口命名时会包含 <code>SwappableImageView</code> 字样。另外，使用该特性需要 <code>pod update</code> 到 1.5.5以上的版本。</p>

<h4 id="toc_16">多TabBar嵌套，并指定PlusButton位置</h4>

<p>该功能的版本需要 &gt;= v1.17.4。</p>

<p>效果图：</p>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fmn3005isfg308r0iltl6.gif" alt="enter image description here"/></p>

<p>实现 PlusButton 的如下协议方法指定 context：</p>

<pre><code class="language-Objective-C">//CYLPlusButtonSubclassing
+ (NSString *)tabBarContext;

</code></pre>

<p>当该值与 TabBarController 的 context 能够匹配上，PlusButton 将会展示。如果 PlusButton 与 TabBarController 均未制定 context 值，那么默认 context 值是相等的。</p>

<p>目前仅支持一个 PlusButton 展示一次，不限层级。如果与多个 TabBarController 的 context 能够匹配上，仅展示在最先一次的匹配上的 TabBarController 上。</p>

<h4 id="toc_17">在 Swift 项目中使用 CYLTabBarController</h4>

<p>仓库中给出了一个Swift Demo，文件夹叫做 Example-Swift。</p>

<p>具体的编写步骤参考热心网友提供的教程： <a href="http://www.jianshu.com/p/c5bc2eae0f55?nomobile=yes">《从头开始swift2.1 仿搜材通项目（三） 主流框架Tabbed的搭建》</a> </p>

<p>这里注意，文章的示例代码有问题，少了设置 PlusButton 大小的代码：<br/>
这将导致 PlusButton 点击事件失效，具体修改代码如下：<br/>
<img src="http://i67.tinypic.com/118ottv.jpg" alt="enter image description here"/></p>

<h4 id="toc_18">搭配 Storyboard 使用 CYLTabBarController</h4>

<p><a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor">这里</a> ，里面有个文件夹CYLTabBarControllerTestDemo，这个Demo演示了如何搭配 Storyboard 使用。</p>

<h4 id="toc_19">源码实现原理</h4>

<p>参考： <a href="http://www.jianshu.com/p/8758d8014f86">《[Note] CYLTabBarController》</a> </p>

<p>更多文档信息可查看 <a href="http://cocoadocs.org/docsets/CYLTabBarController/1.2.1/index.html"> <strong><em>CocoaDocs：CYLTabBarController</em></strong> </a> 。</p>

<h3 id="toc_20">FAQ</h3>

<p>更多Q-A内容，可以在这里查看： <a href="https://github.com/ChenYilong/CYLTabBarController/issues?utf8=%E2%9C%93&amp;q=+label%3AQ-A+">issue-FAQ</a> <br/>
Q：为什么放置6个TabBarItem会显示异常？</p>

<p>A：</p>

<p>Apple 规定：</p>

<blockquote>
<p>一个 <code>TabBar</code> 上只能出现最多5个 <code>TabBarItem</code> ，第六个及更多的将不被显示。</p>
</blockquote>

<p>另外注意，Apple检测的是 <code>UITabBarItem</code> 及其子类，所以放置“加号按钮”，这是 <code>UIButton</code> 不在“5个”里面。</p>

<p>最多只能添加5个 <code>TabBarItem</code> ，也就是说加上“加号按钮”，一共最多在一个 <code>TabBar</code> 上放置6个控件。否则第6个及之后出现 <code>TabBarItem</code> 会被自动屏蔽掉。而且就Apple的审核机制来说，超过5个也会被直接拒绝上架。</p>

<p>Q：我把 demo 两侧的 item 各去掉一个后，按钮的响应区域就变成下图的样子了：<br/>
 <img src="https://cloud.githubusercontent.com/assets/12152553/10725491/62600172-7c07-11e5-9e0a-0ec7d795d1e3.jpeg" alt="wechat_1445851872"/></p>

<p>A：v1.5.5 版本已经修复了该问题，现在不会出现类似的问题了：点击按钮区域却不响应，响应区域有偏移。</p>

<p>Q： 如何实现添加选中背景色的功能 ，像下面这样：<br/>
<img width="409" alt="screen shot 2015-10-28 at 9 21 56 am" src="https://cloud.githubusercontent.com/assets/7238866/10777333/5d7811c8-7d55-11e5-88be-8cb11bbeaf90.png"></p>

<p>A：我已经在 Demo 中添加了如何实现该功能的代码：<br/>
详情见 <code>CYLTabBarControllerConfig</code>  类中下面方法的实现：</p>

<pre><code class="language-Objective-C">/**
 *  更多TabBar自定义设置：比如：tabBarItem 的选中和不选中文字和背景图片属性、tabbar 背景图片属性
 */
- (void)customizeTabBarAppearance:(CYLTabBarController *)tabBarController;

</code></pre>

<p>效果如下：<br/>
<img src="https://cloud.githubusercontent.com/assets/2911921/10779397/34956b0a-7d6b-11e5-82d9-fa75aa34e8d0.png" alt="simulator screen shot 2015 10 28 11 44 32"/></p>

<p>Q: 当 <code>ViewController</code> 设置的 <code>self.title</code> 和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候，会出现如图的错误，排序不对了</p>

<p>A：在 v1.0.7 版本中已经修复了该 bug，但是也需要注意：</p>

<p>请勿使用 <code>self.title = @&quot;同城&quot;;</code> 这种方式，请使用 <code>self.navigationItem.title = @&quot;同城&quot;;</code> </p>

<p><code>self.title = @&quot;同城&quot;;</code> 这种方式，如果和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候可能会导致如下现象（不算 bug，但看起来也很奇怪）：</p>

<p><img src="http://i68.tinypic.com/282l3x4.jpg" alt="enter image description here"/></p>

<p>规则如下：</p>

<pre><code class="language-Objective-C">
    self.navigationItem.title = @&quot;同城&quot;;    //✅sets navigation bar title.The right way to set the title of the navigation
    self.tabBarItem.title = @&quot;同城23333&quot;;   //❌sets tab bar title. Even the `tabBarItem.title` changed, this will be ignored in  tabbar.
    self.title = @&quot;同城1&quot;;                  //❌sets both of these. Do not do this‼️‼️ This may cause something strange like this : http://i68.tinypic.com/282l3x4.jpg 

</code></pre>

<p>Q :  当使用这个方法时 <code>-[UIViewController cyl_popSelectTabBarChildViewControllerAtIndex:]</code> 系列方法时，会出现如下的黑边问题。</p>

<p><img src="http://i63.tinypic.com/bg766g.jpg" alt="enter image description here"/></p>

<p>A： 这个是 iOS 系统的BUG，经测试iOS9.3已经修复了，如果在更早起版本中出现了，可以通过下面将 <code>rootWindow</code> 的背景色改为白色来避免：比如你可以 <code>Appdelegate</code> 类里这样设置：</p>

<pre><code class="language-Objective-C">//#import &quot;CYLTabBarController.h&quot;
    [[self cyl_tabBarController] rootWindow].backgroundColor = [UIColor whiteColor];
</code></pre>

<p>Q:我现在已经做好了一个比较简单的中间凸起的 icon 但是超过了49这个高度的位置是不能效应的  我想请问你的demo哪个功能是可以使我超出的范围也可以响应的呢?</p>

<p>A: 这个是自动做的，但是 <code>CYLTabBarController</code> 只能保证的是：只要是 <code>UIButton</code> 的 frame 区域内就能响应。</p>

<p>请把 button 的背景颜色设置为显眼的颜色，比如红色，比如像下面的plus按钮，红色部分是能接收点击事件的，但是超出了红色按钮的，黄色的图片区域，依然是无法响应点击事件的。</p>

<p><img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>这是因为，在响应链上，<code>UIControl</code> 能响应点击事件， <code>UIImage</code> 无法响应。</p>

<p>Q：为什么在iOS10上会Crash，iOS9上不会？</p>

<p>A：<br/>
  在注册加号按钮时，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C"> + (void)load {
    [super registerPlusButton];
}
</code></pre>

<p>Q: 我的样式是点击 <code>plusButton</code> 后跳转到一个 <code>ViewController</code>，但是选中了一次中间的 <code>plusButton</code> 之后，再点别的 <code>tabItem</code> ，中间不会变成 <code>normal</code> 的状态。</p>

<p>A: 有两种情况会造成这个问题：</p>

<ol>
<li><p>应该是你的 <code>tabBar</code> 设置了 <code>delegate</code> 了，你要是 <code>tabBar</code> 的代理没设置的话，默认会有这个 <code>selected</code> 状态切换的处理。你设置代理后，会覆盖我的行为。所以手动加上就好了。</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
return YES;
}
</code></pre></li>
<li><p><code>plusButton</code> 添加了自定义点击事件或者自定义手势，因为这样会造成点击事件冲突或手势冲突，当需要 <code>pushViewController</code> 的时候，这个库会自动的添加点击事件，你这里重新加了点击事件所以冲突了；</p>

<p>在你项目的基础，把 <code>plusButton</code> 的点击事件取消掉,也就是 <code>addTarget</code> 这一行注释掉，手势事件也同理，应该就ok了</p></li>
</ol>

<p>A: <code>PlusButton</code> 与其他的 <code>TabBarItem</code> 距离没有平均分布 </p>

<p>(对应于 <a href="https://github.com/ChenYilong/CYLTabBarController/issues/36#issuecomment-269165471">issue#36</a> )</p>

<p>把这 Demo 里的这一行代码改下：</p>

<pre><code class="language-Objective-C">[button sizeToFit];
</code></pre>

<p>改成：</p>

<pre><code class="language-Objective-C">button.frame = CGRectMake(0.0, 0.0, w, h);
</code></pre>

<p>那么如果单是放一个照相机的图片，一般是多大的尺寸？</p>

<p>这个要看设计图，通常情况下，你可以写死与其他TabBarItem一样大小：</p>

<pre><code class="language-Objective-C"> [UIScreen mainScreen].bounds.size.width / [CYLTabBarController allItemsInTabBarCount]
</code></pre>

<hr/>

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 2 ->]]></title>
    <link href="www.freefook.com/15142759656625.html"/>
    <updated>2017-12-26T16:12:45+08:00</updated>
    <id>www.freefook.com/15142759656625.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 3 ->]]></title>
    <link href="www.freefook.com/15142759962160.html"/>
    <updated>2017-12-26T16:13:16+08:00</updated>
    <id>www.freefook.com/15142759962160.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 4 ->]]></title>
    <link href="www.freefook.com/15142759959034.html"/>
    <updated>2017-12-26T16:13:15+08:00</updated>
    <id>www.freefook.com/15142759959034.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 5 ->]]></title>
    <link href="www.freefook.com/15142759955738.html"/>
    <updated>2017-12-26T16:13:15+08:00</updated>
    <id>www.freefook.com/15142759955738.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 6 ->]]></title>
    <link href="www.freefook.com/15142759953924.html"/>
    <updated>2017-12-26T16:13:15+08:00</updated>
    <id>www.freefook.com/15142759953924.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 7 ->]]></title>
    <link href="www.freefook.com/15142759949984.html"/>
    <updated>2017-12-26T16:13:14+08:00</updated>
    <id>www.freefook.com/15142759949984.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 8 ->]]></title>
    <link href="www.freefook.com/15142759939184.html"/>
    <updated>2017-12-26T16:13:13+08:00</updated>
    <id>www.freefook.com/15142759939184.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发说明]]></title>
    <link href="www.freefook.com/15139213651453.html"/>
    <updated>2017-12-22T13:42:45+08:00</updated>
    <id>www.freefook.com/15139213651453.html</id>
    <content type="html"><![CDATA[
<pre><code>what？

项目分配下来后，针对一些疑问的解释说明。
针对一些项目中开发事宜，做一些解释说明。
针对一些项目中重复代码，做一些记录，不管在哪个电脑，哪个项目，写的时候，可以copy。

why?

避免一些情况 “开发做了很多，布局调整导致缝缝补补的局面”。
所以有经验的开发人员总会说一句，就是“不管简单或复杂的页面，都不要写死了。
谁知道哪天甲方/产品说这里很简单，改一下吧，那个很简单，改一下吧”
如果你没时间改，那别给队友带刀啊。
所以统一规范，统一大块的思路，在程序中增加说明文件，减少上班带刀的同事，避免做地铁过安检的问题。

how?

建项开始:
1. 项目问题汇总
2. 建项使用三方管理工具cocoapods
3. 建项创建.pch文件
4. 建项那些.pch里写了些什么
5. 建项权限、网络问题
6. 建项屏幕适配问题
</code></pre>

<h4 id="toc_0">简单的编码中规范说明</h4>

<p>程序开始增加说明文件</p>

<pre><code>说明文件，记录项目功能实现的思维说明：
1.MVC  MVVM MVCS 等放荡不羁的模式
2.复杂UI的实现说明或使用了他人封装类库，注明使用方法示例；
3.网络请求方式，加密方式，部数据处理方式；
4.本地数据的存储方式
5.复杂业务逻辑的流程说明，与实现后遗留缺陷。
6.写出你认为程序中还遗留的缺陷， bug，改进，优化的地方
</code></pre>

<h4 id="toc_1">程序开发过程中命名方式</h4>

<blockquote>
<p>大家公认无岐义的缩写(比如：nav，bg，btn等)<br/>
写在哪些命名里都可以</p>
</blockquote>

<h5 id="toc_2">类命名：前缀+描述+类型</h5>

<pre><code>1.创建一个类时，增加自己名字首字母的简写例如：张东 ZDLoginViewController
2.ViewController 是处理业务逻辑，UI 代码 数据请求与处理 尽量不要写太多
3.view的生命周期的几个方法 在类中方法的最上方
4.类中方法增加Mark（#pragma - mark - 点击登录，请求登录接口 ）

</code></pre>

<h5 id="toc_3">属性命名：描述性单词+变量类型</h5>

<pre><code>UILabel* nameLabel;
</code></pre>

<h5 id="toc_4">方法命名</h5>

<pre><code>一个规范的方法读起来应该像一句完整的话，读过之后便知函数的作用。
返回性的方法应该以返回的内容开头，但之前不要加get。
不要各种缩写，写完猜不出意思。保持完整性

</code></pre>

<h5 id="toc_5">函数命名</h5>

<pre><code>一些典型操作应该使用约定的动词，如initWith,insert,remove,replace,add等等。
</code></pre>

<h5 id="toc_6">程序中使用的图片命名</h5>

<pre><code>在Assets.xcassets里创建相应使用的功能模块文件夹
例如：personalCenter 文件里放登录、注册、我的信息用到的图片
图片命名 类型+模块/功能 例如：btn/bg_login_normal@3x.png 
</code></pre>

<h5 id="toc_7">代码注释</h5>

<pre><code>代码的注释问题:很多人的注释过于粗糙,有些甚至都没有注释习惯,导致代码可读性差,
版本迭代或是需求变更的时候不能及时定位到具体代码；

注释方式例如：
/** 名字 */
@property(nonatomic,strong)NSString* name;

这样注释的好处是:
当你调用这个属性时会具有相关备注提示

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目问题汇总]]></title>
    <link href="www.freefook.com/15139392949146.html"/>
    <updated>2017-12-22T18:41:34+08:00</updated>
    <id>www.freefook.com/15139392949146.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">遇到的小问题却忽略的必然问题项如下：</h5>

<h6 id="toc_1">不明确问题：</h6>

<ol>
<li>项目都有哪些功能？不明确？</li>
<li>适配的系统与屏幕大小？</li>
<li>是否需要检测网络，无网络或者无数据页面如何处理？</li>
<li>例如：显示无数据页面，点击按钮重新请求？</li>
<li>某些数据内容展示不开时：显示一行即可/多行？</li>
<li>提示语的说明?</li>
<li>本地数据存储是否多？</li>
<li>业务复杂逻辑流程图？各端统一，麻烦也要统一做。</li>
</ol>

<h6 id="toc_2">不明确的功能项：</h6>

<ol>
<li>列表 tableview 是否有动态行高？</li>
<li>哪些是必须登录才可看的页面？</li>
<li>登录后是否有页面乱push 与pop 的情况？</li>
<li>热点问题是否有适配的价值，例如：京东曾不适配。</li>
</ol>

<h6 id="toc_3">必须有的功能项：</h6>

<ol>
<li>网络请求的日志信息，如何处理?和接口人员商议</li>
<li>需要增加闪退统计例如：集成极光。</li>
</ol>

<h6 id="toc_4">接口问题：</h6>

<ol>
<li>有通知功能时登录接口不是必传通知获取的token/channel_id？</li>
<li>接口返回问题返回数组的时候是空数组，还是空对象？</li>
</ol>

<h6 id="toc_5">UI问题:</h6>

<ol>
<li>设计图是根据多大屏幕作图？</li>
<li>不规则切图用规则型的透明背景切图.</li>
<li>如tabbar底部选项卡的图，大小统一.</li>
<li>个人中心等同位置图标 大小统一.</li>
</ol>

<p>以上问题会在下面 建项的各个阶段给出处理方式；</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-使用三方管理工具cocoaPods]]></title>
    <link href="www.freefook.com/15139117675584.html"/>
    <updated>2017-12-22T11:02:47+08:00</updated>
    <id>www.freefook.com/15139117675584.html</id>
    <content type="html"><![CDATA[
<p>我们都用哪些三方呢？例如：<br/>
1.  --极光的统计：可查看闪退日志（必须要有首先就要集成）<br/>
2.  --可能用到的推送，可用极光的推送<br/>
3.  --网络请求  AFNetWorking<br/>
4.  --刷新  MJRefresh<br/>
5.  --图片加载  SDWebImage<br/>
6.  --用于加载的loading和提示框  MBProgressHUD<br/>
7.  --用于解决输入框被键盘遮挡的问题  IQKeyBoardManager<br/>
8.  --用于布局约束  Masonry<br/>
9.  --加在程序中,解决NUll问题  nullSafe.m</p>

<pre><code>使用三方管理工具cocoapods
1、Ruby环境搭建
查看下当前ruby版本：打开终端输入 ruby -v

如果需要更新，进行如下操作更改Ruby镜像：

gem sources --remove https://rubygems.org/ 
gem sources -a https://gems.ruby-china.org/
gem sources -l  （用来检查使用替换镜像位置成功与否）

最后 输入  rvm install 2.2.4  更新ruby


2、下载安装CocoaPods
终端输入：sudo gem install cocoapods 

结束之后：
终端cd 到自己的项目文件下Create a Podfile

终端输入touch Podfile
       open -a Xcode Podfile


写上如下内容：
target &#39;MyApp的名’ do
  pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1’
end

执行 pod install 就OK了

查询三方版本可用 pod search afnetworking  （不区分大小写）
第一次安装完pod 进行搜索需要多等一段时间，
会卡在Creating search index for spec repo &#39;master&#39;..    

CocoaPods的基本安装及使用都详细的说明了，
当需要同时导入多个第三方时候怎么办 ？
这就需要修改Podfile了，就是用vim编辑的那个保存在项目根目录中的文件，
修改完了Podfile文件，需要重新执行一次pod install命令。
</code></pre>

<h5 id="toc_0">例如</h5>

<pre><code>target &#39;myApp’ do
pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1’
pod &#39;MJRefresh&#39;, &#39;~&gt; 3.1.15.1&#39;
pod &#39;SDWebImage&#39;, &#39;~&gt; 4.2.2&#39;
pod &#39;MBProgressHUD&#39;, &#39;~&gt; 1.1.0&#39;
pod &#39;IQKeyboardManager&#39;, &#39;~&gt; 5.0.7&#39;
pod &#39;Masonry&#39;, &#39;~&gt; 1.1.0&#39;
pod &#39;NullSafe&#39;, &#39;~&gt; 1.2.3&#39;
pod &#39;CYLTabBarController&#39;, &#39;~&gt; 1.17.4&#39;
pod &#39;SDCycleScrollView&#39;, &#39;~&gt; 1.75&#39;
pod &#39;MJExtension&#39;, &#39;~&gt; 3.0.13&#39;
pod &#39;FMDB&#39;, &#39;~&gt; 2.7.2&#39;
pod &#39;SDAutoLayout&#39;, &#39;~&gt; 2.2.0&#39;
end
</code></pre>

<h5 id="toc_1">Podfile 如上简单的写法 会报警告 默认platform：iOS9</h5>

<blockquote>
<p>The Podfile is a specification that describes the dependencies of the targets of one or more Xcode projects.</p>
</blockquote>

<p>A Podfile can be very simple:</p>

<pre><code>target &#39;MyApp&#39;
pod &#39;AFNetworking&#39;, &#39;~&gt; 1.0&#39;
</code></pre>

<p>An example of a more complex Podfile can be:</p>

<pre><code>platform :ios, &#39;9.0&#39;
inhibit_all_warnings!

target &#39;MyApp&#39; do
  pod &#39;ObjectiveSugar&#39;, &#39;~&gt; 0.5&#39;

  target &quot;MyAppTests&quot; do
    inherit! :search_paths
    pod &#39;OCMock&#39;, &#39;~&gt; 2.0.1&#39;
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    puts &quot;#{target.name}&quot;
  end
end
</code></pre>

<h5 id="toc_2">参考如下：</h5>

<pre><code> iOS安装CocoaPods详细过程
 请查看:(http://www.jianshu.com/p/9e4e36ba8574)
 
 cocoapods报错问题You need at least git version 1.8.5 to use CocoaPods
 请查看:(http://www.jianshu.com/p/a1ab3b291f55)
 
 使用cocoapods时常见错误
 请查看:(http://www.jianshu.com/p/dfc7b93e67eb)
 
 iOS 下 Podfile 使用方法
 请查看:(http://www.cnblogs.com/Kennytian/p/6413734.html)
 
 如果出现下面问题,请尝试:cocoapods 出现 &quot;_OBJC_CLASS_$--&quot;, 
 referenced from:的问题target-&gt;build setting
  -&gt;other link flags 添加一个$(inherited) 
  
  
  
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 9 ->]]></title>
    <link href="www.freefook.com/15142760505102.html"/>
    <updated>2017-12-26T16:14:10+08:00</updated>
    <id>www.freefook.com/15142760505102.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[联系方式]]></title>
    <link href="www.freefook.com/15139235853705.html"/>
    <updated>2017-12-22T14:19:45+08:00</updated>
    <id>www.freefook.com/15139235853705.html</id>
    <content type="html"><![CDATA[
<p>邮箱：<a href="mailto:jsjzdd_2014@126.com">jsjzdd_2014@126.com</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARKit 看我就受够了]]></title>
    <link href="www.freefook.com/15139220095625.html"/>
    <updated>2017-12-22T13:53:29+08:00</updated>
    <id>www.freefook.com/15139220095625.html</id>
    <content type="html"><![CDATA[
<p>因为有项目需求ARKit，查询后反馈的文档<br/>
现发布出来，还没注明转载出自哪里，见谅，找到地址时补齐；</p>

<p><a href="https://developer.apple.com/documentation/arkit">https://developer.apple.com/documentation/arkit</a><br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-3bdc5004b7ecbc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>截图</p>

<h3 id="toc_0">AR增强现实技术</h3>

<p>在即将发布的iOS11系统上，ARKit正式成为iOS系统框架，让开发者能够使用OC或swift语言开发AR类型的APP。<br/>
ARKit的大部分计算都是在CPU上处理的，在A8处理器上的性能损耗在15%~ 25%,<br/>
在A9处理器上的性能损耗在10% ~ 15%。为了更好的体验，所以苹果仅支持 A9 及以上处理器<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-2eaafcbc013d5c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>AR支持系列</p>

<h4 id="toc_1">ARKit 实现测量尺功能：</h4>

<p>实现该功能原理:收集相机的视觉信息，以及手机中传感器，包括陀螺仪、罗盘和加速度计来计算并确定设备的位置。<br/>
当然，这都是基于ARKit开发的，不想深入，想深入，深入，入...</p>

<blockquote>
<p>•多媒体捕捉现实图像:如摄像头<br/>
•三维建模:3D立体模型<br/>
•传感器追踪:主要追踪现实世界动态物体的六轴变化，这六轴分别是X、Y、Z轴位移及旋转。其中位移三轴决定物体的方位和大小，旋转三轴决定物体显示的区域。<br/>
•坐标识别及转换:3D模型显示在现实图像中不是单纯的坐标点，而是一个三维的矩阵坐标</p>
</blockquote>

<h4 id="toc_2">注意:</h4>

<ol>
<li><p>如果手机中的场景越丰富，那么测量的结果也就越精确。如果想要测量一面白墙的长度，暂时还不是很准确。AR应用是通过“特征点”进行识别的,也因为是三维矩阵坐标，要求测量时必须很稳的在同一个 Z 轴高度上测量平面的长度;</p></li>
<li><p>不要期望 AR检测的平面会完全贴合表面，虽然检测到了平面但角度可能不完全正确，所以如果开发的AR app需要获得非常精确的几何体来提供更好的效果，可能会出现问题</p></li>
<li><p>边缘检测不是特别好，实际的平面范围有时会太大或太小，所以不要尝试做需要准确边缘的 ARapp</p></li>
</ol>

<h4 id="toc_3">ARKit还存在一些问题:</h4>

<blockquote>
<p>ARKit是基于惯性-视觉来做空间定位的，这项技术会将iOS设备的动作感测硬件信息，加上对可见场景的计算机视觉分析功能，然后与设备的摄像头相结合，需要平稳缓慢的移动+转向手机，才能构建更加准确的世界，这对用户来说是一种考验，需要积极提示。</p>

<p>一旦刚开始检测平面失败，出现时间久，飘逸的现象，后期很难再正确检测，要强制重启。</p>

<p>AVFoudation与ARSession之间的切换会有轻微的卡顿，切换后ARSession就停止摄像头采集了，但3D渲染会继续，只是丧失了空间定位与检测识别的能力.</p>

<p>不支持前置摄像头。ARKit并不是一个用于前置摄像头环境的技术，因为空间有限，能提供的信息也非常有限。100米左右是ARKit在保持较好用户体验的最大测量距离。</p>

<p>ARKit没有计划支持连接两个不同ARKit世界。</p>
</blockquote>

<h4 id="toc_4">要建立高品质的 AR 体验，那么请注意下述这些注意事项和提示:</h4>

<blockquote>
<p>全局追踪是一项不精确的科学 (inexact science)。<br/>
尽管在这个过程当中，经常会产生可观的准确度，从而让AR 的体验更加真实。然而，它严重依赖于设备物理环境的相关细节，而这些细节并不总是一致，有些时候也难以实时测量，这也就导致这些物理细节往往都会存在某种程度的错误。</p>

<p>基于可见的照明条件来设计AR场景。<br/>
全局追踪涉及到了图像分析的相关内容，因此就需要我们提供清晰的图像。如果摄像头没有办法看到相关的物理细节，比如说摄像头拍到的是一面空空如也的墙壁，或者场景的光线实在太暗的话，那么全局追踪的质量就会大大降低。</p>

<p>根据追踪质量的相关信息来给用户进行反馈提示。<br/>
全局追踪会将图像分析与设备的动作模式关联起来。如果设备正在移动的话，那么ARKit 就可以更好地对场景进行建模，这样即便设备只是略微晃动，也不会影响追踪质量。但是一旦用户的动作过多、过快或者晃动过于激烈，就会导致图像变得模糊，或者导致视频帧中要追踪的特征之间的距离过大，从而致使追踪质量的降低。ARCamera类能够提供追踪状态，此外还能提供导致该状态出现的相关原因，您可以在 UI 上展示这些信息，告诉用户如何解决追踪质量低这个问题。</p>

<p>给水平面检测预留点时间来生成清晰的结果，一旦您获得所需的结果后，就禁用水平面检测。一开始对水平面进行检测的时候，所检测到的水平面位置和范围很可能不准确。不过随着时间的推移，只要水平面仍然保持在场景当中，<br/>
那么 ARKit 就能够较为精确地估计水平面的位置和范围。当场景中有一个比较大的平坦表面的话，就算您已经使用过这个水平面来放置内容，那么 ARKit 可能还会继续对水平面的锚点位置、范围和变换点进行修正 。</p>
</blockquote>

<p>综上所述:ARKit 实现测量尺功能，对物理环境要求较高，<br/>
第一，环境光检测，清晰的获取摄像头的帧图像;<br/>
第二，平面检测，准确的获取水平面，如果精确测量，需要边缘化检测准确;<br/>
第三，运动追踪稳定准确等外部因素，对环境和用户操作要求较高;</p>

<h4 id="toc_5">后记补充：</h4>

<p>ARKit是有环境光估计的，这个功能会通过摄像头捕捉并计算捕捉到的场景中的光的总量，来给虚拟物体施加正确的光照条件，渲染效果更加真实。环境光的模拟对于AR出来的画面的真实感，还是有非常大的影响的。</p>

<h5 id="toc_6">在此说一下ARKit没有提供图像识别方面的功能，所以平时可能看到身边有的AR场景是可以识别特定的图像做其他操作类型的App，用ARKit是不能实现的；</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-创建.pch文件]]></title>
    <link href="www.freefook.com/15139119793020.html"/>
    <updated>2017-12-22T11:06:19+08:00</updated>
    <id>www.freefook.com/15139119793020.html</id>
    <content type="html"><![CDATA[
<p>command+n 滑动到最底下other 里创建pch文件。<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-06ec44085a3c68e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="箭头所指三个选中.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-192ddcde4df0a66f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加粗的两项改动test是项工程名.png"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AES加密打开方式...]]></title>
    <link href="www.freefook.com/15139219514745.html"/>
    <updated>2017-12-22T13:52:31+08:00</updated>
    <id>www.freefook.com/15139219514745.html</id>
    <content type="html"><![CDATA[
<p>很久没写博客,Markdown牵出来遛遛</p>

<p>AES加密时需要统一的几个参数。</p>

<pre><code>密钥长度（Key Size）
加密模式（Cipher Mode）
填充方式（Padding）
初始向量（Initialization Vector）
</code></pre>

<blockquote>
<p>1.本例使用AES-128,</p>

<p>2.AES属于块加密BlockCipher，块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。本例使用CBC模式</p>

<p>3.由于块加密只能对特定长度的数据块进行加密，因此CBC、ECB模式需要在最后一数据块加密前进行数据填充。（CFB，OFB和CTR模式由于与key进行加密操作的是上一块加密后的密文，因此不需要对最后一段明文进行填充）<br/>
在iOS SDK中提供了PKCS7Padding</p>
</blockquote>

<p>ECB加密模式（不推荐）：容易被攻击</p>

<blockquote>
<p>1.每次key,明文,密文的长度都必须是64位;<br/><br/>
2.数据块重复排序不需要检测;<br/><br/>
3.相同的明文块(使用相同的密钥)产生相同的密文块,容易遭受字典被攻击<br/><br/>
4.一个错误仅仅会对一个密文块产生影响</p>
</blockquote>

<p>CBC加密方式(推荐):</p>

<blockquote>
<p>1.每次加密的密文长度为64位(8个字节);<br/><br/>
2.当相同的明文使用相同的密钥和初始向量的时候CBC模式总是产生相同的密文;<br/><br/>
3.密文块要依赖以前的操作结果,所以密文块不能进行重新排列;<br/><br/>
4.可以使用不同的初始化向量来避免相同的明文产生相同的密文,一定程度上抵抗字典攻击<br/>
5.一个错误发生后,当前和以后的密文都会被影响;</p>

<p>使用PKCS5Padding/PKCS7Padding填充可以兼容多平台语言之间AES加密解密  </p>

<p>注意: 这里每次产生的密文是相同的，因为设置了初试向量iv为16位个数的“0”。要产生不同的密文就要使用变化的初试向量iv</p>
</blockquote>

<p>ios使用案例  </p>

<p>创建一个类AESCipher继承NSObject</p>

<p>.h文件如下:</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
NSString * aesEncryptString(NSString *content, NSString *key);
NSString * aesDecryptString(NSString *content, NSString *key);
NSData * aesEncryptData(NSData *data, NSData *key);
NSData * aesDecryptData(NSData *data, NSData *key);

</code></pre>

<p>.m文件如下:</p>

<pre><code>#import &quot;AESCipher.h&quot;
#import &lt;CommonCrypto/CommonCryptor.h&gt;
//注意:初始向量,默认16个0(]前后端保持统一)
NSString const *kInitVector = @&quot;0000000000000000&quot;;
size_t const kKeySize = kCCKeySizeAES128;
NSData * cipherOperation(NSData *contentData, NSData *keyData, CCOperation operation) {
    NSUInteger dataLength = contentData.length;
    void const *initVectorBytes = [kInitVector dataUsingEncoding:NSUTF8StringEncoding].bytes;
    void const *contentBytes = contentData.bytes;
    void const *keyBytes = keyData.bytes;
    size_t operationSize = dataLength + kCCBlockSizeAES128;
    void *operationBytes = malloc(operationSize);
    size_t actualOutSize = 0;
    CCCryptorStatus cryptStatus = CCCrypt(operation,                                   kCCAlgorithmAES,                                   kCCOptionPKCS7Padding,
 keyBytes,                                      kKeySize,                                     initVectorBytes,                                    contentBytes,                                     dataLength,                                     operationBytes,                                    operationSize,                                   &amp;actualOutSize);
    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:operationBytes length:actualOutSize];
    }
    free(operationBytes);
    return nil;
}
NSString * aesEncryptString(NSString *content, NSString *key) {
    NSData *contentData = [content dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    NSData *encrptedData = aesEncryptData(contentData, keyData);
    return [encrptedData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed];
}
NSString * aesDecryptString(NSString *content, NSString *key) {
    NSData *contentData = [[NSData alloc] initWithBase64EncodedString:content options:NSDataBase64DecodingIgnoreUnknownCharacters];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    NSData *decryptedData = aesDecryptData(contentData, keyData);
    return [[NSString alloc] initWithData:decryptedData encoding:NSUTF8StringEncoding];
}
NSData * aesEncryptData(NSData *contentData, NSData *keyData) {
    NSString *hint = [NSString stringWithFormat:@&quot;The key size of AES-%lu should be %lu bytes!&quot;, kKeySize * 8, kKeySize];
    NSCAssert(keyData.length == kKeySize, hint);
    return cipherOperation(contentData, keyData, kCCEncrypt);
}
NSData * aesDecryptData(NSData *contentData, NSData *keyData) {
    NSString *hint = [NSString stringWithFormat:@&quot;The key size of AES-%lu should be %lu bytes!&quot;, kKeySize * 8, kKeySize];
    NSCAssert(keyData.length == kKeySize, hint);
    return cipherOperation(contentData, keyData, kCCDecrypt);
}
</code></pre>

<p>使用方法如下:</p>

<pre><code>/*
 使用案例:
 第一: 导入头文件
 #import &quot;AESCipher.h&quot;
 测试字符串
 NSString *TestStr = @&quot;abc&quot;;
 设置key
 NSString *key = @&quot;1234567812345678&quot;;
 NSString *cipherText = aesEncryptString(TestStr, key);
 NSLog(@&quot;加密==%@&quot;, cipherText);
 NSString *decryptedText = aesDecryptString(cipherText, key);
 NSLog(@&quot;解密==%@&quot;, decryptedText);
 */
</code></pre>

<p>原文查看:<br/>
 <a href="http://blog.csdn.net/u013749540/article/details/70225594">http://blog.csdn.net/u013749540/article/details/70225594</a><br/>
 <a href="http://www.cnblogs.com/dcb3688/p/4608007.html">http://www.cnblogs.com/dcb3688/p/4608007.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[互动直播变身视频会议]]></title>
    <link href="www.freefook.com/15139219144104.html"/>
    <updated>2017-12-22T13:51:54+08:00</updated>
    <id>www.freefook.com/15139219144104.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">视频会议</h2>

<blockquote>
<p>初试水: 需求是13人同屏视频会议,最多进入视频会议房间的人数上线也就是13人;<br/>
也因最大障碍网络问题,设备问题,<br/>
很难支撑稳定的长时间连接这么多路的视频通话而被放弃;</p>

<p>在思考: 用互动直播模式,改进视频会议方案<br/>
为了视频会议的稳定性:减少至视频人员数量(4人),<br/>
现有APP调查: QQ视频同时4人;微信支持9人;<br/>
直播类属于连麦, YY4人 ,直播类有多的是连6人;<br/>
淘宝旗下的产品,钉钉视频会议5人;</p>

<p>方案一:因为视频人员数量只有4人,后台创建会议时应设置有权限视频的人员;<br/>
其余人默认观众模式,只可语音;<br/>
这就抛出了第一个问题?<br/>
谁能视频会议,分配给谁这个权限的问题?<br/>
所以:后台添加开会人员时;分配视频权限;(谁是视频显示,其他人默认语音)<br/>
房间只能是有视频权限的人创建,谁是房主有最高权限,这个人是</p>
</blockquote>

<h1 id="toc_1">一. 网易云互动直播</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-c7961d44fe677e47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.30.36.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-812f5105d2624c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.36.55.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-2a227a96dae9afb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.32.17.png"/></p>

<h4 id="toc_2">功能概述</h4>

<blockquote>
<p>网易云通信的互动直播功能，支持主播和观众实时连麦互动。<br/>
互动直播由连麦互动和直播两部分组成，其中连麦互动基于音视频通话实现，可以实现1个主播+3个连麦者的音视频通话连麦（基于私有协议实现）。<br/>
主播和连麦者的音视频数据在互动直播高性能服务器合成为一道流后推流到CDN流媒体服务器，普通观众拉流观看即可（RTMP推流协议)</p>
</blockquote>

<h4 id="toc_3">互动直播接入流程</h4>

<blockquote>
<p>1.接入IM账号体系：单独的直播并不需要接入账号体系，但是互动连麦是基于音视频通话做的，音视频通话是基于IM的账号体系的，所以这边需要给主播和连麦者都分配IM账号。由服务端创建IM账号;<br/>
2.客户端接入IM的SDK，登录IM<br/>
3.客户端接入音视频通话SDK，实现主播和连麦者的音视频通话。（互动直播基于音视频多人会议开发，通过将多人会议中用户的音视频数据处理后推送给视频流服务器实现直播和实时连麦。 在功能的提供上，互动直播复用多人音视频接口，增加互动开关、推流地址指定与切换、直播角色指定等扩展设置）<br/>
4.接入直播，服务端创建频道后获取推流地址，在主播端设置该推流地址。<br/>
5.观众使用该推流地址对应的拉流地址观看（支持HLS (m3u8)、RTMP、HTTP-FLV等拉流协议），可接入直播的拉流播放器。</p>
</blockquote>

<h4 id="toc_4">demo简介</h4>

<blockquote>
<p>互动直播Demo在互动连麦的基础上还接入了无人数上限的聊天室，来实现文字互动、点赞、送礼物等多种消息形式。<br/>
1.聊天室的是由服务端创建并管理的。客户端在登录IM成功后根据服务端提供的roomid加入聊天室即可。所以聊天室也是基于IM的账号体系的。<br/>
2.聊天室的消息收发。</p>
</blockquote>

<h4 id="toc_5">demo各功能说明：</h4>

<blockquote>
<p>1.注册，客户端获取注册信息后发给demo服务器，由demo服务器完成。（账号体系）<br/>
2.客户端初始化SDK，登录IM<br/>
3.demo服务器创建直播频道获取推拉流地址。<br/>
4.demo服务器创建聊天室。<br/>
5.主播客户端创建音视频通话房间，从demo服务器获取推流地址后，开启推流开关。<br/>
6.各客户端加入聊天室。<br/>
7.连麦者加入主播创建的音视频通话房间，和主播连麦互动。</p>
</blockquote>

<p>网易云互动直播地址:<a href="https://www.163yun.com/product/interact">https://www.163yun.com/product/interact</a></p>

<h1 id="toc_6">二. 腾讯云 互动直播ILVB</h1>

<blockquote>
<p>互动直播（Interactive Live Video Broadcasting）是全新的一站式“多路音视频互动”解决方案，主打“连麦”、“多画面特效”等能力；通过客户端SDK可打造跨平台一对多，多对多（支持最大同时<strong>8</strong>人上麦）的超清酷炫直播场景</p>
</blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-2e9adb38e8fa79b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.50.15.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-70b7b469c6e2cd0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.51.20.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-3380c4ef7ee31fb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.53.40.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-39dc0cb9cb7963dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午1.59.56.png"/></p>

<p><strong>数据交互时序说明</strong></p>

<pre><code>步骤1和2解释了独立帐号模式下，app用户完成腾讯互动直播身份认证的过程。

如果采用托管帐号模式，则不需要开发者server参与，直接调互动直播sdk login接口即可；
开播、观看、上麦等音视频接口的调用必须在进房间成功之后；
只要app业务逻辑允许，在调用相应的接口后，任何用户都有上麦能力；
开发者后台server可以通过腾讯互动直播给app里的用户或者群组push消息。
</code></pre>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-3fa0edd5258cff74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午2.01.36.png"/></p>

<h4 id="toc_7">后台接口已实现的功能</h4>

<blockquote>
<p>注册<br/>
    登录<br/>
    创建房间<br/>
    上报创建房间结果<br/>
    拉取直播房间列表<br/>
    上报进入房间信息<br/>
    拉取房间成员列表<br/>
    心跳上报<br/>
    申请上麦<br/>
    申请上麦结果上报<br/>
    录制视频完成上报<br/>
    退出房间<br/>
    拉取点播列表<br/>
    拉取旁路直播地址列表<br/>
    拉取指定房间的旁路直播地址<br/>
    下线</p>
</blockquote>

<h4 id="toc_8">客户端开启直播接口流程:</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-85bc4166c86ea4e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午2.06.47.png"/></p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-1aebc166c9efbf5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午2.07.17.png"/></p>

<p>腾讯云互动直播地址:<a href="https://cloud.tencent.com/document/product/268">https://cloud.tencent.com/document/product/268</a><br/>
价格地址:<a href="https://cloud.tencent.com/document/product/268/5127">https://cloud.tencent.com/document/product/268/5127</a></p>

<h1 id="toc_9">三. 阿里云直播</h1>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-20b86d34a12214b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午2.10.07.png"/></p>

<h5 id="toc_10">连麦介绍:</h5>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-a69c2696e42d1554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017-05-27 下午2.14.32.png"/></p>

<blockquote>
<p>连麦服务提供接入测试操作，可通过连麦参数配置接入连麦服务，测试阶段连麦服务做多支持5路连麦并发流。如果您想接入阿里云连麦服务，请与客户服务人员联系或提交工单申请。<br/>
阿里云连麦服务提供简单的配置，开通过程包括以下步骤<br/>
Step 1: 添加直播加速域名<br/>
Step 2: 创建连麦服务<br/>
Step 3：配置回调地址</p>
</blockquote>

<h5 id="toc_11">连麦参与者的职责和功能</h5>

<h6 id="toc_12">主播端</h6>

<blockquote>
<p>采集音视频信号并编码、推送直播流。<br/>
拉取副麦端的直播流。<br/>
将拉取的副麦端的直播流与本地采集的视频进行叠加播放。</p>
</blockquote>

<h6 id="toc_13">副麦端</h6>

<blockquote>
<p>采集音视频信号并编码、推送直播流。<br/>
拉取主播及其他副麦端的直播流。<br/>
将拉取的直播流与本地采集的视频进行叠加播放。</p>
</blockquote>

<h6 id="toc_14">观众端</h6>

<blockquote>
<p>播放混流地址中的直播流</p>
</blockquote>

<h6 id="toc_15">APP Server</h6>

<blockquote>
<p>管理直播或连麦过程中使用的地址，包括推流地址、播放地址和混流地址。<br/>
对直播或连麦业务进行管理<br/>
调用AliLive的混流接口和接受AliLive的回调，以实现服务端混流的功能。</p>
</blockquote>

<h6 id="toc_16">AliLive</h6>

<blockquote>
<p>接受直播流的推送<br/>
接受直播流的拉取<br/>
将多路直播流混合成一路，并输出<br/>
接受混合后的直播流的拉取</p>
</blockquote>

<h6 id="toc_17">注：</h6>

<blockquote>
<p>连麦过程中APP Server需要提供三类地址：推流地址、播放地址、混流地址。<br/>
1   推流地址是直播或副麦推送直播流的地址，仅供主播端和副麦端使用。<br/>
2   播放地址是用于观看主播或副麦的直播视频的地址，仅在连麦的过程中使用，且仅供主播端和副麦端使用。<br/>
3   混流地址是用于观看AliLive混合多路直播流的结果的地址，仅供观众端使用。混流地址可以在非连麦的过程中使用，此时播放的就是主播的画面（与主播的播放地址内容相同）；若在连麦过程中使用，播放的就是主播与副麦的混合画面。<br/>
4  观众播放的一定是混流地址。当观众参与连麦、成为副麦时，会结束混流地址的播放，并开始播放主播和其他副麦的直播地址；当副麦结束连麦、成为观众时，会结束播放主播和其他副麦的直播地址，重新开始播放混流地址。</p>
</blockquote>

<h5 id="toc_18">连麦的参与者</h5>

<p>连麦的过程有5种参与者：</p>

<blockquote>
<p>主播端：<br/>
主播的客户端。<br/>
副麦端：<br/>
正在与主播连麦的人的客户端。<br/>
观众端：<br/>
未参与连麦的、观看直播或他人连麦的人的客户端。<br/>
APP Server：<br/>
用于接收或转发连麦信号的服务端，由直播业务方自行开发，可以根据自身的业务逻辑来控制连麦的流程，也是混流功能的唯一调用方。<br/>
AliLive：<br/>
阿里云直播服务器，提供整个直播或连麦过程中所有直播流的接收、分发和混流服务。<br/>
注：当观众开始连麦后，我们称之为副麦；当副麦结束连麦后，我们称之为观众。</p>
</blockquote>

<h4 id="toc_19">典型业务流程</h4>

<pre><code>
本小节将描述一个典型业务流程的实线逻辑，从主播上线到观众加入连麦、连麦结束，最后主播退出直播为止。

主播发起直播与观众观看直播

    主播向APP Server发起直播请求。
    APP Server同意主播发起直播，并分配主播的推流地址、播放地址以及混流地址。
    主播通过推流地址开始推流。
    APP Server收到AliLive推流成功的回调，将主播放入直播列表，表示此时观众可以播放主播的直播流。
    观众A、B、C开始观看直播（即播放混流地址）。
    通知AppServer,用户A、B、C正在观看

主播发起连麦

    主播向APP Server发出请求，希望与观众A、B连麦。
    APP Server向观众A、B反馈主播的请求。
    观众A、B向APP Server发送同意主播连麦请求的信号。
    APP Server向观众A、B分配各自的推流地址，并发送主播流的播放地址。
    观众A、B开始连麦（即结束播放混流地址，开始推流、开始播放主播的播放地址）。
    APP Server收到AliLive给出的观众A、B推流成功的回调，将A、B的播放地址发送给主播和A、B、C。（注释1：此处观众C并不需要收到A、B的播放地址，是否收到A、B的播放地址对于观众C的播放没有任何影响。之所以收到这个消息主要是通知第三方观众有人加入连麦了。）
    主播开始与A、B进行连麦（即播放A、B的播放地址）。
    副麦A增加与B的连麦（即播放B的播放地址）。
    副麦B增加与A的连麦（即播放A的播放地址）。
    APP Server调用AliLive的混流接口，开始混流且A、B加入混流画面。至此，主播与A、B连麦成功。

副麦退出连麦

    副麦B向APP Server发送结束连麦的通知，然后结束连麦（即停止推流、停止播放主播和副麦A的播放地址，开始播放混流地址）。
    APP Server调用AliLive的混流接口，B退出混流画面
    APP Server发送副麦B退出直播的消息给主播及A、B、C。
    主播与B停止连麦（即结束播放B的播放地址）。
    副麦A与B停止连麦（即结束播放B的播放地址）。 

观众加入连麦

    观众C向APP Server发出申请，要求加入连麦。
    APP Server向主播和副麦A转发观众C的申请。
    主播和副麦A向APP Server发送同意连麦的信号。
    APP Server向观众C分配推流地址，并发送主播和副麦A的播放地址。
    观众C开始连麦（即结束播放混流地址，开始推流、开始播放主播和副麦A的播放地址）。
    APP Server收到AliLive给出的观众C推流成功的回调，将C的播放地址发送给主播和A、B、C。
    主播增加与C的连麦（即播放C的播放地址）。
    副麦A增加与C的连麦（即播放C的播放地址）。
    APP Server调用AliLive的混流接口，C加入混流画面。至此，观众C加入连麦成功。

主播终止连麦

    主播向APP Server发送终止连麦通知，并终止连麦（即结束播放副麦A、C的播放地址）。
    APP Server向主播和A、B、C发送终止连麦的信号。
    副麦A退出连麦（即结束推流、结束播放主播和副麦C的播放地址，开始播放混流地址）。
    副麦C退出连麦（即结束推流、结束播放主播和副麦A的播放地址，开始播放混流地址）。
    APP Server调用AliLive的混流接口，结束混流，A、C退出混流画面。至此，连麦终止。

主播结束直播

    主播向APP Server发送结束直播的通知，并结束推流。
    APP Server向观众A、B、C告知直播结束。
    观众A、B、C退出直播（即结束播放混流地址）。

注：无论是直播还是连麦的过程，推流是不可缺少的。主播会推流，副麦会推流。客户端SDK中就提供了能够实现推流功能的接口，这些接口中所谓的推流成功指的是直播流可以成功的发送出去。但这并不表示此时可以从服务端下载这些直播流并观看，只有收到AliLive中推流成功的回调后，才表示可以真正开始播放。
</code></pre>

<h4 id="toc_20">连麦服务开通与配置</h4>

<blockquote>
<p>I：提供需要连麦的域名和APP（连麦需要消耗大量服务端资源，业务上需要将连麦与非连麦的业务区分）<br/>
II：提供连麦的估计并发量<br/>
III：提供混流回调URL：混流可用回调和混流结果回调<br/>
IV：将上述三个信息提供给阿里云相关人员<br/>
V：在阿里云控制台上配置直播推断流回调</p>
</blockquote>

<p>阿里云连麦文档地址:<a href="https://help.aliyun.com/document_detail/52350.html?spm=5176.doc29951.6.650.DNEVno">https://help.aliyun.com/document_detail/52350.html?spm=5176.doc29951.6.650.DNEVno</a><br/>
价格地址:<a href="https://cn.aliyun.com/price/product#/live/detail">https://cn.aliyun.com/price/product#/live/detail</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac电脑清理存储空间]]></title>
    <link href="www.freefook.com/15139218767623.html"/>
    <updated>2017-12-22T13:51:16+08:00</updated>
    <id>www.freefook.com/15139218767623.html</id>
    <content type="html"><![CDATA[
<p>由于今天提示空间不足1G不得不来清理一下空间</p>

<h3 id="toc_0">清理后的空间:</h3>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-f0d2bd53eb590038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<h3 id="toc_1">以下诉说的是120G的悲伤</h3>

<h4 id="toc_2">第一步:先看一下那个文件目录下空间使用</h4>

<p>sudo du -sh /*</p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-742477290ff2ea3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<p>如果你使用xcode 可以做如下操作获得更多的空闲存储空间</p>

<h4 id="toc_3">操作1 :xcode移除DerivedData</h4>

<p>可重新生成；会删除build生成的项目索引、build输出以及日志。<br/>
路径：~/Library/Developer/Xcode/DerivedData</p>

<h4 id="toc_4">操作2 :删除DeviceSupport</h4>

<p>如果你是128G的本子,用xcode开发,空间不足时,<br/>
删除DeviceSupport里的吧,留两个自己经常使用的就够了<br/>
~/Library/Developer/Xcode/iOS DeviceSupport</p>

<h4 id="toc_5">操作3 :清除缓存文件</h4>

<p>cd ~/Library/Caches/<br/>
rm -rf ~/Library/Caches/*<br/>
不用命令行方式:<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-fe787cb2173e93c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<p>点击前往文件夹,输入:~/Library/Caches/<br/>
就看到文件目录了,删除caches下的文件即可;</p>

<h4 id="toc_6">操作4 :删除所有系统日志</h4>

<p>可以使用下面的命令删除：<br/>
sudo rm -rf /private/var/log/*<br/>
也可以在操作6中截图的路径文件夹看到Log文件夹,删除下面的文件就可以;</p>

<h4 id="toc_7">操作5 :删除临时文件路径</h4>

<p>cd /private/var/tmp/<br/>
也可以在操作6中截图的路径文件夹看到tmp文件夹,删除下面的文件就可以;</p>

<h4 id="toc_8">操作6 :禁用SafeSleep休眠模式</h4>

<p>当升级到OS X 10.9 Mavericks版本之后，显示隐藏文件命令如下：<br/>
//显示隐藏文件<br/>
defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder <br/>
//不显示隐藏文件<br/>
defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder </p>

<p>显示隐藏文件对照截图目录寻找<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-baedb9fac879bcb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/></p>

<p>防止OS X继续创建该文件，所以我们需要下面的命令生成一个无法被替换的空文件<br/>
1  touch sleepimage<br/>
2  chmod 000 /private/var/vm/sleepimage<br/>
如果你想要重新开启SafeSleep功能，只需下面的命令即可<br/>
1  sudo pmset -a hibernatemode 3<br/>
2  sudo rm /private/var/vm/sleepimage</p>

<h4 id="toc_9">操作7 :停止TimeMachine本地备份（这个看你个人喜欢）</h4>

<p>sudo tmutil disablelocal</p>

<h4 id="toc_10">操作8 :嗓音文件删除</h4>

<p>如果你不适用文字转语音功能，那么你肯定不会使用到OS X内置的嗓音文件。<br/>
你可以删除这些文件重新获得硬盘空间。<br/>
在终端应用中，使用下面的命令即可，首先定位到文件所在文件夹：<br/>
cd /System/Library/Speech/<br/>
然后执行删除命令，将所有嗓音文件删除<br/>
sudo rm -rf Voices/*<br/>
如果你执行了命令，那么你将无法使用系统的文字转语音功能。</p>

<h4 id="toc_11">操作9 :不建议尝试</h4>

<p>通过下面的命令移除缓存代码：<br/>
sudo rm -rf /private/var/folders/<br/>
但是别清除,出错了你又不知道怎么改好;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS  MQTT 接入示例]]></title>
    <link href="www.freefook.com/15139218580826.html"/>
    <updated>2017-12-22T13:50:58+08:00</updated>
    <id>www.freefook.com/15139218580826.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">前言</h4>

<blockquote>
<p>需求是移动端接入MQTT,点击按钮利用MQTT给门禁上的设备发送消息;<br/>
注:门禁设备(Android系统集成了MQTT和给硬件信息发送指令的包)<br/>
缺陷未解决: <br/>
1.门最后开没开成功,硬件是没有给反馈的,门禁设备也不知道;<br/>
2.移动设备消息发送了,指定的门禁设备是否收到消息,移动端还不知道;</p>

<p>该文介绍的是使用阿里的MQTT接入ios的说明<br/>
因给的demo里没有参数说明,看👇简单说明作为了解;</p>
</blockquote>

<h4 id="toc_1">MQTT协议中文版</h4>

<blockquote>
<p>MQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。<br/>
这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）<br/>
协议传送门:<a href="https://mcxiaoke.gitbooks.io/mqtt-cn/content/">https://mcxiaoke.gitbooks.io/mqtt-cn/content/</a></p>
</blockquote>

<h4 id="toc_2">MQTT应用场景</h4>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-a120f71ecd76f2e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照.png"/></p>

<h4 id="toc_3">MQTT 物联套件</h4>

<p>介绍 MQTT 协议基本概念，阿里巴巴 MQ 提供的 MQTT 服务的主要原理以及 MQTT 协议主要的应用场景<br/>
地址如下:<br/>
<a href="https://help.aliyun.com/document_detail/42419.html?spm=5176.doc47755.6.560.dcabYu">https://help.aliyun.com/document_detail/42419.html?spm=5176.doc47755.6.560.dcabYu</a></p>

<h4 id="toc_4">MQTT iOS 接入示例</h4>

<p>介绍如何使用 iOS 客户端收发 MQTT 消息地址如下:<br/>
<a href="https://help.aliyun.com/document_detail/47755.html?spm=5176.doc44711.6.633.pN8AIa">https://help.aliyun.com/document_detail/47755.html?spm=5176.doc44711.6.633.pN8AIa</a></p>

<h4 id="toc_5">iOS接入 非CocoaPods 安装配置</h4>

<p>滑动到👆示例地址的底部: 下载demo  拿到路径pods下的MQTTClient下的MQTTClient导入工程;<br/>
不要将LICENSE文件也导入进程序</p>

<h6 id="toc_6">不是CocoaPods安装,需要将如下头文件改成双引号&quot;&quot;</h6>

<pre><code>#import &lt;MQTTClient/MQTTSession.h&gt;
#import &lt;MQTTClient/MQTTSessionLegacy.h&gt;
#import &lt;MQTTClient/MQTTSessionSynchron.h&gt;
#import &lt;MQTTClient/MQTTMessage.h&gt;
#import &lt;MQTTClient/MQTTTransport.h&gt;
#import &lt;MQTTClient/MQTTCFSocketTransport.h&gt;
#import &lt;MQTTClient/MQTTCoreDataPersistence.h&gt;
#import &lt;MQTTClient/MQTTSSLSecurityPolicyTransport.h&gt;
</code></pre>

<pre><code>#import &quot;MQTTSession.h&quot;
#import &quot;MQTTSessionLegacy.h&quot;
#import &quot;MQTTSessionSynchron.h&quot;
#import &quot;MQTTMessage.h&quot;
#import &quot;MQTTTransport.h&quot;
#import &quot;MQTTCFSocketTransport.h&quot;
#import &quot;MQTTCoreDataPersistence.h&quot;
#import &quot;MQTTSSLSecurityPolicyTransport.h&quot;
</code></pre>

<h6 id="toc_7">在需要实现的地方导入头文件;</h6>

<pre><code>/*
 * MQTTClient: imports
 * MQTTSessionManager.h is optional
 */
#import &quot;MQTTClient.h&quot;
#import &quot;MQTTSessionManager.h&quot;

/*
 * MQTTClient: using your main view controller as the MQTTSessionManagerDelegate
 */

#import &lt;CommonCrypto/CommonHMAC.h&gt;
</code></pre>

<h6 id="toc_8">添加代理:</h6>

<pre><code>MQTTSessionManagerDelegate
</code></pre>

<pre><code>/*
 * MQTTClient: keep a strong reference to your MQTTSessionManager here
 */
@property (strong, nonatomic) MQTTSessionManager *manager;

@property (strong, nonatomic) NSDictionary *mqttSettings;
@property (strong, nonatomic) NSString *rootTopic;
@property (strong, nonatomic) NSString *accessKey;
@property (strong, nonatomic) NSString *secretKey;
@property (strong, nonatomic) NSString *groupId;
@property (strong, nonatomic) NSString *clientId;
@property (assign, nonatomic) NSInteger qos;

@property (strong, nonatomic) NSMutableArray *chat;
</code></pre>

<h6 id="toc_9">初始化客户端连接到host</h6>

<pre><code> MQTT-Client-FrameWork 包提供的客户端类有 MQTTSession 和 MQTTSessionManager，
 建议使用后者维持静态资源，而且已经封装好自动重连等逻辑。
 初始化时需要传入相关的网络参数
</code></pre>

<p>参数在阿里提供的demo里有一个plist文件,如下:</p>

<p><img src="http://upload-images.jianshu.io/upload_images/670820-a7797966c33937f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2017.png"/></p>

<p>参数如何配置请查看👇:<br/>
<a href="https://help.aliyun.com/document_detail/29536.html?spm=5176.doc29535.6.551.OrrVHX">https://help.aliyun.com/document_detail/29536.html?spm=5176.doc29535.6.551.OrrVHX</a></p>

<h4 id="toc_10">从配置文件导入相关属性,发起连接</h4>

<p>我的需求是只有一个地方使用,进到这个页面的时候,我才发起连接,<br/>
点击按钮给门禁上的java程序发送开门消息,连接方法调用如下方法:<br/>
```<br/>
-(void)initMQTT{</p>

<pre><code>NSURL *bundleURL = [[NSBundle mainBundle] bundleURL];
NSURL *mqttPlistUrl = [bundleURL URLByAppendingPathComponent:@&quot;mqtt.plist&quot;];
self.mqttSettings = [NSDictionary dictionaryWithContentsOfURL:mqttPlistUrl];
self.rootTopic = self.mqttSettings[@&quot;rootTopic&quot;];
self.accessKey = self.mqttSettings[@&quot;accessKey&quot;];
self.secretKey = self.mqttSettings[@&quot;secretKey&quot;];
self.groupId = self.mqttSettings[@&quot;groupId&quot;];
self.qos =[self.mqttSettings[@&quot;qos&quot;] integerValue];

//clientId的生成必须遵循GroupID@@@前缀，且需要保证全局唯一
/*为了保证全局唯一,ios可以获取CFUUID,每次获取都是不一样的,
   想保证一个设备一样,需要存本地一份;
    但是我这里需要每次使用的时候,每次连击所以为了保证clientid全局唯一,
    我每次都获取一次CFUUID,去掉中间的分隔线&quot; - &quot;代码如下,
*/
CFUUIDRef cfuuid = CFUUIDCreate(kCFAllocatorDefault);
NSString* cfuuidString = (NSString*)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, cfuuid));
NSString* tempstr = [cfuuidString stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;];
cfuuidString = tempstr;

self.clientId=[NSString stringWithFormat:@&quot;%@@@@%@%@&quot;,self.groupId,@&quot;&quot;,cfuuidString];

self.chat = [[NSMutableArray alloc] init];
/*
 * MQTTClient: create an instance of MQTTSessionManager once and connect
 * will is set to let the broker indicate to other subscribers if the connection is lost
 */
if (!self.manager) {
    self.manager = [[MQTTSessionManager alloc] init];
    self.manager.delegate = self;

    self.manager.subscriptions = [NSDictionary dictionaryWithObject:
                                  [NSNumber numberWithLong:self.qos]forKey:
                                  [NSString stringWithFormat:@&quot;%@/#&quot;, self.rootTopic]];

    //password的计算方式是，使用secretkey对groupId做hmac签名算法，具体实现参考macSignWithText方法
    NSString *passWord = [[self class] macSignWithText:self.groupId secretKey:self.secretKey];
      /*
      此处从配置文件导入的Host即为MQTT的接入点，该接入点获取方式请参考资源申请章节文档，
       在控制台上申请MQTT实例，每个实例会分配一个接入点域名
      */
    [self.manager connectTo:self.mqttSettings[@&quot;host&quot;]
                       port:[self.mqttSettings[@&quot;port&quot;] intValue]
                        tls:[self.mqttSettings[@&quot;tls&quot;] boolValue]
                  keepalive:60  //心跳间隔不得大于120s
                      clean:true
                       auth:true
                       user:self.accessKey
                       pass:passWord
                       will:false
                  willTopic:nil
                    willMsg:nil
                    willQos:0
             willRetainFlag:FALSE
               withClientId:self.clientId];

} else {
    [self.manager connectToLast];
}
</code></pre>

<p>}</p>

<p>/*<br/>
 userName 和 passWord 的设置</p>

<p>由于服务端需要对客户端进行鉴权，因此需要传入合法的 userName 和 passWord。<br/>
 userName 设置为当前用户的 AccessKey，<br/>
 password 则设置为 MQTT 客户端 GroupID 的签名字符串，<br/>
 签名计算方式是使用 SecretKey 对 GroupID 做 HmacSHA1 散列加密。<br/>
 具体方法请参考 👇 中的 macSignWithText 函数。<br/>
 */<br/>
+ (NSString *)macSignWithText:(NSString *)text secretKey:(NSString *)secretKey<br/>
{<br/>
    NSData *saltData = [secretKey dataUsingEncoding:NSUTF8StringEncoding];<br/>
    NSData <em>paramData = [text dataUsingEncoding:NSUTF8StringEncoding];<br/>
    NSMutableData</em> hash = [NSMutableData dataWithLength:CC_SHA1_DIGEST_LENGTH ];<br/>
    CCHmac(kCCHmacAlgSHA1, saltData.bytes, saltData.length, paramData.bytes, paramData.length, hash.mutableBytes);<br/>
    NSString *base64Hash = [hash base64EncodedStringWithOptions:0];</p>

<pre><code>return base64Hash;
</code></pre>

<p>}</p>

<pre><code>#####connectTo方法里的参数说明:
 &gt;  * tls:false //是否使用tls协议，mosca是支持tls的，如果使用了要设置成true
 *  clean:false //session是否清除，这个需要注意，如果是false，代表保持登录，
     如果客户端离线了再次登录就可以接收到离线消息。注意：QoS为1和QoS为2，并需订阅和发送一致
 *  auth:true //是否使用登录验证，和下面的user和pass参数组合使用
 * user:_userName //用户名
 * pass:_passwd //密码
 * willTopic:@&quot;&quot; //下面四个参数用来设置如果客户端异常离线发送的消息，
    当前参数是哪个topic用来传输异常离线消息，这里的异常离线消息都指的是客户端掉线后发送的掉线消息
 * will:@&quot;&quot; //异常离线消息体。自定义的异常离线消息，约定好格式就可以了
 * willQos:0 //接收离线消息的级别 0、1、2
 * willRetainFlag:false //只有在为true时，Will Qos和Will Retain才会被读取，此时消息体payload中
     要出现Will Topic和Will   Message具体内容，否则，Will QoS和Will Retain值会被忽略掉
 * withClientId:nil]; //客户端id，需要特别指出的是这个id需要全局唯一，因为服务端是根据这个来区分不同的客户端的，
    默认情况下一个id登录后，假如有另外的连接以这个id登录，上一个连接会被踢下线;

####发送消息(当点击按钮的时候,发送消息方法如下:)
</code></pre>

<p>[self.manager sendData:[self.scanDic.mj_JSONString dataUsingEncoding:NSUTF8StringEncoding]<br/>
                     topic:[NSString stringWithFormat:@&quot;%@&quot;,<br/>
                            self.rootTopic]//此处设置多级子topic<br/>
                       qos:self.qos<br/>
                    retain:FALSE];<br/>
```</p>

<h5 id="toc_11">发送方法注意topic的设置</h5>

<blockquote>
<p>以下为安卓代码中的注释示例:<br/>
ios的demo中没有此说明<br/>
消息发送到某个主题Topic，所有订阅这个Topic的设备都能收到这个消息。<br/>
遵循MQTT的发布订阅规范，Topic也可以是多级Topic。<br/>
此处设置了发送到二级topic如下:<br/>
 sampleClient.publish(topic+&quot;/notice/&quot;, message);<br/>
但是发送P2P消息，二级Topic必须是“p2p”,三级topic是目标的ClientID<br/>
 此处设置的三级topic需要是接收方的ClientID如下:<br/>
 string p2pTopic =topic+&quot;/p2p/&quot;+consumerClientId;</p>
</blockquote>

<h5 id="toc_12">qos:消息的传输方式</h5>

<blockquote>
<p>QoS说明如下：<br/>
   *  0    代表“至多一次”，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。<br/>
     这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。<br/>
   *  1   代表“至少一次”，确保消息到达，但消息重复可能会发生。<br/>
   *  2   代表“只有一次”，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。 <br/>
   * 备注：由于服务端采用Mosca实现，Mosca目前只支持到QoS 1<br/>
   * 如果发送的是临时的消息，例如:给某topic所有在线的设备发送一条消息，丢失的话也无所谓，0就可以了<br/>
（客户端登录的时候要指明支持的QoS级别，同时发送消息的时候也要指明这条消息支持的QoS级别)<br/>
   * 如果需要客户端保证能接收消息，需要指定QoS为1，如果同时需要加入客户端不在线也要能接收到消息，<br/>
   那么客户端登录的时候要指定session的有效性，接收离线消息需要指定服务端要保留客户端的session状态。</p>
</blockquote>

<h4 id="toc_13">接收发送消息的回调</h4>

<pre><code>/*
 * MQTTSessionManagerDelegate
 */
- (void)handleMessage:(NSData *)data onTopic:(NSString *)topic retained:(BOOL)retained {
    /*
     * MQTTClient: process received message
     */
    NSString *dataString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    [self.chat insertObject:[NSString stringWithFormat:@&quot;RecvMsg from Topic: %@\nBody: %@&quot;, topic, dataString] atIndex:0];    
}

</code></pre>

]]></content>
  </entry>
  
</feed>
