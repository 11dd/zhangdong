<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[至尊宝典之备忘录]]></title>
  <link href="www.freefook.com/atom.xml" rel="self"/>
  <link href="www.freefook.com/"/>
  <updated>2018-11-14T17:38:43+08:00</updated>
  <id>www.freefook.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Mac下的Vue环境搭建]]></title>
    <link href="www.freefook.com/15421818269588.html"/>
    <updated>2018-11-14T15:50:26+08:00</updated>
    <id>www.freefook.com/15421818269588.html</id>
    <content type="html"><![CDATA[
<p>官网地址：<a href="https://vuejs.org/">https://vuejs.org/</a></p>

<h4 id="toc_0">安装清单：</h4>

<ul>
<li><strong>Homebrew：</strong>  Mac系统下的包管理器</li>
<li><strong>Node.js:</strong>    JavaScript运行环境(runtime)</li>
<li><strong>npm:</strong>        Nodejs下的包管理器</li>
<li><strong>webpack:</strong>    Vue的组件是通过 .vue自定义的组件，需要打包成 .js文件</li>
<li><strong>Vue-cli:</strong>    用来生成模板的Vue工程</li>
</ul>

<h5 id="toc_1">打开Mac下的终端</h5>

<h4 id="toc_2">安装Homebrew</h4>

<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;

安装成功后查看一下版本信息输入: brew -v
</code></pre>

<h4 id="toc_3">安装Node.js</h4>

<pre><code>brew install nodejs

也可以下载后安装,下载地址：https://nodejs.org/en/download/

安装成功后查看一下版本信息输入: node -v
</code></pre>

<h4 id="toc_4">获取Nodejs安装目录访问权限</h4>

<pre><code>sudo chmod -R 777 /usr/local/lib/node_modules/
</code></pre>

<h4 id="toc_5">安装npm (淘宝镜像)</h4>

<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org

按回车执行，就可以用淘宝团队定制的cnpm代替默认的npm了
cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm

npm安装插件是从官网http://registry.npmjs.org下载对应的插件包
该网站服务器位于国外，所以经常下载缓慢或出现异常
阿里巴巴的淘宝团队,把npm官网的插件都同步到了中国的服务器
</code></pre>

<h4 id="toc_6">安装webpack</h4>

<pre><code>cnpm install webpack -g
</code></pre>

<h4 id="toc_7">安装vue脚手架</h4>

<pre><code>cnpm install vue-cli -g
</code></pre>

<h4 id="toc_8">分道扬镳之一</h4>

<h4 id="toc_9">创建一个vue的项目代码</h4>

<pre><code>cd 目录路径

安装项目依赖，执行命令：
cnpm install

安装 vue 路由模块vue-router和网络请求模块vue-resource执行命令：
cnpm install vue-router vue-resource --save

启动项目
cnpm run dev
</code></pre>

<h4 id="toc_10">分道扬镳之二</h4>

<h4 id="toc_11">创建一个基于mpvue的小程序项目代码</h4>

<pre><code>cd 目录路径

执行命令：
vue init mpvue/mpvue-quickstart firstVueProject(不要使用中文)
</code></pre>

<p>接下来是项目的一些配置信息，可一路回车Enter<br/>
当出现如下信息，模板代码已经下载结束</p>

<pre><code>Vue-cli . Generated &quot;firstVueProject(你创建的工程文件名)&quot; .
To get started:
   cd firstVueProject(你创建的工程文件名)
   npm install
   npm run dev 
Documentation can be found at http://mpvue.com
</code></pre>

<p>这时代码还缺少依赖库，继续执行</p>

<pre><code>cd firstVueProject(你创建的工程文件名)
cnpm install
</code></pre>

<h6 id="toc_12">cnpm install过程中---可能会出现npm update check failed</h6>

<pre><code>因为文件夹的权限问题导致的，执行如下命令
sudo chown -R $USER:$(id -gn $USER) /home/{username}/.config
</code></pre>

<h6 id="toc_13">cnpm install过程中---可能会出现类似警告</h6>

<pre><code>npm WARN vue-loader@15.2.4 requires a peer of css-loader@* but none is installed. You must install peer dependencies yourself.
npm WARN vue-loader@15.2.4 requires a peer of vue-template-compiler@^2.0.0 but none is installed. You must install peer dependencies yourself.
</code></pre>

<p>需要安装css-loader 和vue-template-compiler</p>

<pre><code>cnpm i css-loader vue-template-compiler
</code></pre>

<p>终于到了最后，执行命令让这个代码运行起来，进入开发模式：</p>

<pre><code>cnpm run dev
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之登录篇]]></title>
    <link href="www.freefook.com/15234367737951.html"/>
    <updated>2018-04-11T16:52:53+08:00</updated>
    <id>www.freefook.com/15234367737951.html</id>
    <content type="html"><![CDATA[
<p>做小程序登录思考问题：</p>

<ol>
<li>问题一：不想在小程序里总输入自己平台的账号密码，怎么与微信关联；</li>
<li>问题二：关联了微信也要可以切换账号使用；</li>
<li>问题三：不注册账号也可以在小程序里体验使用，必要时提示去登录；</li>
<li>问题四：如果打开小程序是我们项目自己的登录注册页面（体验较</li>
</ol>

<p><img src="media/15234367737951/IMG_3194.png" alt="IMG_3194"/></p>

<hr/>

<h4 id="toc_0">微信登录获取openID</h4>

<pre><code>//不需要微信授权既可获取微信小程序登录API获取code
wx.login({
    success: function (res) {
    //获取code返回值如下：
    //code:&quot;0619IaNe0L8gHz1VMINe0WgjNe09IaNC&quot;
    //errMsg:&quot;login:ok&quot;
    //code每次请求返回都不同，并且code使用一次后作废，
    //即使不使用，下一次请求code，上一次的code也作废。
    }
})
</code></pre>

<ol>
<li>得到code将code传给服务器</li>
<li>服务器post请求接口<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></li>
</ol>

<pre><code>小程序官方更新将此请求改为GET请求了
https://api.weixin.qq.com/sns/jscode2session  
参数{
    appid，
    secret，
    js_code = code，
    grant_type = authorization_code
} 
返回数据{
    session_key，
    openid
}
</code></pre>

<h4 id="toc_1">还想获取更多个人信息要如何做？</h4>

<ol>
<li>如果授权获可以取用户信息wx.getUserInfo得到iv,encryptedData,rawData,signature</li>
<li>将得到的iv,encryptedData 和wx.login 得到的code传给服务器</li>
<li>服务器post请求接口<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></li>
<li>服务端解密数据encryptedData 可以获取userinfo信息和unionId</li>
</ol>

<pre><code>服务端解密数据encryptedData
    对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
    对称解密的目标密文为 Base64_Decode(encryptedData)。
    对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
    对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。
    
解密encryptedData数据
{
　　&quot;openId&quot;:&quot;&quot;,
　　&quot;nickName&quot;:&quot;ZIM東&quot;,
　　&quot;gender&quot;:1,
　　&quot;language&quot;:&quot;zh_CN&quot;,
　　&quot;city&quot;:&quot;&quot;,
　　&quot;province&quot;:&quot;&quot;,
　　&quot;country&quot;:&quot;&quot;,
　　&quot;avatarUrl&quot;:&quot;&quot;,
　　&quot;unionId&quot;:&quot;&quot;,
　　&quot;watermark&quot;:{
　　　　&quot;timestamp&quot;:1523433831,
　　　　&quot;appid&quot;:&quot;&quot;
　　}
}

在登录小程序之前，既没有关注过公众号，也没有登录过公众号，
更没有使用微信登录的方式登录过app。
通过 wx.login 的到的 code 解密后未返回 unionid

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )
appid 敏感数据归属appid，开发者可校验此参数与自身appid是否一致
timestamp 敏感数据获取的时间戳, 开发者可以用于数据时效性校验
</code></pre>

<h4 id="toc_2">会话密钥session_key有效性</h4>

<pre><code>开发者如果遇到因为session_key不正确而校验签名失败或解密失败，请关注下面几个与session_key有关的注意事项。

    1.wx.login()调用时，用户的session_key会被更新而致使旧session_key失效。
    开发者应该在明确需要重新登录时才调用wx.login()，
    及时通过登录凭证校验接口更新服务器存储的session_key。

    2.微信不会把session_key的有效期告知开发者。
    我们会根据用户使用小程序的行为对session_key进行续期。
    用户越频繁使用小程序，session_key有效期越长。

    3.开发者在session_key失效时，可以通过重新执行登录流程获取有效的session_key。
    使用接口wx.checkSession()可以校验session_key是否有效，
    从而避免小程序反复执行登录流程。

    4.当开发者在实现自定义登录态时，
    可以考虑以session_key有效期作为自身登录态有效期，
    也可以实现自定义的时效性策略。
    
    5.wx.login() 之后再获取wx.getUserInfo()
</code></pre>

<blockquote>
<pre><code>微信如何授权小程序获取用户信息:

为优化用户体验，使用 wx.getUserInfo 接口直接弹出授权框的开发方式将逐步不再支持。
从2018年4月30日开始，小程序与小游戏的体验版、开发版调用 wx.getUserInfo 接口，
将无法弹出授权询问框，默认调用失败。正式版暂不受影响。
开发者可使用以下方式获取或展示用户信息：

一、小程序:
1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。

详情参考文档:
https://developers.weixin.qq.com/miniprogram/dev/component/button.html


2、使用 open-data 展示用户基本信息。

详情参考文档:
https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html
</code></pre>
</blockquote>

<h4 id="toc_3">登录流程图</h4>

<p><img src="media/15234367737951/%E6%B5%81%E7%A8%8B.png" alt="流程"/></p>

<p>👆原图地址：<a href="https://blog.csdn.net/dingjianmin/article/details/75137934">https://blog.csdn.net/dingjianmin/article/details/75137934</a></p>

<p><img src="media/15234367737951/%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.jpg" alt="登录流程"/></p>

<p>注意：开发者后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。 </p>

<p><img src="media/15234367737951/%E6%95%B0%E6%8D%AE.png" alt="数据"/></p>

<pre><code>签名校验以及数据加解密涉及用户的会话密钥session_key。
 开发者应该事先通过 wx.login 登录流程获取会话密钥 session_key 并保存在服务器。
 为了数据不被篡改，开发者不应该把session_key传到小程序客户端等服务器外的环境。

数据签名校验

为了确保 开放接口 返回用户数据的安全性，微信会对明文数据进行签名。
开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。

    通过调用接口（如 wx.getUserInfo）获取数据时，接口会同时返回 rawData、signature，
    其中 signature = sha1( rawData + session_key )
    
    开发者将 signature、rawData 发送到开发者服务器进行校验。
    服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，
    比对 signature 与 signature2 即可校验数据的完整性。

</code></pre>

<p>官方数据签名校验<br/>
<a href="https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject">https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之解析html]]></title>
    <link href="www.freefook.com/15420001365512.html"/>
    <updated>2018-11-12T13:22:16+08:00</updated>
    <id>www.freefook.com/15420001365512.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">使用wxParse解析html</h5>

<p>github地址：<a href="https://github.com/icindy/wxParse">https://github.com/icindy/wxParse</a><br/>
下载之后，将wxParse文件夹导入自己工程与utils同级别   </p>

<h5 id="toc_1">在app.wxss全局样式文件中，引入wxParse的样式表如:</h5>

<pre><code>@import&quot;/wxParse/wxParse.wxss&quot;;
</code></pre>

<h5 id="toc_2">在所需的JS文件中引入如:</h5>

<pre><code>var WxParse = require(&#39;../../wxParse/wxParse.js&#39;);

/**
     * WxParse.wxParse(bindName , type, data, target,imagePadding)
     * 1.bindName绑定的数据名(必填)
     * 2.type可以为html或者md(必填)
     * 3.data为传入的具体数据(必填)
     * 4.target为Page对象,一般为this(必填)
     * 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)
     */
     
    WxParse.wxParse(&#39;content&#39;, &#39;html&#39;, &#39;&lt;h1&gt;我是内容&lt;/h1&gt;&#39;, this, 0);
</code></pre>

<h5 id="toc_3">在wxml所需的文件中引入如:</h5>

<pre><code>&lt;import src=&quot;../../wxParse/wxParse.wxml&quot; /&gt;

&lt;!-- 内容 --&gt;
&lt;template is=&quot;wxParse&quot; data=&quot;{{wxParseData:content.nodes}}&quot; /&gt;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之跑马灯效果]]></title>
    <link href="www.freefook.com/15419994873507.html"/>
    <updated>2018-11-12T13:11:27+08:00</updated>
    <id>www.freefook.com/15419994873507.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">实现跑马灯效果图</h5>

<p><img src="media/15419923901812/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-12%20%E4%B8%8A%E5%8D%8811.45.16.png" alt="屏幕快照 2018-11-12 上午11.45.16"/></p>

<h5 id="toc_1">---wxml文件---</h5>

<pre><code>&lt;!--跑马灯中的文字信息字段:gundong_text--&gt;
&lt;view wx:if=&#39;{{gundong_text}}&#39; class=&quot;marquee_container&quot; style=&quot;--marqueeWidth--:-12em&quot;&gt;
  &lt;view class=&#39;marquee_text&#39;&gt;
    &lt;view class=&#39;hengxianggundong&#39;&gt;
      &lt;image class=&#39;gundong_image&#39; mode=&#39;aspectFit&#39; src=&#39;../../image/laba.png&#39;&gt;&lt;/image&gt;
      &lt;view class=&#39;triangle-left&#39;&gt;&lt;/view&gt;
      &lt;view class=&quot;gundong_textView weui-zimFont9&quot;&gt;{{gundong_text}}&lt;/view&gt;
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>

<h5 id="toc_2">---wxss文件---</h5>

<pre><code>/* 跑马灯样式 */
@keyframes around {
  from {
    margin-left: 100%;
  }
  to {
    /* var接受传入的变量 */
    margin-left: var(--marqueeWidth--);
  }
}
.marquee_container {
  position: absolute;
  top: 120rpx;
  width: 100%;
  height: 60rpx;
  line-height: 60rpx;
  z-index: 1200;
}
.marquee_container:hover {
  /* 不起作用 */
  animation-play-state: paused;
}
.marquee_text {
  display: inline-block;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
  white-space: nowrap;
  animation-name: around;
  animation-duration: 10s; /*过渡时间*/
  animation-iteration-count: infinite;
  animation-timing-function: linear;
}
.hengxianggundong {
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  align-items: center;
}
.gundong_image {
  background-color: rgba(0, 0, 0, 0.6);
  width: 50rpx;
  height: 50rpx;
  border-radius: 50%;
  margin-right: 20rpx;
}
.triangle-left {
  width: 0;
  height: 0;
  border-right: 10rpx solid rgba(0, 0, 0, 0.8);
  border-bottom: 10rpx solid rgba(0, 0, 0, 0);
  border-top: 10rpx solid rgba(0, 0, 0, 0);
}
.gundong_textView {
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding-left: 20rpx;
  padding-right: 20rpx;
  border-radius: 10rpx;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之动画]]></title>
    <link href="www.freefook.com/15419945000025.html"/>
    <updated>2018-11-12T11:48:20+08:00</updated>
    <id>www.freefook.com/15419945000025.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">---wxml文件---</h5>

<pre><code>&lt;view class=&#39;lunbo&#39; animation=&quot;{{animationItem}}&quot;
&lt;/view&gt;
</code></pre>

<h5 id="toc_1">---JS文件---</h5>

<pre><code>  var that = this;
    //动画样式
    that.animationItem = wx.createAnimation({
      duration: 500,
      timingFunction: &#39;linear&#39;,
      transformOrigin: &#39;90% 70%&#39;,
      success: function(res) {}
    });
    
    // 定时器，2S 循环一次
    that.data.newLunbo_interval = setInterval(function() {
      //开始动画-缩小
      that.animationItem.scale3d(0.98, 0.98, 0.1).step();
      that.setData({
        animationItem: that.animationItem.export()
      });
      //延迟恢复到原来大小
      setTimeout(function() {
        that.animationItem.scale3d(1.0, 1.0, 1.0).step();
        that.setData({
          animationItem: that.animationItem.export(),
        });
      }, 500)
    }.bind(that), 2000);
</code></pre>

<h5 id="toc_2">清理定时器</h5>

<pre><code>    clearInterval(this.data.newLunbo_interval);
</code></pre>

<h5 id="toc_3">创建wx.createAnimation参数含义</h5>

<pre><code>duration            动画持续时间，单位 ms 
timingFunction      &#39;linear&#39; 动画的效果  
delay               动画延迟时间，单位 ms 
transformOrigin     &#39;50% 50% 0&#39;
</code></pre>

<h5 id="toc_4">timingFunction 的合法值</h5>

<pre><code>&#39;linear&#39;    动画从头到尾的速度是相同的
&#39;ease&#39;  动画以低速开始，然后加快，在结束前变慢
&#39;ease-in&#39;   动画以低速开始
&#39;ease-in-out&#39;   动画以低速开始和结束
&#39;ease-out&#39;  动画以低速结束
&#39;step-start&#39;    动画第一帧就跳至结束状态直到结束
&#39;step-end&#39;  动画一直保持开始状态，最后一帧跳到结束状态
</code></pre>

<h5 id="toc_5">transformOrigin 的合法值</h5>

<pre><code>transform-origin: x-axis y-axis z-axis;

x-axis  定义视图被置于 X 轴的何处。可能的值：
    left
    center
    right
    length
    %
    
y-axis  定义视图被置于 Y 轴的何处。可能的值：
    top
    center
    bottom
    length
    %

z-axis  定义视图被置于 Z 轴的何处。可能的值：
    length
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之点击与跳页传参]]></title>
    <link href="www.freefook.com/15419918698485.html"/>
    <updated>2018-11-12T11:04:29+08:00</updated>
    <id>www.freefook.com/15419918698485.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">点击事件</h5>

<pre><code>bindtap  事件绑定不会阻止冒泡事件向上冒泡
catchtap  事件绑定可以阻止冒泡事件向上冒泡

点击事件的参数传递：
target：触发事件的源组件
currentTarget：事件绑定的当前事件
</code></pre>

<p><img src="media/15326733440349/86CC8E232275B9B77BD5728B014D3B69.png" alt="86CC8E232275B9B77BD5728B014D3B69"/></p>

<h5 id="toc_1">跳页</h5>

<pre><code>wx.navigateTo({
url: &#39;../Temp/Temp?province=&#39; + this.data.name + &#39;&amp;selectedindex=&#39; + index + &#39;&amp;arrayIndex=&#39; + JSON.stringify(this.data.arrayIndex),
})
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序之提示信息]]></title>
    <link href="www.freefook.com/15326733440349.html"/>
    <updated>2018-07-27T14:35:44+08:00</updated>
    <id>www.freefook.com/15326733440349.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">Toast提示</h5>

<pre><code> mask   Boolean     否   是否显示透明蒙层，防止触摸穿透，默认：false
 icon   String  否   图标，有效值 &quot;success&quot;, &quot;loading&quot;, &quot;none&quot;
 
 wx.showToast({
        title: &#39;请输入提示语&#39;,
        icon: &#39;none&#39;,
        mask:true,
        duration: 2000
      }) 
</code></pre>

<h5 id="toc_1">加载的loading</h5>

<pre><code>  wx.showLoading({
      title: &#39;正在加载&#39;,
      mask: true,
    })
   wx.hideLoading();
</code></pre>

<h5 id="toc_2">延迟执行</h5>

<pre><code> setTimeout(function() {
   wx.hideLoading()
 }, 1000)
          
</code></pre>

<h5 id="toc_3">弹出窗口提示</h5>

<pre><code>wx.showModal({
    title: &#39;我是弹窗标题&#39;,
    content: &#39;佛系弹窗详情内容&#39;,
    success: function(res) {
      if (res.confirm) {
        console.log(&#39;用户点击确定&#39;)
      } else if (res.cancel) {
        console.log(&#39;用户点击取消&#39;)
      }
    }
  })   
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序开发规范]]></title>
    <link href="www.freefook.com/15416465825836.html"/>
    <updated>2018-11-08T11:09:42+08:00</updated>
    <id>www.freefook.com/15416465825836.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">微信小程序里的四种文件</h5>

<pre><code>.json 后缀的 JSON 配置文件
.wxml 后缀的 WXML 模板文件
.wxss 后缀的 WXSS 样式文件
.js 后缀的 JS 脚本逻辑文件
</code></pre>

<h5 id="toc_1">资源管理</h5>

<pre><code>### 图片资源
目前图片资源的主要性能问题在于大图片和长列表图片上，
这两种情况都有可能导致 iOS 客户端内存占用上升，
从而触发系统回收小程序页面。
### 图片对内存的影响
在 iOS 上，小程序的页面是由多个 WKWebView 组成的，
在系统内存紧张时，会回收掉一部分 WKWebView。
从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。
### 图片对页面切换的影响
除了内存问题外，大图片也会造成页面切换的卡顿。
我们分析过的案例中，有一部分小程序会在页面中引用大图片，
在页面后退切换中会出现掉帧卡顿的情况。
当前我们建议开发者尽量减少使用大图片资源。
</code></pre>

<h5 id="toc_2">资源文件</h5>

<pre><code>所有资源文件(如图片)放在统一文件下及其子文件中(例如以下分类)
resource
  ——public
  ——tab
  ——home
  ——mine
</code></pre>

<h5 id="toc_3">基础页面</h5>

<pre><code>业务展示的页面放在如 pages 文件及其子文件中(例如以下分类)
pages
  ——index
  ——mall
    ——goodList
    ——goodDetail
  ——order
    ——orderList
    ——orderDetail
  ——mine
    ——myInfo
    ——myAddress
    
如有其他子业务，单独在pages里创建新的子级文件
</code></pre>

<pre><code>注释规范
   针对wxml页面由上到下(或由左到右)分级的模块，均需注释出其功能，
   并在其上下空出一行与其他代码进行区分。
</code></pre>

<h5 id="toc_4">样式文件</h5>

<pre><code>基础样式文件，在最外层中创建(如：weui.wxss)
第一步：写入公共样式：如 
1.标题字体大小，描述字体大小等项目中一二三级字号；
2.程序中所用的公共色值；
3.布局方式flex的横向布局，纵向布局等；
4.公共布局中wxss样式前缀统一(如weui-开头)；
等等

第二步：在app.wxss文件最上部，引入 @import &quot;weui.wxss&quot;;
以上公共样式便可全局使用
</code></pre>

<pre><code>wxss规范
    1.wxss 页面可使用快捷键真理代码(Shift+Alt+F)
    整理后代码有明显的代码缩进，对齐。每一个样式类之间空出一行；

    2.在开发过程中rpx和px均可能用到，
    如通常情况下间距使用rpx，
    字体大小和边框等使用px，开发者根据实际情况而定；
       
    3.同一块的样式属性(如 .order-title 和 .order-image)放在一块；
    
    4.wxss 样式中同一块可以这样抒写(如 .order.title)
    意思是.order样式下的.title,
    其他地方的class=&#39;title&#39;不会引用到.order下的.title
    
    5.wxss样式之间用块状注释。请勿在代码后面直接注释。
</code></pre>

<h5 id="toc_5">JS规范</h5>

<pre><code>JS规范
    1.删除js文件中未用到的生命周期函数，保持代码的整洁
    2.右上角不要分享的页面，删除JS文件中该方法onShareAppMessage:function()
    3.采用ES6 关键字let定义变量，尽量不使用var
    4.所有涉及到数据绑定的变量均需在data中初始化,禁止在不定义的情况下直接setData
    5.变量名以及函数名统一采用驼峰命名法(或下划线分割)
    6.正常情况下函数名前缀需加上清晰的动词表示函数功能(如getOderList)
    7.点击事件函数命名方式为 on + 事件名 或者业务名
    8.JS语句无需以分号结束，统一省略分号
    9.JS中一致使用单引号&#39; &#39; , WXML中一致使用双引号&quot; &quot;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序的历程]]></title>
    <link href="www.freefook.com/15416695471017.html"/>
    <updated>2018-11-08T17:32:27+08:00</updated>
    <id>www.freefook.com/15416695471017.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">历程</h4>

<ol>
<li><p>16年 越来越多产品通过公众号来做，因为这里开发、获取用户和传播成本更低。拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫「微信小程序」。</p></li>
<li><p>从2017年1月9日 小程序正式推出之后至 2017年12月28日 跳一跳上线火爆，传播发展的地域时间差；</p></li>
<li><p>全面开放申请后，主体类型为企业、政府、媒体、其他组织或个人的开发者，均可申请注册小程序。小程序、订阅号、服务号、企业号是并行的体系。</p></li>
<li><p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p></li>
<li><p>2018.7.13 微信更新小程序，增加了我的小程序入口,最多可加50个；</p></li>
<li><p>小程序入口=&gt; 微信 消息页下拉，发现页 小程序；<br/>
小程序分享不能分享到朋友圈，分享好友或群；<br/>
主要是线下场景扫码使用</p></li>
</ol>

<h4 id="toc_1">小程序的几点介绍</h4>

<pre><code>1.小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念；

2.用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。

3.对于开发者而言，小程序开发门槛相对较低，难度不及APP，能够满足简单的基础应用；

4.适合生活服务类线下商铺以及非刚需低频应用的转换。

5.小程序能够实现消息通知、线下扫码、公众号关联等七大功能。其中，通过公众号关联，用户可以实现公众号与小程序之间相互跳转。由于小程序不存在入口。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序账号]]></title>
    <link href="www.freefook.com/15232437563217.html"/>
    <updated>2018-04-09T11:15:56+08:00</updated>
    <id>www.freefook.com/15232437563217.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">小程序注意事项</h4>

<ol>
<li>同一个邮箱只能申请1个公众号；</li>
<li>同一个手机号码可注册和认证5个公众号；</li>
<li>同一身份证注册个人类型公众号数量上限为2个；</li>
<li>同一公司、个体工商户、事业单位、其他组织资料注册公众号数量上限为5个；</li>
<li>同一政府、媒体类型可注册和认证50个公众号。</li>
<li>企业、政府、媒体、其他组织主体可以注册50个小程序</li>
<li>个体户和个人类型主体可注册5个小程序。<br/></li>
<li>公众号可关联同主体的10个小程序及不同主体的3个小程序 </li>
<li>已关联的小程序可被使用在自定义菜单和模版消息场景中</li>
<li>小程序和小程序 相互跳转的必须是同一公众号下关联的</li>
<li>小程序发布前，可修改2次名称</li>
<li>发布后，必须通过微信认证流程改名</li>
<li>小程序名称可以由中文、数字、英文。长度在4-30个字符之间，一个中文字等于2个字符</li>
<li>公众号、小程序在微信公众平台上的名称是唯一的，且属于同一主体下，可以重名</li>
<li>不得与不同主体的公众号名称重名。</li>
</ol>

<p>另附一种快速注册微信小程序方法：微信商户平台里，可以添加小程序，<br/>
并且是直接认证通过的，支付认证过的, 省600块！！！</p>

<hr/>

<h4 id="toc_1">小程序账号注册流程介绍</h4>

<ol>
<li>打开公众平台 <a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></li>
<li>使用未绑定微信其他产品的邮箱注册</li>
<li>填写信息后，个人登录成功(免费且不能认证)</li>
<li>企业需要填写企业信息需300块认证费</li>
<li>企业有支付功能开通需300块</li>
<li>查看小程序平台, 截图如下</li>
</ol>

<h5 id="toc_2">个人小程序账号截图</h5>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.19.02.png" alt="屏幕快照 2018-04-09 上午11.19.02"/></p>

<h5 id="toc_3">个人账号下应用类截图：</h5>

<p><img src="media/15232437563217/1533714194263.jpg" alt="1533714194263"/></p>

<h5 id="toc_4">个人账号下游戏类截图：</h5>

<p><img src="media/15232437563217/1533714051550.jpg" alt="1533714051550"/></p>

<h5 id="toc_5">企业小程序认证3到5个工作日</h5>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-18%20%E4%B8%8A%E5%8D%8810.31.37.png" alt="屏幕快照 2018-04-18 上午10.31.37"/></p>

<h5 id="toc_6">企业小程序基本信息设置</h5>

<p><img src="media/15232437563217/%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF.png" alt="基本信息"/></p>

<h5 id="toc_7">企业小程序 侧边栏多了微信支付 支付设置 与小程序插件</h5>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%881.54.00.png" alt="屏幕快照 2018-04-19 下午1.54.00"/></p>

<h5 id="toc_8">企业微信小程序支付</h5>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%883.17.14.png" alt="屏幕快照 2018-08-08 下午3.17.14"/></p>

<h5 id="toc_9">小程序更新</h5>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%883.16.10.png" alt="屏幕快照 2018-08-08 下午3.16.10"/></p>

<hr/>

<h4 id="toc_10">官方微信小程序接入指南链接：</h4>

<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/introduction/">https://developers.weixin.qq.com/miniprogram/introduction/</a></li>
</ul>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.31.04.png" alt="屏幕快照 2018-04-09 上午11.31.04"/></p>

<hr/>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信平台与微信小程序]]></title>
    <link href="www.freefook.com/15399429964472.html"/>
    <updated>2018-10-19T17:56:36+08:00</updated>
    <id>www.freefook.com/15399429964472.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">微信平台有哪些？</h5>

<p>微信公众平台：<br/>
<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></p>

<p>微信支付的商户平台：<br/>
<a href="https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F">https://pay.weixin.qq.com/index.php/core/home/login?return_url=%2F</a><br/>
注：小程序里支付只能用小程序支付方式，必须和小程序里开通的支付的商户一致；</p>

<p>支付接口文档<br/>
<a href="https://pay.weixin.qq.com/wiki/doc/api/index.html">https://pay.weixin.qq.com/wiki/doc/api/index.html</a></p>

<p>微信开放平台<br/>
<a href="https://open.weixin.qq.com/cgi-bin/index?t=home/index&amp;lang=zh_CN">https://open.weixin.qq.com/cgi-bin/index?t=home/index&amp;lang=zh_CN</a></p>

<p>微信开发者平台：<br/>
<a href="http://weixin.qq.com/">http://weixin.qq.com/</a></p>

<p>微信硬件平台：<br/>
<a href="https://iot.weixin.qq.com/">https://iot.weixin.qq.com/</a></p>

<p>腾讯的广告平台：<br/>
<a href="http://e.qq.com/ads/">http://e.qq.com/ads/</a></p>

<p>腾讯开放平台：<br/>
<a href="http://open.tencent.com/">http://open.tencent.com/</a></p>

<h5 id="toc_1">腾讯自家小程序全家桶</h5>

<pre><code>小程序示例   第一个小程序
小程序开发助手
小程序数据助手
小游戏数据助手
公众平台助手
微信发票助手
王卡申请助手

QQ游戏
腾讯爱玩
全民大乐斗
企鹅电竞+
腾讯动漫+

腾讯+  产品体验官
腾讯网
腾讯文档
腾讯企业邮箱

腾讯云助手
腾讯视频云
腾讯AI体验中心
腾讯云AI体验中心
腾讯优图AI开发平台
</code></pre>

<h5 id="toc_2">其他特色小程序</h5>

<pre><code>摩拜单车： 接入是小程序线下落地的一次大的尝试
KFC，麦当劳： 点餐实用型的线下场景
家乐福中国：小程序有优惠
沃尔玛：小程序可自助结账

一时风靡的答题类，头脑王者

青芒杂志
一条视频
毒蛇电影社区

企鹅电竞+
斗鱼直播
虎牙直播
YY直播+
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS审核被拒4.3]]></title>
    <link href="www.freefook.com/15403646176398.html"/>
    <updated>2018-10-24T15:03:37+08:00</updated>
    <id>www.freefook.com/15403646176398.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">一种是过不了机审关被拒，一种是过不了人审关被拒。</h5>

<pre><code>iOS预审核，扫描api，及plist文件字符缺失等；
此处分两步，第一步为上传时苹果Application Loador等应用对于适配icon等的检查，
第二步为上传后苹果的功能性检查，例如配置了Push功能但有缺失
或者未打开功能，则会邮件提示等等；

iOS机审，主要是对代码进行机器审核，排查APP是否重复应用，此处扫描支付SDK等，及马甲情况，机器扫描主要看代码块

iOS人审，主要是由苹果审核人员对APP的内容、功能进行核验，防止APP有bug，
防止APP模仿其他应用，内容与其他APP重复，影响用户体验，
检测功能或者App体验测试，例如用测试账号登录App体验功能，
或其他是否明显bug等，ipv6也在此处检测；

</code></pre>

<h5 id="toc_1">区分机审 、人审</h5>

<pre><code>那么如何区分是机器审核还是人工审核呢？主要看APP被拒的信息：

1）如果是机器审核被拒，一般收到的被拒信息第一句话基本上是这样的：
Guideline4.3 - Design - Spam
Yourapp duplicates the content and functionality of apps submitted to the AppStore,
 which is considered a form of spam.

2）如果是人工审核被拒，一般收到的被拒信息第一句话基本上是这样的：
Guideline4.3 - Design - Spam
Wefound that your app provides the same feature set as other apps submitted tothe App Store, 
which is not appropriate to the App Store.
</code></pre>

<h5 id="toc_2">针对审核</h5>

<pre><code>1.原来账号里的APP的名字可以作废掉或者修改成其他的，
同时记得移除之前的APP，重新打个空包传上去，
icon图则用其他logo图置换掉

2.增加登录日志

3.主要的方法是添加垃圾代码，且代码的相似程度不高于45%，
  混淆工程地址：https://github.com/klaus01/KLGenerateSpamCode

4.工程中的文件夹的名字全部进行修改，类名修改，方法名修改

5.资源图片替换修改，适当添加一些无用的资源 

6.API名称，机扫二进制文件，也会对比API

7.换开发者账号，换不同账号提交审核

8.换 bundle id，换一个包再提交审核；

9. 一定要关注名字,icon,启动图;修改UI风格同时进行假页面的添加;

10.升级 version，升级一个版本号提交审核

11.修改产品分类

12.还需要注意相同的马甲包提交至少要间隔一天以上。

13.定期换电脑提包.换电脑的序列号.换VPN环境.定期换域名. 

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序运营 设计与开发]]></title>
    <link href="www.freefook.com/15416647115012.html"/>
    <updated>2018-11-08T16:11:51+08:00</updated>
    <id>www.freefook.com/15416647115012.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">项目经理必备</h4>

<p>项目经理必要了解API里面微信开放接口的信息例如：</p>

<ol>
<li>登录授权</li>
<li>获取用户信息</li>
<li>微信支付</li>
<li>转发</li>
<li>收货地址</li>
<li>生成小程序二维码</li>
</ol>

<p>小程序初期明确是否在运营规范里允许的，或者找一些已有小程序样例</p>

<ul>
<li>运营规范(在这里查看禁止事项)：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/index.html">https://mp.weixin.qq.com/debug/wxadoc/product/index.html</a></li>
<li><p>特殊行业所需资质材料：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714</a><br/>
<img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%883.46.27.png" alt="屏幕快照 2018-08-08 下午3.46.27"/></p></li>
<li><p>支付文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1">https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1</a></p></li>
<li><p>客服消息：<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221">https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221</a> </p></li>
<li><p>数据分析：<a href="https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714</a></p></li>
</ul>

<hr/>

<h5 id="toc_1">当开始要做一个小程序时，需通读设计指南</h5>

<p>设计指南：<a href="https://mp.weixin.qq.com/debug/wxadoc/design/index.html">https://mp.weixin.qq.com/debug/wxadoc/design/index.html</a></p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.28.55.png" alt="屏幕快照 2018-04-09 上午11.28.55"/></p>

<h4 id="toc_2">小程序开发人员必备</h4>

<p>入坑指南，疑难问题，请浏览👇<br/>
小程序社区：<a href="http://www.wxapp-union.com/">http://www.wxapp-union.com/</a></p>

<p>开发者学习已有框架可参考<br/>
WePY框架开发小程序请移步👇<br/>
<a href="https://tencent.github.io/wepy/index.html">https://tencent.github.io/wepy/index.html</a></p>

<p>美团一团队出的框架mpvue框架请移步👇<br/>
<a href="http://mpvue.com/mpvue/#_2">http://mpvue.com/mpvue/#_2</a></p>

<p>weui Github 地址：<br/>
<a href="https://github.com/Tencent/weui-wxss">https://github.com/Tencent/weui-wxss</a></p>

<hr/>

<h5 id="toc_3">微信开发者工具创建小程序工程需要AppID</h5>

<p>官方工具：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714</a></p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.21.41.png" alt="屏幕快照 2018-04-09 上午11.21.41"/></p>

<h5 id="toc_4">小程序开发必读项，教程 ，框架 ，组件 ，API , 工具</h5>

<p>简易教程：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.23.50.png" alt="屏幕快照 2018-04-09 上午11.23.50"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序微信开放API]]></title>
    <link href="www.freefook.com/15326548831374.html"/>
    <updated>2018-07-27T09:28:03+08:00</updated>
    <id>www.freefook.com/15326548831374.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">开放接口：</h5>

<pre><code>wx.login    登录
wx.getUserInfo  获取用户信息
wx.chooseAddress    获取用户收货地址
wx.requestPayment   发起微信支付
wx.addCard  添加卡券
wx.openCard 打开卡券
可以获取用户手机号
不能获取本机IP
</code></pre>

<h5 id="toc_1">设备 API 列表：</h5>

<pre><code>wx.scanCode 扫码
wx.makePhoneCall    拨打电话
wx.getSystemInfo    获取系统信息
wx.getSystemInfoSync    获取系统信息
wx.getNetworkType   获取网络类型
wx.onNetworkStatusChange    监听网络状态变化

wx.onAccelerometerChange    监听加速度数据
wx.startAccelerometer   开始监听加速度数据
wx.stopAccelerometer    停止监听加速度数据
wx.onCompassChange  监听罗盘数据
wx.startCompass 开始监听罗盘数据
wx.stopCompass  停止监听罗盘数据
wx.setClipboardData 设置剪贴板内容
wx.getClipboardData 获取剪贴板内容
</code></pre>

<h5 id="toc_2">多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</h5>

<h5 id="toc_3">网络请求API</h5>

<pre><code>wx.request  发起网络请求
wx.uploadFile   上传文件
wx.downloadFile 下载文件
</code></pre>

<h5 id="toc_4">界面 API 列表：</h5>

<pre><code>wx.navigateTo   新窗口打开页面
wx.redirectTo   原窗口打开页面
wx.switchTab    切换到 tabbar 页面
wx.navigateBack 退回上一个页面

wx.showToast    显示提示框
wx.hideToast    隐藏提示框

wx.showLoading  显示加载提示框
wx.hideLoading  隐藏提示框

wx.showModal    显示模态弹窗
wx.showActionSheet  显示菜单列表

wx.setNavigationBarTitle    设置当前页面标题
wx.showNavigationBarLoading 显示导航条加载动画
wx.hideNavigationBarLoading 隐藏导航条加载动画
wx.setBackgroundColor   动态设置窗口的背景色
wx.setBackgroundTextStyle   动态设置下拉背景字体、loading 图的样式

wx.createAnimation  动画
wx.createContext    创建绘图上下文
wx.drawCanvas   绘图
wx.stopPullDownRefresh  停止下拉刷新动画
</code></pre>

<h5 id="toc_5">媒体 API 列表：</h5>

<pre><code>wx.chooseImage  从相册选择图片，或者拍照
wx.previewImage 预览图片
wx.startRecord  开始录音
wx.stopRecord   结束录音
wx.playVoice    播放语音
wx.pauseVoice   暂停播放语音
wx.stopVoice    结束播放语音
wx.getBackgroundAudioPlayerState 获取音乐播放状态
wx.playBackgroundAudio  播放音乐
wx.pauseBackgroundAudio 暂停播放音乐
wx.seekBackgroundAudio  控制音乐播放进度
wx.stopBackgroundAudio  停止播放音乐
wx.onBackgroundAudioPlay    监听音乐开始播放
wx.onBackgroundAudioPause   监听音乐暂停
wx.onBackgroundAudioStop    监听音乐结束
wx.chooseVideo  从相册选择视频，或者拍摄
wx.loadFontFace 动态加载字体
</code></pre>

<h5 id="toc_6">文件 API 列表：</h5>

<pre><code>wx.saveFile 保存文件
wx.getSavedFileList 获取已保存的文件列表
wx.getSavedFileInfo 获取已保存的文件信息
wx.removeSavedFile  删除已保存的文件信息
wx.openDocument 打开文件
</code></pre>

<h5 id="toc_7">数据 API 列表：</h5>

<pre><code>wx.getStorage   获取本地数据缓存
wx.getStorageSync   获取本地数据缓存
wx.setStorage   设置本地数据缓存
wx.setStorageSync   设置本地数据缓存
wx.getStorageInfo   获取本地缓存的相关信息
wx.getStorageInfoSync   获取本地缓存的相关信息
wx.removeStorage    删除本地缓存内容
wx.removeStorageSync    删除本地缓存内容
wx.clearStorage 清理本地数据缓存
wx.clearStorageSync 清理本地数据缓存
</code></pre>

<h5 id="toc_8">位置 API 列表：</h5>

<pre><code>wx.getLocation  获取当前位置
wx.chooseLocation   打开地图选择位置
wx.openLocation 打开内置地图
wx.createMapContext 地图组件控制
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序机制]]></title>
    <link href="www.freefook.com/15287848933165.html"/>
    <updated>2018-06-12T14:28:13+08:00</updated>
    <id>www.freefook.com/15287848933165.html</id>
    <content type="html"><![CDATA[
<p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p>

<h4 id="toc_0">小程序未发布时有权限-需添加用户身份</h4>

<pre><code>管理入口位于：小程序管理后台 - 用户身份 – 成员管理

一个团队进行小程序的开发，那么团队成员的身份管理是很有必要的。
管理员可在小程序管理后台统一管理项目成员（
包括开发者、体验者及其他成员）、
设置项目成员的权限，包括：开发者/体验者权限、登录小程序管理后台、开发管理、查看小程序数据分析等。
管理入口位于：小程序管理后台 - 用户身份 – 成员管理
</code></pre>

<h4 id="toc_1">小程序运行机制</h4>

<pre><code>热启动
 小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。
 假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，
 此时无需重新启动，只需将后台态的小程序切换到前台，
冷启动
 冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，
 此时小程序需要重新加载启动。

 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后
 （目前是5分钟）会被微信主动销毁
 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁
</code></pre>

<pre><code>小程序启动进入程序紧接着通过 
app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:
默认启动app.json 的 pages 字段的第一个页面就是这个小程序的首页
(打开小程序看到的第一个页面)。
</code></pre>

<p><img src="media/15287848933165/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%883.05.53.png" alt="屏幕快照 2018-08-08 下午3.05.53"/></p>

<h4 id="toc_2">小程序更新机制</h4>

<pre><code>小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，
并同时用客户端本地的包进行启动，
即新版本的小程序需要等下一次冷启动才会应用上。 
如果需要马上应用最新版本，
可以使用 wx.getUpdateManager API 进行处理。
</code></pre>

<h4 id="toc_3">小程序代码包大小的优化</h4>

<pre><code>小程序一开始时代码包限制为 1MB，但我们收到了很多反馈说代码包大小不够用，
经过评估后我们放开了这个限制，增加到 2MB 。
代码包上限的增加对于开发者来说，能够实现更丰富的功能，
但对于用户来说，也增加了下载流量和本地空间的占用。

分包加载

目前小程序分包大小有以下限制：
 •  整个小程序所有分包大小不超过 8M
 •  单个分包/主包大小不能超过 2M
对小程序进行分包，可以优化小程序首次启动的下载时间，
以及在多团队共同开发时可以更好的解耦协作。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[简易博客]]></title>
    <link href="www.freefook.com/15337217832111.html"/>
    <updated>2018-08-08T17:49:43+08:00</updated>
    <id>www.freefook.com/15337217832111.html</id>
    <content type="html"><![CDATA[
<p>首先看地址：www.freefook.com</p>

<p>专业的 Markdown编辑工具MWeb地址：<a href="https://zh.mweb.im/">https://zh.mweb.im/</a></p>

<p>空间地址，男人的天堂：<a href="https://github.com/">https://github.com/</a><br/>
github 桌面版工具地址：<a href="https://desktop.github.com/">https://desktop.github.com/</a></p>

<p>域名购买地址：<a href="https://sg.godaddy.com/">https://sg.godaddy.com/</a></p>

<p>github地址建个账号，建个项目</p>

<p><img src="media/15337217832111/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%885.54.20.png" alt="屏幕快照 2018-08-08 下午5.54.20"/></p>

<p>cheakout到电脑文件目录，便于上传更新项目，使用github桌面工具<br/>
<img src="media/15337217832111/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%886.03.04.png" alt="屏幕快照 2018-08-08 下午6.03.04"/></p>

<h5 id="toc_0">绑定域名</h5>

<p>点击setting 进设置页面，设置如下：</p>

<p><img src="media/15337217832111/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%885.56.47.png" alt="屏幕快照 2018-08-08 下午5.56.47"/></p>

<p><img src="media/15337217832111/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-09%20%E4%B8%8B%E5%8D%882.40.04.png" alt="屏幕快照 2018-08-09 下午2.40.04"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序]]></title>
    <link href="www.freefook.com/15198806151662.html"/>
    <updated>2018-03-01T13:03:35+08:00</updated>
    <id>www.freefook.com/15198806151662.html</id>
    <content type="html"><![CDATA[
<pre><code> sizeof 判断数据类型长度符的关键字  简单的说其作用就是返回一个对象或者类型所占的内存字节数
</code></pre>

<h4 id="toc_0">选择排序</h4>

<pre><code>主要思想：
 对比数组中前一个元素跟后一个元素的大小，
 如果后面的元素比前面的元素小则用一个变量k来记住他的位置，
 接着第二次比较，前面“后一个元素”现变成了“前一个元素”，
 继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在  数组中的位置(下标)，
 等到循环结束的时候，我们应该找到了最小的那个数的下标了，
 然后进行判断，如果这个元素的下标不是第一个元素的下标，
 就让第一个元素跟他交换一下值，
 这样就找到整个数组中最小的数了。
 然后找到数组中第二小的数，让他跟数组中第二个元素交换一下值，以此类推。
 
 总之一句话，拿第一个数和后面的所有数比，谁小记录上下标，用这个小的继续和后面的比，直到比完所有。
 n个乱序-&gt;选择排序可经过n-1趟直接选择排序得到有序结果
</code></pre>

<pre><code>#include&lt;stdio.h&gt;
void select_sort(int arr[],int size)
{
    int i=0,j=0;
    int k=0;
    for(i=0;i&lt;size;i++){
        k=i;
        for(j=i+1;j&lt;size;j++){
           //结果输出想从小到大，还是从大到小，改这个&gt; or &lt;;
            if(arr[k]&lt;arr[j]){
                k=j;
            }

        }
        if(k!=i){
            int tmp=arr[k];
            arr[k]=arr[i];
            arr[i]=tmp;
        }
    }
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    int len=sizeof(arr)/sizeof(arr[0]);
    select_sort(arr,len);
    int i=0;
    for(i=0;i&lt;len;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>

<h4 id="toc_1">冒泡排序</h4>

<pre><code> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
 针对所有的元素重复以上的步骤，除了最后一个。
 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
</code></pre>

<pre><code>#include&lt;stdio.h&gt;
void bubble_sort(int arr[],int size)
{
    int i=0,j=0;
    for(i=0;i&lt;size;i++){
        for(j=0;j&lt;size-i-1;j++){
            if(arr[j]&gt;arr[j+1]){
                int tmp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=tmp;
            }
        }
    }
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    int len=sizeof(arr)/sizeof(arr[0]);
    bubble_sort(arr,len);
    int i=0;
    for(i=0;i&lt;len;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>

<h4 id="toc_2">快速排序</h4>

<pre><code> 第一遍快速排序不会直接得到最终结果，
 只会把比k大和比k小的数分到k的两边。
 为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，
 然后再分解数组，直到数组不能再分解为止（只有一个数据），
 才能得到正确结果。
 
 总结：分别从初始序列两端开始，先从右往左找一个小于“数组第一个”的数，再从左往右找一个大于“数组第一个”的数，然后交换他们；

跳跃式交换，进化了冒泡的相邻交换，数据量多的无序数组排序时才提现出效果
二分思想

</code></pre>

<pre><code>#include&lt;stdio.h&gt;
void quick_sort(int arr[],int left,int right)
{
    if(left&gt;=right){
        return;
    }
    int key=arr[left];
    int begin=left;
    int end=right;
    while(begin!=end){
        while(begin&lt;end &amp;&amp; arr[end]&gt;=key){
            end--;
        }
        if(end&gt;begin){
            arr[begin]=arr[end];
        }
        while(begin&lt;end &amp;&amp; arr[begin]&lt;=key){
            begin++;
        }
        if(begin&lt;end){
            arr[end]=arr[begin];
        }
    }
    arr[begin]=key;
    quick_sort(arr,left,begin-1);
    quick_sort(arr,begin+1,right);
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    quick_sort(arr,0,9);
    int i=0;
    for(i=0;i&lt;10;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>

<h4 id="toc_3">插入排序</h4>

<pre><code>插入排序有以下几种方式：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）

示例直接插入排序，
用数组第二个和第一个比，如果小，就插入第一位位置；
用数组第三个和第二个比，如果小，就插入第二个位置；
                    如果大，就留在原位置；
                    依次类推；
</code></pre>

<pre><code>#include&lt;stdio.h&gt;
void insert_sort(int arr[],int size)
{
    int i=0,j=0;
    int tmp=0;
    for(i=1;i&lt;size;i++){
        tmp=arr[i];
        j=i;
        while(j&gt;0 &amp;&amp; arr[j-1]&gt;tmp){
            arr[j]=arr[j-1];
            j--;
        }
        arr[j]=tmp;
    }
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    int len=sizeof(arr)/sizeof(arr[0]);
    insert_sort(arr,len);
    int i=0;
    for(i=0;i&lt;len;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>

<h4 id="toc_4">希尔排序</h4>

<pre><code>#include&lt;stdio.h&gt;
void shell_insert_sort(int arr[],int size)
{
    int gap=0;
    int i=0,j=0,k=0;
    for(gap=size/2;gap&gt;0;gap/=2){
        //for(i=0;i&lt;gap;i++){
            for(j=gap;j&lt;size;j++){
                int tmp=arr[j];
                k=j;
                while(k-gap&gt;=0 &amp;&amp; arr[k-gap]&gt;tmp){
                    arr[k]=arr[k-gap];
                    k-=gap;
                }
                arr[k]=tmp;
            }
        //}
    }
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    int len=sizeof(arr)/sizeof(arr[0]);
    shell_insert_sort(arr,len);
    int i=0;
    for(i=0;i&lt;len;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>

<h4 id="toc_5">归并排序（合并排序）</h4>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
void merge(int* src,int *dst,int begin,int mid,int end)
{
    int begin1=begin;
    int begin2=mid;
    int index=begin;
    while(begin1&lt;mid &amp;&amp; begin2&lt;end){
        if(src[begin1]&lt;src[begin2]){
            dst[index++]=src[begin1++];
        }else{
            dst[index++]=src[begin2++];
        }
    }
    while(begin1&lt;mid){
        dst[index++]=src[begin1++];
    }
    while(begin2&lt;end){
        dst[index++]=src[begin2++];
    }
    memcpy(src+begin,dst+begin,(end-begin)*sizeof(int));
}
void _merge_sort(int *arr,int* tmp,int left,int right)
{
    if(left+1&gt;=right){
        return;
    }
    int mid=left+(right-left)/2;
    _merge_sort(arr,tmp,left,mid);
    _merge_sort(arr,tmp,mid,right);
    merge(arr,tmp,left,mid,right);
}
void merge_sort(int* arr,int size)
{
    int* tmp=(int*)malloc(size*sizeof(int));
    _merge_sort(arr,tmp,0,size);
    free(tmp);
}
int main()
{
    int arr[]={3,6,1,9,4,2,0,5,8,7};
    int len=sizeof(arr)/sizeof(arr[0]);
    merge_sort(arr,len);
    int i=0;
    for(i=0;i&lt;len;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);

    return 0;
}
</code></pre>

<h4 id="toc_6">堆排序</h4>

<pre><code>#include&lt;stdio.h&gt;
void swap(int *a,int *b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
}
void adjust_down(int arr[],int root,int size)
{
    int parent=root;
    int left=root*2+1;
    int right=left+1;
    while(left&lt;size){
        int max=left;
        if(right&lt;size &amp;&amp; arr[right]&gt;arr[max]){
            max=right;
        }
        if(arr[max]&gt;arr[parent]){
            swap(&amp;arr[max],&amp;arr[parent]);
            parent=max;
            left=parent*2+1;
            right=left+1;
        }
        else{
            break;
        }
    }
}
//make min heap
void heap_sort(int arr[],int size)
{
    int begin=0;
    for(begin=size/2-1;begin&gt;=0;--begin){
        adjust_down(arr,begin,size);
    }
    int end=size-1;
    while(end&gt;0){
        swap(&amp;arr[0],&amp;arr[end]);
        adjust_down(arr,0,end);
        --end;
    }
}
int main()
{
    int arr[10]={3,7,1,4,2,8,5,0,9,6};
    heap_sort(arr,10);
    int i=0;
    for(;i&lt;10;i++){
        printf(&quot;%d &quot;,arr[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}

</code></pre>

<p><img src="media/15198806151662/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-01%20%E4%B8%8B%E5%8D%883.45.58.png" alt="屏幕快照 2018-03-01 下午3.45.58"/></p>

<p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，<br/>
冒泡排序、插入排序、归并排序 是稳定的排序算法。</p>

<p>在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>

<p>稳定都是相对的，不是绝对的稳定</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些地址记录]]></title>
    <link href="www.freefook.com/15338947142066.html"/>
    <updated>2018-08-10T17:51:54+08:00</updated>
    <id>www.freefook.com/15338947142066.html</id>
    <content type="html"><![CDATA[
<p>接口管理地址：<br/>
<a href="https://www.eolinker.com/">https://www.eolinker.com/</a></p>

<p>微信小程序开发资源汇总<br/>
<a href="https://github.com/justjavac/awesome-wechat-weapp">https://github.com/justjavac/awesome-wechat-weapp</a></p>

<p>nodejs 下载地址：<br/>
<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>

<p>微信小程序-SASS开发环境搭建(mac)<br/>
<a href="https://blog.csdn.net/yaodong379/article/details/79305100">https://blog.csdn.net/yaodong379/article/details/79305100</a></p>

<p>微信小程序中使用Promise进行异步流程处理<br/>
A polyfill for ES6-style Promises ：<br/>
<a href="https://github.com/stefanpenner/es6-promise">https://github.com/stefanpenner/es6-promise</a></p>

<p>weapp.qrcode.js 在 微信小程序 中，快速生成二维码 <br/>
<a href="https://github.com/yingye/weapp-qrcode">https://github.com/yingye/weapp-qrcode</a></p>

<p>小程序开发视频环境管理地址：<br/>
<a href="https://console.qcloud.com/lav2/dev">https://console.qcloud.com/lav2/dev</a></p>

<p>ES6 map()遍历、filter()筛选<br/>
<a href="https://blog.csdn.net/zuorishu/article/details/80958705">https://blog.csdn.net/zuorishu/article/details/80958705</a></p>

<p>微信小程序获取系统时间、时间戳、时间时间戳加减<br/>
<a href="https://blog.csdn.net/ufo00001/article/details/72834437">https://blog.csdn.net/ufo00001/article/details/72834437</a></p>

<p>微信小程序编解码base64<br/>
<a href="https://blog.csdn.net/qq_33382313/article/details/81074347">https://blog.csdn.net/qq_33382313/article/details/81074347</a></p>

<p>微信小程序 sha1 实现密码加密<br/>
<a href="https://www.cnblogs.com/mtour/p/7116415.html">https://www.cnblogs.com/mtour/p/7116415.html</a></p>

<p><div>设置宽度，汉字正常换行，输入字母/数字不换行的解决方案分析<br/>
<a href="https://www.cnblogs.com/qq278360339/archive/2012/12/11/2813395.html">https://www.cnblogs.com/qq278360339/archive/2012/12/11/2813395.html</a></p>

<h4 id="toc_0">iOS</h4>

<p>appCode破解下载地址：<br/>
<a href="http://www.sdifen.com/appcode201631.html">http://www.sdifen.com/appcode201631.html</a></p>

<p>iOS部署企业包：<br/>
<a href="https://www.jianshu.com/p/a9db64b53607">https://www.jianshu.com/p/a9db64b53607</a></p>

<p>极光统计地址：<br/>
<a href="https://www.jiguang.cn/stat/#/app/2c155c3d850ff8cb16f857a8/crash_log_list">https://www.jiguang.cn/stat/#/app/2c155c3d850ff8cb16f857a8/crash_log_list</a></p>

<p>阿里云推送地址：<br/>
<a href="https://help.aliyun.com/document_detail/30072.html">https://help.aliyun.com/document_detail/30072.html</a></p>

<h4 id="toc_1">Other</h4>

<p>在线地图经纬度查询：<br/>
<a href="http://www.gpsspg.com/maps.htm">http://www.gpsspg.com/maps.htm</a></p>

<p>视频直播方案地址：<br/>
<a href="http://www.easynvr.com/index.html">http://www.easynvr.com/index.html</a></p>

<p>赵哲的地址：<br/>
<a href="http://www.zhaozhepublic.com/">http://www.zhaozhepublic.com/</a></p>

<p>CMMI<br/>
<a href="https://sas.cmmiinstitute.com/pars/pars_detail.aspx?a=32649">https://sas.cmmiinstitute.com/pars/pars_detail.aspx?a=32649</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序基础介绍]]></title>
    <link href="www.freefook.com/15325981613625.html"/>
    <updated>2018-07-26T17:42:41+08:00</updated>
    <id>www.freefook.com/15325981613625.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">小程序里的四种文件</h5>

<pre><code>.json 后缀的 JSON 配置文件
.wxml 后缀的 WXML 模板文件
.wxss 后缀的 WXSS 样式文件
.js 后缀的 JS 脚本逻辑文件
</code></pre>

<h4 id="toc_1">小程序数据类型</h4>

<p>WXS 语言目前共有以下几种数据类型：</p>

<pre><code>number ： 数值
string ：字符串
boolean：布尔值
object：对象
function：函数
array : 数组
date：日期
regexp：正则
</code></pre>

<h4 id="toc_2">小程序生命周期</h4>

<pre><code>onLaunch        Function    
生命周期函数--监听小程序初始化    
当小程序初始化完成时，会触发 onLaunch（全局只触发一次）

onShow          Function    
生命周期函数--监听小程序显示     
当小程序启动，或从后台进入前台显示，会触发 onShow

onHide          Function    
生命周期函数--监听小程序隐藏     
当小程序从前台进入后台，会触发 onHide

onError         Function    
错误监听函数  
当小程序发生脚本错误，
或者 api 调用失败时，会触发 onError 并带上错误信息

onPageNotFound  Function    
页面不存在监听函数   
当小程序出现要打开的页面不存在的情况，会带上页面信息回调该函数

其他  Any         
开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问
</code></pre>

<h4 id="toc_3">小程序路由方式</h4>

<pre><code>打开新页面     调用 API wx.navigateTo

页面重定向     调用 API wx.redirectTo

页面返回        调用 API wx.navigateBack

Tab 切换      调用 API wx.switchTab

重启动         调用 API wx.reLaunch
</code></pre>

<p>Tips:</p>

<pre><code>1.navigateTo, redirectTo 只能打开非 tabBar 页面。
2.switchTab 只能打开 tabBar 页面。
3.reLaunch 可以打开任意页面。
4.页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
5.tabBar只能配置最少2个、最多5个 tab
6.调用页面路由带的参数可以在目标页面的onLoad中获取
</code></pre>

<h4 id="toc_4">小程序响应的数据绑定</h4>

<pre><code>框架的核心是一个响应的数据绑定系统。
整个系统分为两块视图层（View）和逻辑层（App Service）
框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，
只需要在逻辑层修改数据，视图层就会做相应的更新。
</code></pre>

<h5 id="toc_5">工作原理</h5>

<pre><code> setData 是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。

小程序的视图层目前使用 WebView 作为渲染载体，
而逻辑层是由独立的 JavascriptCore 作为运行环境。
在架构上，WebView 和 JavascriptCore 都是独立的模块，
并不具备数据直接共享的通道。
当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。
即用户传输的数据，需要将其转换为字符串形式传递，
同时把转换后的数据内容拼接成一份 JS 脚本，
再通过执行 JS 脚本的形式传递到两边独立环境。
而 evaluateJavascript 的执行会受很多方面的影响，
数据到达视图层并不是实时的。


渐进式JavaScript 框架VUE 地址：&quot;https://cn.vuejs.org/&quot;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微信小程序开发配置介绍]]></title>
    <link href="www.freefook.com/15325981038081.html"/>
    <updated>2018-07-26T17:41:43+08:00</updated>
    <id>www.freefook.com/15325981038081.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">服务器配置</h5>

<p>服务器域名请在 小程序后台-设置-开发设置-服务器域名 中进行配置，配置时需要注意：</p>

<pre><code> •  域名只支持 https (request、uploadFile、downloadFile) 和 wss (connectSocket) 协议；
 •  域名不能使用 IP 地址或 localhost
 •  域名必须经过 ICP 备案；
 •  出于安全考虑，api.weixin.qq.com 不能被配置为服务器域名，
       相关API也不能在小程序内调用。
       开发者应将 appsecret 保存到后台服务器中，
       通过服务器使用 appsecret 获取 accesstoken，并调用相关 API。
 •  对于每个接口，分别可以配置最多 20 个域名

</code></pre>

<p><img src="media/15325981038081/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%882.58.15.png" alt="屏幕快照 2018-08-08 下午2.58.15"/></p>

<p><img src="media/15325981038081/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%884.00.18.png" alt="屏幕快照 2018-08-08 下午4.00.18"/></p>

<p><img src="media/15325981038081/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-08%20%E4%B8%8B%E5%8D%884.00.09.png" alt="屏幕快照 2018-08-08 下午4.00.09"/></p>

<h5 id="toc_1">HTTPS 证书</h5>

<pre><code>
小程序必须使用 HTTPS 请求。
小程序内会对服务器域名使用的 HTTPS 证书进行校验，
如果校验失败，则请求不能成功发起。
由于系统限制，不同平台对于证书要求的严格程度不同。
为了保证小程序的兼容性，建议开发者按照最高标准进行证书配置，
并使用相关工具检查现有证书是否符合要求。
</code></pre>

<h5 id="toc_2">对证书要求如下：</h5>

<pre><code>
 •  HTTPS 证书必须有效。证书必须被系统信任，部署SSL证书的网站域名必须与证书颁发的域名一致，证书必须在有效期内;
 •  iOS 不支持自签名证书;
 •  iOS 下证书必须满足苹果 App Transport Security (ATS) 的要求;
 •  TLS 必须支持 1.2 及以上版本。部分旧 Android 机型还未支持 TLS 1.2，请确保 HTTPS 服务器的 TLS 版本支持1.2及以下版本;
 •  部分 CA 可能不被操作系统信任，请开发者在选择证书时注意小程序和各系统的相关通告。
 •  Chrome 56/57 内核对 WoSign、StartCom 证书限制周知

</code></pre>

<h5 id="toc_3">跳过域名校验</h5>

<pre><code>
在微信开发者工具中，可以临时开启 开发环境不校验请求域名、
TLS版本及HTTPS证书 选项，跳过服务器域名的校验。
此时，在微信开发者工具中及手机开启调试模式时，不会进行服务器域名的校验。


</code></pre>

<h5 id="toc_4">关于请求</h5>

<pre><code>     •  默认超时时间和最大超时时间都是 60s
     •  request、uploadFile、downloadFile 的最大并发限制是 10 个
     •  网络请求的 referer header 不可设置。
     •  小程序进入后台运行后（非置顶聊天），如果 5s 内网络请求没有结束，会回调错误信息 fail interrupted；在回到前台之前，网络请求接口调用都会无法调用。
     •  只要成功接收到服务器返回，无论statusCode是多少，都会进入success回调。
     
</code></pre>

]]></content>
  </entry>
  
</feed>
