<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[zhangdong]]></title>
  <link href="www.freefook.com/atom.xml" rel="self"/>
  <link href="www.freefook.com/"/>
  <updated>2018-01-22T09:31:32+08:00</updated>
  <id>www.freefook.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[晒出你手机里的APP]]></title>
    <link href="www.freefook.com/15143536172739.html"/>
    <updated>2017-12-27T13:46:57+08:00</updated>
    <id>www.freefook.com/15143536172739.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143536172739/IMG_1415.png" alt="IMG_1415"/></p>

<p><img src="media/15143536172739/IMG_1416.png" alt="IMG_1416"/></p>

<p><img src="media/15143536172739/IMG_1417.png" alt="IMG_1417"/></p>

<p><img src="media/15143536172739/IMG_1418.png" alt="IMG_1418"/><br/>
<img src="media/15143536172739/IMG_1419.png" alt="IMG_1419"/><br/>
<img src="media/15143536172739/IMG_1420.png" alt="IMG_1420"/><br/>
<img src="media/15143536172739/IMG_1421.png" alt="IMG_1421"/><br/>
<img src="media/15143536172739/IMG_1422.png" alt="IMG_1422"/><br/>
<img src="media/15143536172739/IMG_1423.png" alt="IMG_1423"/><br/>
<img src="media/15143536172739/IMG_1424.png" alt="IMG_1424"/><br/>
<img src="media/15143536172739/IMG_1425.png" alt="IMG_1425"/><br/>
<img src="media/15143536172739/IMG_1426.png" alt="IMG_1426"/><br/>
<img src="media/15143536172739/IMG_1427.png" alt="IMG_1427"/><br/>
<img src="media/15143536172739/IMG_1428.png" alt="IMG_1428"/><br/>
<img src="media/15143536172739/IMG_1429.png" alt="IMG_1429"/><br/>
<img src="media/15143536172739/IMG_1430.png" alt="IMG_1430"/><br/>
<img src="media/15143536172739/IMG_1431.png" alt="IMG_1431"/><br/>
<img src="media/15143536172739/IMG_1432.png" alt="IMG_1432"/><br/>
<img src="media/15143536172739/IMG_1433.png" alt="IMG_1433"/><br/>
<img src="media/15143536172739/IMG_1434.png" alt="IMG_1434"/><br/>
<img src="media/15143536172739/IMG_1435.png" alt="IMG_1435"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC]]></title>
    <link href="www.freefook.com/15142856325027.html"/>
    <updated>2017-12-26T18:53:52+08:00</updated>
    <id>www.freefook.com/15142856325027.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC]]></title>
    <link href="www.freefook.com/15142856321781.html"/>
    <updated>2017-12-26T18:53:52+08:00</updated>
    <id>www.freefook.com/15142856321781.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 字符串操作方法说明]]></title>
    <link href="www.freefook.com/15139214218497.html"/>
    <updated>2017-12-22T13:43:41+08:00</updated>
    <id>www.freefook.com/15139214218497.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">属性字符串常用操作</h5>

<pre><code>- (NSMutableAttributedString *)stringToAttributedString:(NSString*)tempStr NSMakeRange:(int)num
{
    NSMutableAttributedString *attrString = [[NSMutableAttributedString alloc] initWithString:tempStr];
    //颜色
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(num,tempStr.length-num)];
    //字体
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(14)] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(16)] range:NSMakeRange(num,tempStr.length-num)];  
    return attrString;
}
</code></pre>

<h5 id="toc_1">将字符串分隔成数组</h5>

<pre><code>    NSString* str = @&quot;one,two,three,four,five&quot;;
    //分割字符创为数组，下例以“，”分割
    NSArray* array = [str componentsSeparatedByString:@&quot;,&quot;];
    for(NSString* obj in array)
    {
        NSLog(@&quot;%@&quot;, obj);
    }

    //链接字符串,下例以空格连接
    str = [array componentsJoinedByString:@&quot; &quot;];
    NSLog(@&quot;%@&quot;, str);
</code></pre>

<h5 id="toc_2">判断字符串是否包含另一个字符串</h5>

<pre><code>//判断”abcd” 是否含有@&quot;ab&quot;
 NSString *tempStr = @&quot;abcd&quot;;
    if([tempStr rangeOfString:@&quot;ab&quot;].location !=NSNotFound){
        NSLog(@&quot;yes&quot;);
    }else {
        NSLog(@&quot;no&quot;);
    }
</code></pre>

<h5 id="toc_3">字符串去掉特殊符号或改成去除数字/字母的笨方法</h5>

<pre><code>NSString * string111 = @&quot;1234、[]{}#%-*+=_\\|~＜&quot;;
NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;@／：；（）¥「」＂、[]{}#%-*+=_\\|~＜＞$€^•&#39;@#$%^&amp;*()_+&#39;\&quot;&quot;];
NSString *string222 = [string111 stringByTrimmingCharactersInSet:set];
</code></pre>

<h5 id="toc_4">从字符串的开头一直截取到指定的位置，但不包括该位置的字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringToIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_5">以指定位置开始（包括指定位置的字符），并包括之后的全部字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringFromIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_6">按照所给出的位置，长度（截取几位而不是到哪），任意地从字符串中截取子串</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringWithRange:NSMakeRange(0, 4)];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_7">替换字符串中字符,该方法做了copy操作，原字符串没变，需要重新赋值给原字符串</h5>

<pre><code>    NSString* tempstr4 = [tempstr3 stringByReplacingOccurrencesOfString:@&quot;:&quot; withString:@&quot;&quot;];
    NSString* tempstr5 = [tempstr4 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];
    NSString* tempstr6 = [tempstr5 stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;&quot;];
</code></pre>

<h5 id="toc_8">字符串大小写</h5>

<pre><code>//   将字符串中的英文字符由小写转换为大写
    NSString *bigString = [string uppercaseString];
    NSLog(@&quot;string = %@, bigstring = %@&quot;, string, bigString); 
       
//   将字符串中的英文字符由大写转换为小写
    NSString *smallString = [string lowercaseString];
    NSLog(@&quot;string = %@, smallString = %@&quot;, string, smallString);
    
//  将字符串的首字母改为大写
    NSString *firstBigString = [string capitalizedString];
    NSLog(@&quot;%@&quot;, firstBigString);
</code></pre>

<h5 id="toc_9">字符串拼接</h5>

<pre><code>//  字符串拼接:将两个字符串拼在一起后形成一个新的字符串,原来两个字符串并未发生改变
    NSString *string1 = @&quot;abc&quot;;
    NSString *string2 = @&quot;123&quot;;
    NSString *addString = [string1 stringByAppendingString:string2];
    NSLog(@&quot;%@&quot;, addString);
</code></pre>

<h4 id="toc_10">字符串查找</h4>

<pre><code>    NSString * string = @&quot;1234&quot;;
    //  字符串查找：判断是否以参数给定的字符串开头。是，返回真 1 ；否，返回假 0。
    BOOL result1 = [string hasPrefix:@&quot;1&quot;];
    NSLog(@&quot;%d&quot;, result1);
    
    //  字符串查找：判断是否以参数给定的字符串结尾。是，返回真 1 ；否，返回假 0。
    BOOL result2 = [string hasSuffix:@&quot;4&quot;];
    NSLog(@&quot;%d&quot;, result2);
</code></pre>

<h4 id="toc_11">反转字符串</h4>

<pre><code>/**
 *  @brief  反转字符串
 *
 *  @param strSrc 被反转字符串
 *
 *  @return 反转后字符串
 */
+ (NSString *)jk_reverseString:(NSString *)strSrc
{
    NSMutableString* reverseString = [[NSMutableString alloc] init];
    NSInteger charIndex = [strSrc length];
    while (charIndex &gt; 0) {
        charIndex --;
        NSRange subStrRange = NSMakeRange(charIndex, 1);
        [reverseString appendString:[strSrc substringWithRange:subStrRange]];
    }
    return reverseString;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 数组操作方法说明]]></title>
    <link href="www.freefook.com/15139214500331.html"/>
    <updated>2017-12-22T13:44:10+08:00</updated>
    <id>www.freefook.com/15139214500331.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">获取数组的正序迭代器</h5>

<pre><code>    NSEnumerator *enu1 = [tempArr objectEnumerator];
</code></pre>

<h5 id="toc_1">获取数组的反序迭代器</h5>

<pre><code>    NSEnumerator *enu2 = [tempArr reverseObjectEnumerator];
    //数组倒序输出
    dataArray=(NSMutableArray *)[[dataArray reverseObjectEnumerator] allObjects];
</code></pre>

<h5 id="toc_2">数组排序</h5>

<pre><code>    // 返回一个排好序的数组，原来数组的元素顺序不会改变
    // 指定元素的比较方法：compare:
    NSArray *array1 = [NSArray arrayWithObjects:@&quot;2&quot;, @&quot;3&quot;, @&quot;1&quot;, @&quot;4&quot;, nil];
    NSArray *array2 = [array1 sortedArrayUsingSelector:@selector(compare:)];
    NSLog(@&quot;array2:%@&quot;, array2);(1,2,3,4)
</code></pre>

<h5 id="toc_3">选择排序-iOS常用模式tempLogArr数组里每一元素是字典，根据字典里的dic[Index]排序</h5>

<pre><code>    for (int i=0; i&lt;tempLogArr.count; i++) {
        
        for (int j=i+1; j&lt;tempLogArr.count; j++) {
            
            if ([tempLogArr[i][@&quot;Index&quot;] intValue] &lt; [tempLogArr[j][@&quot;Index&quot;] intValue]) {
                
                [tempLogArr exchangeObjectAtIndex:i withObjectAtIndex:j];
            }
        }
    }
</code></pre>

<h5 id="toc_4">数组tempLogArr元素是字典“遍历所有”去掉重复信息用（ i--）方式，避免数组越界</h5>

<pre><code>    int x;
    int y;
    for (int i = (int)tempLogArr.count - 1; i &gt;=0 ; i--) {
        NSString * tempStr = [NSString stringWithFormat:@&quot;%@&quot;,tempLogArr[i][@&quot;Index&quot;]];
        x = [tempStr intValue];
        for (int j = i-1; j &gt;=0 ; j--) {
            y = [tempLogArr[j][@&quot;Index&quot;] intValue];
            if (x == y) {
                [tempLogArr removeObjectAtIndex:j];
            }
        }
    }

</code></pre>

<h5 id="toc_5">数组historyArray元素是字典 遍历遇到重复信息删除，停止遍历</h5>

<p>不遍历全部，针对每次增加信息的时候，都会调用这个方法，不会出现重复两次的情况</p>

<pre><code>//tempStr 信息的唯一标识，tempDic是全部信息内容
-(void)saveSearchData:(NSString*)tempStr infoDic:(NSDictionary *)tempDic
{
    /**该模块为判断浏览的信息是否已经存在历史记录里,如果存在则删除过去的,重新添加最新的搜索记录*/
    
    if (self.historyArray.count&gt;0) {
        //第一种遍历方法，数组元素为字典，字典是每条信息的全部内容
        [self.historyArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            
            //NSLog(@&quot;idx=%lu, id=%@&quot;, (unsigned long)idx, obj);
            
            if ([obj[@&quot;info_id&quot;] isEqualToString:tempStr]) {
                [self.historyArray removeObjectAtIndex:idx];
                *stop = YES;//停止遍历
            }
        }];
    }
    [self.historyArray addObject:tepDic];
}
</code></pre>

<h5 id="toc_6">遍历方法:快速枚举</h5>

<pre><code>    for(NSString* obj in tempArr)
    {
        NSLog(@&quot;%@&quot;, obj);
    }
</code></pre>

<h5 id="toc_7">遍历方法:快速遍历</h5>

<pre><code>//顺序遍历
[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = YES;//停止遍历,也可以在此增加if判断idx = 3 的时候停止。
 }];
//倒序遍历
[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = NO;//继续遍历
}];
</code></pre>

<h5 id="toc_8">动态数组NSMutableArray的add操作</h5>

<pre><code>    NSArray * array = [NSArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;, nil];
    
    //方法一
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list addObjectsFromArray: array]];
    NSLog(@&quot;%@&quot;,list);//(1,2)
    
    //方法二arrayByAddingObjectsFromArray 该方法做了copy原数据不变
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list arrayByAddingObjectsFromArray: array]
    NSLog(@&quot;%@&quot;,list);//()
    
</code></pre>

<h5 id="toc_9">数组的简单操作</h5>

<pre><code>//插入索引为几的位置
[tempArr insertObject:@&quot;two&quot; atIndex:1];

//修改数组中第2个元素的内容
[tempArr replaceObjectAtIndex:2 withObject:@&quot;aaa&quot;];

//交换数组中得内容
[tempArr exchangeObjectAtIndex:1 withObjectAtIndex:3];

//取出连续范围的元素作为子集内容
NSArray *sub1 = [tempArr subarrayWithRange:NSMakeRange(1, 3)];
</code></pre>

<h5 id="toc_10">数组的删除操作</h5>

<pre><code>//1.删除最后一个元素
 [array removeLastObject];
 NSLog(@&quot;%@&quot;,array);

//2.删除指定下标的元素
[array removeObjectAtIndex:5];
 NSLog(@&quot;%@&quot;,array);

//3.直接删除元素
[array removeObject:@&quot;e&quot;];
 NSLog(@&quot;%@&quot;,array);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC plist文件管理(代码方式)]]></title>
    <link href="www.freefook.com/15142856319824.html"/>
    <updated>2017-12-26T18:53:51+08:00</updated>
    <id>www.freefook.com/15142856319824.html</id>
    <content type="html"><![CDATA[
<pre><code>//获取本地沙盒路径
NSArray *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);

//获取完整路径
NSString *documentsPath = [path objectAtIndex:0];
NSString *plistPath = [documentsPath stringByAppendingPathComponent:@&quot;Test.plist&quot;];

//创建数据
NSMutableDictionary *dataDict = [NSMutableDictionary dictionary];

[dataDict setObject:@&quot;zhangd&quot; forKey:@&quot;name&quot;];
[dataDict setObject:@&quot;26&quot; forKey:@&quot;age&quot;];
[dataDict setObject:@&quot;man&quot; forKey:@&quot;sex&quot;];

//写入plist文件
[dataDict writeToFile:plistPath atomically:YES];

//读取plist文件
//文件是什么类型，就用什么类型的数据来接收
NSMutableDictionary *dataDict1 = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];
NSLog((@&quot;**start**\n[function name:%s]\n&quot; &quot;[Lines:%d]\n&quot; &quot;data-&gt;%@\n**end**\n\n&quot;), __FUNCTION__, __LINE__,dataDict1);

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 设计模式]]></title>
    <link href="www.freefook.com/15142851754689.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851754689.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 传值方式]]></title>
    <link href="www.freefook.com/15142851753416.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851753416.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 从AppDelegate说起]]></title>
    <link href="www.freefook.com/15142851543985.html"/>
    <updated>2017-12-26T18:45:54+08:00</updated>
    <id>www.freefook.com/15142851543985.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">创建程序窗口</h5>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
self.window.backgroundColor = [UIColor whiteColor];
[self.window setRootViewController:self.tabbarVC];
[self.window makeKeyAndVisible];
</code></pre>

<h5 id="toc_1">生命周期</h5>

<pre><code>- (void)applicationWillEnterForeground:(UIApplication *)application {
    NSLog(@&quot;将要进入前台：%s&quot;,__func__);
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    
    NSLog(@&quot;已经获得焦点：%s&quot;,__func__);
}

- (void)applicationWillResignActive:(UIApplication *)application {
    
    NSLog(@&quot;将要释放焦点：%s&quot;,__func__);
}
- (void)applicationWillTerminate:(UIApplication *)application {
    
    NSLog(@&quot;程序将要退出：%s&quot;,__func__);
}
- (void)applicationDidEnterBackground:(UIApplication *)application {
    
    NSLog(@&quot;已经进入后台：%s&quot;,__func__);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 基础使用说明]]></title>
    <link href="www.freefook.com/15139214660338.html"/>
    <updated>2017-12-22T13:44:26+08:00</updated>
    <id>www.freefook.com/15139214660338.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">pragma - mark - tableview列表初始化</h5>

<pre><code>-(UITableView *)tableView
{
    if (!_tableView) {
        
        _tableView = [[UITableView alloc]initWithFrame:
                      CGRectMake(, , , ) style:UITableViewStylePlain];
        _tableView.delegate = self;
        _tableView.dataSource = self;
        _tableView.backgroundColor = ;
        //分割线的颜色
        _tableView.separatorColor = ;
        //隐藏滚动条
        _tableView.showsVerticalScrollIndicator = NO;
        _tableView.tableFooterView = [[UIView alloc]init];
        
    }
    return _tableView;
}
</code></pre>

<h5 id="toc_1">tableview 代理方法实现如下：</h5>

<h6 id="toc_2">tableview解决常规配置的重复问题。。。</h6>

<pre><code>//当页面拉动需要显示新数据的时候，把最后一个cell进行删除 此方案即可避免重复显示，又重用了cell相对内存管理来说是好的方案 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @&quot;Cell&quot;;
    // 通过唯一标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免
    {
        while ([cell.contentView.subviews lastObject] != nil) {
            [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview];
        }
    }
    
//点击没有选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;  

// 对cell 进行简单地数据配置
cell.textLabel.text = @&quot;text&quot;;
   
return cell;
}
</code></pre>

<h5 id="toc_3">other</h5>

<pre><code>//行
-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    
    return &lt;#@#&gt;;
}
//行高
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return &lt;#@#&gt;;
}

#pragma - mark - 点击cell方法

-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    
}
</code></pre>

<h5 id="toc_4">tableview header与footer</h5>

<pre><code>#pragma - mark - tableview_Header and Footer

-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    
    return 0;
}

-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section
{
    
    return 0;
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 常用属性与方法]]></title>
    <link href="www.freefook.com/15142851756052.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851756052.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">tableview 常用属性如下：</h5>

<pre><code>//获取手势点击的是哪一个cell的坐标
NSIndexPath *indexPath = [self.tableView indexPathForCell:((UITableViewCell *)longPress.view)];

//点击button时获取button所在的cell的indexpath
UIButton *button = sender;
tempTableViewCell *cell = (tempTableViewCell *)[[button superview] superview];
NSIndexPath *indexPath = [_tableView indexPathForCell:cell];

//局部刷新一个section刷新    
NSIndexSet *indexSet=[[NSIndexSet alloc]initWithIndex:1];    
[tableview reloadSections:indexSet withRowAnimation:UITableViewRowAnimationAutomatic];    

//局部刷新一个cell刷新   
NSIndexPath *indexPath=[NSIndexPath indexPathForRow:1 inSection:0];   
[tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:indexPath,nil] withRowAnimation:UITableViewRowAnimationNone]; 

//不显示分割线
_tableView.separatorStyle = UITableViewCellSeparatorStyleNone;

//显示箭头
cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;

//无选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;

//自适应单元格高度
tableView.rowHeight = UITableViewAutomaticDimension; 
//先估计一个高度
tableView.estimatedRowHeight = 50; 
</code></pre>

<pre><code></code></pre>

<pre><code></code></pre>

<h5 id="toc_1">tableview 常用方法如下：</h5>

<h6 id="toc_2">tableview 选中第几行</h6>

<pre><code>NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView selectRowAtIndexPath:indexpath animated:YES scrollPosition:UITableViewScrollPositionMiddle];  //选中第5行
</code></pre>

<h6 id="toc_3">滚动到指定位置</h6>

<pre><code>//滚动到指定位置_偏移量
[self.rizhiTableView setContentOffset:CGPointMake(0, OffsetY) animated:NO];
//滚动到第几行
NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionTop animated:NO];
</code></pre>

<h6 id="toc_4">pragma mark  - 滑到最底部</h6>

<pre><code>- (void)scrollTableToFoot
{
    
    dispatch_async(dispatch_get_main_queue(), ^{
        
        NSInteger s = [self.tableView numberOfSections];  //有多少组
        if (s&lt;1) return;  //无数据时不执行 要不会crash
        NSInteger r = [self.tableView numberOfRowsInSection:s-1]; //最后一组有多少行
        if (r&lt;1) return;
        NSIndexPath *indexpath = [NSIndexPath indexPathForRow:r-1 inSection:s-1];  //取最后一行数据
        [self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionBottom animated:NO]; //滚动到最后一行
        
    });
  
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UICollectionView使用详解]]></title>
    <link href="www.freefook.com/15142851752080.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851752080.html</id>
    <content type="html"><![CDATA[
<p>添加代理</p>

<pre><code>&lt;UICollectionViewDataSource,UICollectionViewDelegate&gt;
</code></pre>

<p>初始化</p>

<pre><code> UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
    flowLayout.minimumInteritemSpacing = 0;
    flowLayout.minimumLineSpacing = 0;
    flowLayout.sectionInset  = UIEdgeInsetsMake(0, 5, 0, 5);
    
_collectionView = [[UICollectionView alloc] initWithFrame:
CGRectMake(0, 0, self.view.frame.size.with,self.view.frame.size.height) 
collectionViewLayout:flowLayout];
    
    //一定要注册
    [_collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;colletionCell&quot;];
    [_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;HeaderIdentifier&quot;];
    
    _collectionView.backgroundColor = [UIColor whiteColor];
    _collectionView.dataSource = self;
    _collectionView.delegate = self;
    
    _collectionView.alwaysBounceVertical = YES;
    _collectionView.showsVerticalScrollIndicator = NO;
    [self.view addSubview:_collectionView];
    
    if (@available(iOS 11.0, *)) {
    }else{
        self.automaticallyAdjustsScrollViewInsets = NO;
    }
</code></pre>

<p>设置_collectionView的组数</p>

<pre><code>-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 3;
}
</code></pre>

<p>设置每组cell的个数</p>

<pre><code>//返回每组的个数
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    if (section == 0) {
        return 3;
    }else if (section == 1){
        return 4;
    }else if (section == 2){
        return 3;
    }
    return 0;
} 

</code></pre>

<p>设置每组cell的大小</p>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    if (indexPath.section == 0) {
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
        
    }else if (indexPath.section == 1){
        return  CGSizeMake((KScreenWidth-10)/2, KScreenWidth/2+60);

    }else{
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
    }
}
</code></pre>

<p>布局cell</p>

<pre><code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *reuseIdetify = @&quot;colletionCell&quot;;
    
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdetify forIndexPath:indexPath];
    
    cell.contentView.backgroundColor = [UIColor whiteColor];
    //这句是每次都移除view上的控件,从新添加的;
    [cell.contentView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
    
    /***********布局cell*********/


    /***************************/ 
       
    return cell;
}
</code></pre>

<p>设置_collectionView头部header高度</p>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section {
    
    if (section == 0) {
        CGSize size={KScreenWidth,cycHeight + 240};
        return size;
        
    }else if (section == 1){
        CGSize size={KScreenWidth,140};
        return size;

    }else{
        CGSize size={KScreenWidth,40};
        return size;

    }
}
</code></pre>

<p>布局_collectionView上的头部UI</p>

<pre><code>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView
           viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath
{
    
    UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader
                                                                            withReuseIdentifier:@&quot;HeaderIdentifier&quot;
                                                                                   forIndexPath:indexPath];

    [headView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];

    if (indexPath.section == 0) {
        
        if(kind ==UICollectionElementKindSectionHeader){
            
        }
     }
    
    return headView;
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 计算时间差]]></title>
    <link href="www.freefook.com/15142851759902.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851759902.html</id>
    <content type="html"><![CDATA[
<pre><code>//计算时间差,刚刚,几分钟,几小时,昨天,前天

+(NSString *)CreatedTimeToNowTime:(NSString *)CreatTime
{
    //时间
    NSString *createdTimeStr = @&quot;2017-12-27 09:09:10&quot;;
    
    //把字符串转为NSdate
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];
    NSDate *timeDate = [dateFormatter dateFromString:createdTimeStr];
    
    //得到与当前时间差
    NSTimeInterval timeInterval = [timeDate timeIntervalSinceNow];
    timeInterval = -timeInterval;
    
    long temp = 0;
    
    NSString *result;
    
    if (timeInterval &lt; 60) {
        result = [NSString stringWithFormat:@&quot;刚刚&quot;];
        
    }else if((temp = timeInterval/60) &lt; 60){
        result = [NSString stringWithFormat:@&quot;%ld分钟前&quot;,temp];
        
    }else if((temp = timeInterval/3600) &gt; 1 &amp;&amp; (temp = timeInterval/3600) &lt;24){
        result = [NSString stringWithFormat:@&quot;%ld小时前&quot;,temp];
        
    }else if ((temp = timeInterval/3600) &gt; 24 &amp;&amp; (temp = timeInterval/3600) &lt; 48){
        result = [NSString stringWithFormat:@&quot;昨天&quot;];
        
    }else if ((temp = timeInterval/3600) &gt; 48 &amp;&amp; (temp = timeInterval/3600) &lt; 72){
        result = [NSString stringWithFormat:@&quot;前天&quot;];
        
    }else{
        result = createdTimeStr;//返回具体时间日期
        
    }
    
    NSLog(@&quot;%@&quot;,result);

    return result;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 信息格式验证]]></title>
    <link href="www.freefook.com/15142851758481.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851758481.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">手机号信息格式验证</h4>

<pre><code>//仅判断开头是否为1 位数是否为11 即可
if(textField1.text.length != 11 || ![textField1.text hasPrefix:@&quot;1&quot;])

</code></pre>

<p>如果想详细判断如下操作即可：</p>

<pre><code>#pragma mark - 判断是否为电话号码
- (BOOL)isPhoneNumber
{
    /**
     * 移动号段正则表达式
     */
    NSString *CM_NUM = @&quot;^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\d{8}|(1705)\\d{7}$&quot;;
    /**
     * 联通号段正则表达式
     */
    NSString *CU_NUM = @&quot;^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\d{8}|(1709)\\d{7}$&quot;;
    /**
     * 电信号段正则表达式
     */
    NSString *CT_NUM = @&quot;^((133)|(153)|(177)|(18[0,1,9]))\\d{8}$&quot;;
    NSPredicate *pred1 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM_NUM];
    BOOL isMatch1 = [pred1 evaluateWithObject:self];
    NSPredicate *pred2 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU_NUM];
    BOOL isMatch2 = [pred2 evaluateWithObject:self];
    NSPredicate *pred3 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT_NUM];
    BOOL isMatch3 = [pred3 evaluateWithObject:self];
    
    if (isMatch1 || isMatch2 || isMatch3) {
        return YES;
    }else{
        return NO;
    }
}
</code></pre>

<h4 id="toc_1">身份证信息格式验证</h4>

<pre><code>#pragma mark 身份证格式验证
+(BOOL)verifyIDCardNumber:(NSString *)value
{
    value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([value length] != 18) {
        return NO;
    }
    NSString *mmdd = @&quot;(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)(0[1-9]|[12][0-9]|30))|(02(0[1-9]|[1][0-9]|2[0-8])))&quot;;
    NSString *leapMmdd = @&quot;0229&quot;;
    NSString *year = @&quot;(19|20)[0-9]{2}&quot;;
    NSString *leapYear = @&quot;(19|20)(0[48]|[2468][048]|[13579][26])&quot;;
    NSString *yearMmdd = [NSString stringWithFormat:@&quot;%@%@&quot;, year, mmdd];
    NSString *leapyearMmdd = [NSString stringWithFormat:@&quot;%@%@&quot;, leapYear, leapMmdd];
    NSString *yyyyMmdd = [NSString stringWithFormat:@&quot;((%@)|(%@)|(%@))&quot;, yearMmdd, leapyearMmdd, @&quot;20000229&quot;];
    NSString *area = @&quot;(1[1-5]|2[1-3]|3[1-7]|4[1-6]|5[0-4]|6[1-5]|82|[7-9]1)[0-9]{4}&quot;;
    NSString *regex = [NSString stringWithFormat:@&quot;%@%@%@&quot;, area, yyyyMmdd  , @&quot;[0-9]{3}[0-9Xx]&quot;];
    NSPredicate *regexTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];
    if (![regexTest evaluateWithObject:value]) {
        return NO;
    }
    int summary = ([value substringWithRange:NSMakeRange(0,1)].intValue + [value substringWithRange:NSMakeRange(10,1)].intValue) *7
    + ([value substringWithRange:NSMakeRange(1,1)].intValue + [value substringWithRange:NSMakeRange(11,1)].intValue) *9
    + ([value substringWithRange:NSMakeRange(2,1)].intValue + [value substringWithRange:NSMakeRange(12,1)].intValue) *10
    + ([value substringWithRange:NSMakeRange(3,1)].intValue + [value substringWithRange:NSMakeRange(13,1)].intValue) *5
    + ([value substringWithRange:NSMakeRange(4,1)].intValue + [value substringWithRange:NSMakeRange(14,1)].intValue) *8
    + ([value substringWithRange:NSMakeRange(5,1)].intValue + [value substringWithRange:NSMakeRange(15,1)].intValue) *4
    + ([value substringWithRange:NSMakeRange(6,1)].intValue + [value substringWithRange:NSMakeRange(16,1)].intValue) *2
    + [value substringWithRange:NSMakeRange(7,1)].intValue *1 + [value substringWithRange:NSMakeRange(8,1)].intValue *6
    + [value substringWithRange:NSMakeRange(9,1)].intValue *3;
    NSInteger remainder = summary % 11;
    NSString *checkBit = @&quot;&quot;;
    NSString *checkString = @&quot;10X98765432&quot;;
    checkBit = [checkString substringWithRange:NSMakeRange(remainder,1)];// 判断校验位
    return [checkBit isEqualToString:[[value substringWithRange:NSMakeRange(17,1)] uppercaseString]];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发说明]]></title>
    <link href="www.freefook.com/15139213651453.html"/>
    <updated>2017-12-22T13:42:45+08:00</updated>
    <id>www.freefook.com/15139213651453.html</id>
    <content type="html"><![CDATA[
<pre><code>what？

项目分配下来后，针对一些疑问的解释说明。
针对一些项目中开发事宜，做一些解释说明。
针对一些项目中重复代码，做一些记录，不管在哪个电脑，哪个项目，写的时候，可以copy。

why?

避免一些情况 “开发做了很多，布局调整导致缝缝补补的局面”。
所以有经验的开发人员总会说一句，就是“不管简单或复杂的页面，都不要写死了。
谁知道哪天甲方/产品说这里很简单，改一下吧，那个很简单，改一下吧”
如果你没时间改，那别给队友带刀啊。
所以统一规范，统一大块的思路，在程序中增加说明文件，减少上班带刀的同事，避免做地铁过安检的问题。

how?

建项开始:
1. 项目问题汇总
2. 建项使用三方管理工具cocoapods
3. 建项创建.pch文件
4. 建项那些.pch里写了些什么
5. 建项权限、网络问题
6. 建项屏幕适配问题
</code></pre>

<h4 id="toc_0">程序的“通用性”</h4>

<pre><code>用简单的代码去解决的问题，不要过分的关注了“通用性”，
“可维护性”和“可扩展性”，被搞得绕来绕去，让人琢磨不透。
不用装逼搞酷炫，不是在搞复杂性的东西，不要一个东西调了四五层去解决问题；
“考虑”到了通用性，并不等于你就准确地“把握”住了通用性；

如果在第一次的设计中就过早的考虑到将来，由此带来的多余的复杂性，
有可能让初期的设计就出现问题。所以这种对于将来的变化的考虑，实际上帮了倒忙。
尽量不要大段 大段的留下注释代码，留下以后说可能会用，
其实在打开注释用到的可能性有多少，少之又少。

代码需要被“重用”的场合，实际上比你想象的要少。所以尽可能的简单
因为简单的东西每个项目重复性的、大量的会去写，
所以有些东西，可以放在xcode 的代码块里；

最后不要极端的追求所谓“程序的正确性”畏首畏尾的写程序，
正确不等于直接，高效，放手写吧。。。

</code></pre>

<h4 id="toc_1">简单的编码中规范说明</h4>

<p>程序开始增加说明文件</p>

<pre><code>说明文件，记录项目功能实现的思维说明：
1.MVC  MVVM MVCS 等放荡不羁的模式
2.复杂UI的实现说明或使用了他人封装类库，注明使用方法示例；
3.网络请求方式，加密方式，部数据处理方式；
4.本地数据的存储方式
5.复杂业务逻辑的流程说明，与实现后遗留缺陷。
6.写出你认为程序中还遗留的缺陷， bug，改进，优化的地方
</code></pre>

<h4 id="toc_2">程序开发过程中命名方式</h4>

<blockquote>
<p>大家公认无岐义的缩写(比如：nav，bg，btn等)<br/>
写在哪些命名里都可以</p>
</blockquote>

<h5 id="toc_3">类命名：前缀+描述+类型</h5>

<pre><code>1.创建一个类时，增加自己名字首字母的简写例如：张东 ZDLoginViewController
2.ViewController 是处理业务逻辑，UI 代码 数据请求与处理 尽量不要写太多
3.view的生命周期的几个方法 在类中方法的最上方
4.类中方法增加Mark（#pragma - mark - 点击登录，请求登录接口 ）

</code></pre>

<h5 id="toc_4">属性命名：描述性单词+变量类型</h5>

<pre><code>UILabel* nameLabel;
</code></pre>

<h5 id="toc_5">方法命名</h5>

<pre><code>一个规范的方法读起来应该像一句完整的话，读过之后便知函数的作用。
返回性的方法应该以返回的内容开头，但之前不要加get。
不要各种缩写，写完猜不出意思。保持完整性

</code></pre>

<h5 id="toc_6">函数命名</h5>

<pre><code>一些典型操作应该使用约定的动词，如initWith,insert,remove,replace,add等等。
</code></pre>

<h5 id="toc_7">程序中使用的图片命名</h5>

<pre><code>在Assets.xcassets里创建相应使用的功能模块文件夹
例如：personalCenter 文件里放登录、注册、我的信息用到的图片
图片命名 类型+模块/功能 例如：btn/bg_login_normal@3x.png 
</code></pre>

<h5 id="toc_8">代码注释</h5>

<pre><code>代码的注释问题:很多人的注释过于粗糙,有些甚至都没有注释习惯,导致代码可读性差,
版本迭代或是需求变更的时候不能及时定位到具体代码；

注释方式例如：
/** 名字 */
@property(nonatomic,strong)NSString* name;

这样注释的好处是:
当你调用这个属性时会具有相关备注提示

</code></pre>

<h5 id="toc_9">代码中的循环与判断</h5>

<pre><code>在任何情况下 for 语句和 if 语句之后必须写花括号，
即使允许你在其只包含一行代码的时候可以省略
for (int i=0; i &lt; n; i++)
   function(i);
   
for (int i=0; i &lt; n; i++) {
   function(i);
 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 1 ->TabBar]]></title>
    <link href="www.freefook.com/15142722458623.html"/>
    <updated>2017-12-26T15:10:45+08:00</updated>
    <id>www.freefook.com/15142722458623.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">学习优秀的封装</h4>

<p>CYLTabBarController</p>

<pre><code>【中国特色 TabBar】最低只需传两个数组即可完成主流App框架搭建【iPhoneX supported】 

 （转载 https://github.com/ChenYilong）

</code></pre>

<h5 id="toc_1">CYLTabBarController【低耦合集成TabBarController】</h5>

<h5 id="toc_2">集成后的效果：</h5>

<table>
<thead>
<tr>
<th>既支持默认样式</th>
<th>同时也支持创建自定义的形状不规则加号按钮</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i62.tinypic.com/rvcbit.jpg?192x251_130" alt="enter image description here"/></td>
<td><img src="http://i58.tinypic.com/24d4t3p.jpg?192x251_130" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>支持横竖屏<br/>
 <img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_3">使用<a href="https://github.com/ChenYilong/CYLTabBarController">CYLTabBarController</a></h4>

<p>四步完成主流App框架搭建：</p>

<ol>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8cocoapods%E5%AF%BC%E5%85%A5cyltabbarcontroller"> 第一步：使用CocoaPods导入CYLTabBarController </a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E8%AE%BE%E7%BD%AEcyltabbarcontroller%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E7%BB%84%E5%92%8Ctabbar%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%B0%86cyltabbarcontroller%E8%AE%BE%E7%BD%AE%E4%B8%BAwindow%E7%9A%84rootviewcontroller">第三步：将CYLTabBarController设置为window的RootViewController</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E5%8F%AF%E9%80%89%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BD%A2%E7%8A%B6%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A0%E5%8F%B7%E6%8C%89%E9%92%AE">第四步（可选）：创建自定义的形状不规则加号按钮</a> </li>
</ol>

<h5 id="toc_4">第一步：省略使用CocoaPods导入CYLTabBarController</h5>

<h5 id="toc_5">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</h5>

<pre><code class="language-Objective-C"> - (void)setupViewControllers {
    CYLHomeViewController *firstViewController = [[CYLHomeViewController alloc] init];
    UIViewController *firstNavigationController = [[UINavigationController alloc]
                                                   initWithRootViewController:firstViewController];
    
    CYLSameFityViewController *secondViewController = [[CYLSameFityViewController alloc] init];
    UIViewController *secondNavigationController = [[UINavigationController alloc]
                                                    initWithRootViewController:secondViewController];
    

    CYLTabBarController *tabBarController = [[CYLTabBarController alloc] init];
    [self customizeTabBarForController:tabBarController];
    
    [tabBarController setViewControllers:@[
                                           firstNavigationController,
                                           secondNavigationController,
                                           ]];
    self.tabBarController = tabBarController;
}

/*
 *
 在`-setViewControllers:`之前设置TabBar的属性，
 *
 */
- (void)customizeTabBarForController:(CYLTabBarController *)tabBarController {
    
    NSDictionary *dict1 = @{
                            CYLTabBarItemTitle : @&quot;首页&quot;,
                            CYLTabBarItemImage : @&quot;home_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;home_highlight&quot;,
                            };
    NSDictionary *dict2 = @{
                            CYLTabBarItemTitle : @&quot;同城&quot;,
                            CYLTabBarItemImage : @&quot;mycity_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;mycity_highlight&quot;,
                            };

    NSArray *tabBarItemsAttributes = @[ dict1, dict2 ];
    tabBarController.tabBarItemsAttributes = tabBarItemsAttributes;
}
</code></pre>

<p>在这个字典中，<code>CYLTabBarItemImage</code> 和 <code>CYLTabBarItemSelectedImage</code> 支持 <code>NSString</code>、<code>UIImage</code><br/>
两种格式。<code>CYLTabBarItemTitle</code> 不设置将只展示图标，并会对布局作出居中处理。</p>

<h5 id="toc_6">第三步：将CYLTabBarController设置为window的RootViewController</h5>

<pre><code class="language-Objective-C"> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window setRootViewController:self.tabBarController];
 /* *省略部分：   * */
    return YES;
}
</code></pre>

<h5 id="toc_7">第四步（可选）：创建自定义的形状不规则加号按钮</h5>

<p>创建一个继承于 CYLPlusButton 的类，要求和步骤：</p>

<ol>
<li><p>实现  <code>CYLPlusButtonSubclassing</code>  协议 </p></li>
<li><p>子类将自身类型进行注册，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C">+ (void)load {
[super registerPlusButton];
}
</code></pre></li>
</ol>

<p>协议提供了可选方法：</p>

<pre><code class="language-Objective-C">+ (NSUInteger)indexOfPlusButtonInTabBar;
+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
+ (UIViewController *)plusChildViewController;
+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>作用分别是：</p>

<pre><code class="language-Objective-C"> + (NSUInteger)indexOfPlusButtonInTabBar;
</code></pre>

<p>用来自定义加号按钮的位置，如果不实现默认居中，但是如果 <code>tabbar</code> 的个数是奇数则必须实现该方法，否则 <code>CYLTabBarController</code> 会抛出 <code>exception</code> 来进行提示。</p>

<p>主要适用于如下情景：</p>

<p><img src="http://a64.tinypic.com/2mo0h.jpg" alt="enter image description here"/></p>

<p>Airbnb-app效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<pre><code class="language-Objective-C">+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>该方法是为了调整自定义按钮中心点Y轴方向的位置，建议在按钮超出了 <code>tabbar</code> 的边界时实现该方法。返回值是自定义按钮中心点Y轴方向的坐标除以 <code>tabbar</code> 的高度，如果不实现，会自动进行比对，预设一个较为合适的位置，如果实现了该方法，预设的逻辑将失效。</p>

<p>内部实现时，会使用该返回值来设置 PlusButton 的 centerY 坐标，公式如下：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说：如果 constantOfPlusButtonCenterYOffset 为0，同时 multiplierOfTabBarHeight 的值是0.5，表示 PlusButton 居中，小于0.5表示 PlusButton 偏上，大于0.5则表示偏下。</p>

<pre><code class="language-Objective-C">+ (CGFloat)constantOfPlusButtonCenterYOffsetForTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>参考 <code>+multiplierOfTabBarHeight:</code> 中的公式：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说： constantOfPlusButtonCenterYOffset 大于0会向下偏移，小于0会向上偏移。</p>

<p>注意：实现了该方法，但没有实现 <code>+multiplierOfTabBarHeight:</code> 方法，在这种情况下，会在预设逻辑的基础上进行偏移。</p>

<p>详见Demo中的 <code>CYLPlusButtonSubclass</code> 类的实现。</p>

<pre><code class="language-Objective-C">+ (UIViewController *)plusChildViewController;
</code></pre>

<p>详见： <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%82%B9%E5%87%BB-plusbutton-%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A-uiviewcontroller">点击 PlusButton 跳转到指定 UIViewController</a> </p>

<p>另外，如果加号按钮超出了边界，一般需要手动调用如下代码取消 tabbar 顶部默认的阴影，可在 AppDelegate 类中调用：</p>

<pre><code class="language-Objective-C">    //去除 TabBar 自带的顶部阴影
    [[UITabBar appearance] setShadowImage:[[UIImage alloc] init]];        
</code></pre>

<p>// iOS10 后 需要使用 <code>-[CYLTabBarController hideTabBadgeBackgroundSeparator]</code> 见 AppDelegate 类中的演示;</p>

<p>如何调整、自定义 <code>PlusButton</code> 与其它 <code>TabBarItem</code> 的宽度？</p>

<p><code>CYLTabBarController</code> 规定：</p>

<pre><code class="language-Objective-C"> TabBarItem 宽度 ＝  ( TabBar 总宽度 －  PlusButton 宽度  ) / (TabBarItem 个数)
</code></pre>

<p>所以想自定义宽度，只需要修改 <code>PlusButton</code> 的宽度即可。</p>

<p>比如你就可以在 Demo中的 <code>CYLPlusButtonSubclass.m</code> 类里：</p>

<p>把</p>

<pre><code class="language-Objective-C"> [button sizeToFit]; 
</code></pre>

<p>改为</p>

<pre><code class="language-Objective-C"> button.frame = CGRectMake(0.0, 0.0, 250, 100);
 button.backgroundColor = [UIColor redColor];
</code></pre>

<p>效果如下，<br/>
1.17.4<br/>
<img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>同时你也可以顺便测试下 <code>CYLTabBarController</code> 的这一个特性：</p>

<blockquote>
<p>即使加号按钮超出了tabbar的区域，超出部分依然能响应点击事件</p>
</blockquote>

<p>并且你可以在项目中的任意位置读取到 <code>PlusButton</code> 的宽度，借助 <code>CYLTabBarController.h</code> 定义的 <code>CYLPlusButtonWidth</code> 这个extern。可参考 <code>+[CYLTabBarControllerConfig customizeTabBarAppearance:]</code> 里的用法。</p>

<h3 id="toc_8">补充说明</h3>

<h4 id="toc_9">自定义 <code>TabBar</code> 样式</h4>

<p>如果想更进一步的自定义 <code>TabBar</code> 样式可在 <code>-application:didFinishLaunchingWithOptions:</code> 方法中设置</p>

<pre><code class="language-Objective-C"> /**
 *  tabBarItem 的选中和不选中文字属性、背景图片
 */
- (void)customizeInterface {
    
    // 普通状态下的文字属性
    NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];
    normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];
    
    // 选中状态下的文字属性
    NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];
    selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];
    
    // 设置文字属性
    UITabBarItem *tabBar = [UITabBarItem appearance];
    [tabBar setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];
    [tabBar setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];
    
    // 设置背景图片
    UITabBar *tabBarAppearance = [UITabBar appearance];
    [tabBarAppearance setBackgroundImage:[UIImage imageNamed:@&quot;tabbar_background&quot;]];
}

 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window makeKeyAndVisible];
    [self customizeInterface];
    return YES;
}
</code></pre>

<h4 id="toc_10">捕获 TabBar 点击事件</h4>

<p>实现 CYLTabBarController 的如下几个代理方法即可捕获点击事件。 </p>

<p>下面这个方法能捕获当前点击的 <code>TabBar</code> 上的控件，可以是 <code>UITabBarButton</code>、也可以 <code>PlusButton</code>、也可以是添加到 <code>TabBar</code> 上的任意 <code>UIControl</code> 的子类。但是如果 <code>PlusButton</code> 也添加了点击事件，那么点击 <code>PlusButton</code> 将不会被触发这个代理方法。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 * @attention If PlusButton also add an action, then this delegate method will not be invoked when the PlusButton is selected.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>下面这个方法能捕获跳转前所在的控制器，以及跳转到的目标控制器。</p>

<pre><code class="language-Objective-C">//UITabBarController.h
@protocol UITabBarControllerDelegate &lt;NSObject&gt;
@optional
- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController NS_AVAILABLE_IOS(3_0);
@end

</code></pre>

<p>注意：在调用该方法时应该始终调用<br/>
<code>[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];</code> 来确保 <code>PlusButton</code> 的选中状态。示例如下：</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
    [[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
    return YES;
}
</code></pre>

<p>相关用法已经在 Demo 中展示。</p>

<p>遵循协议的方式如下：</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //...
        tabBarControllerConfig.tabBarController.delegate = self;
    //...
    return YES;
}
</code></pre>

<h4 id="toc_11">点击 TabBarButton 时添加动画</h4>

<p>Demo 演示的效果图：</p>

<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fg9hu6qnwbg308v0gctcc.gif" alt=""/></p>

<p>实现如下代理方法，就能得到对应的选中控件，可以在控件上直接添加动画。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>Demo 中示例代码如下：</p>

<p>遵循协议</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end
</code></pre>

<pre><code class="language-Objective-C"> //AppDelegate.m
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control {
    UIView *animationView;
    // 如果 PlusButton 也添加了点击事件，那么点击 PlusButton 后不会触发该代理方法。
    if ([control isKindOfClass:[CYLExternPlusButton class]]) {
        UIButton *button = CYLExternPlusButton;
        animationView = button.imageView;
    } else if ([control isKindOfClass:NSClassFromString(@&quot;UITabBarButton&quot;)]) {
        for (UIView *subView in control.subviews) {
            if ([subView isKindOfClass:NSClassFromString(@&quot;UITabBarSwappableImageView&quot;)]) {
                animationView = subView;
            }
        }
    }
    
    if ([self cyl_tabBarController].selectedIndex % 2 == 0) {
        [self addScaleAnimationOnView:animationView];
    } else {
        [self addRotateAnimationOnView:animationView];
    }
}

//缩放动画
- (void)addScaleAnimationOnView:(UIView *)animationView {
    //需要实现的帧动画，这里根据需求自定义
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;transform.scale&quot;;
    animation.values = @[@1.0,@1.3,@0.9,@1.15,@0.95,@1.02,@1.0];
    animation.duration = 1;
    animation.calculationMode = kCAAnimationCubic;
    [animationView.layer addAnimation:animation forKey:nil];
}

//旋转动画
- (void)addRotateAnimationOnView:(UIView *)animationView {
    [UIView animateWithDuration:0.32 delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{
        animationView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
    } completion:nil];
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [UIView animateWithDuration:0.70 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0.2 options:UIViewAnimationOptionCurveEaseOut animations:^{
            animationView.layer.transform = CATransform3DMakeRotation(2 * M_PI, 0, 1, 0);
        } completion:nil];
    });
}
</code></pre>

<h4 id="toc_12">横竖屏适配</h4>

<p><code>TabBar</code> 横竖屏适配时，如果你添加了 <code>PlusButton</code>，且适配时用到了 <code>TabBarItem</code> 的宽度, 不建议使用系统的<code>UIDeviceOrientationDidChangeNotification</code> , 请使用库里的 <code>CYLTabBarItemWidthDidChangeNotification</code> 来更新 <code>TabBar</code> 布局，最典型的场景就是，根据 <code>TabBarItem</code> 在不同横竖屏状态下的宽度变化来切换选中的<code>TabBarItem</code> 的背景图片。Demo 里 <code>CYLTabBarControllerConfig.m</code> 给出了这一场景的用法:</p>

<p><code>CYLTabBarController.h</code>  中提供了 <code>CYLTabBarItemWidth</code> 这一extern常量，并且会在 <code>TabBarItem</code> 的宽度发生变化时，及时更新该值，所以用法就如下所示：</p>

<pre><code class="language-Objective-C">- (void)updateTabBarCustomizationWhenTabBarItemWidthDidUpdate {
    void (^deviceOrientationDidChangeBlock)(NSNotification *) = ^(NSNotification *notification) {
        [self tabBarItemWidthDidUpdate];
};
    [[NSNotificationCenter defaultCenter] addObserverForName:CYLTabBarItemWidthDidChangeNotification
                                                      object:nil
                                                       queue:[NSOperationQueue mainQueue]
                                                  usingBlock:deviceOrientationDidChangeBlock];
}

- (void)tabBarItemWidthDidUpdate {
    UIDeviceOrientation orientation = [[UIDevice currentDevice] orientation];
    if ((orientation == UIDeviceOrientationLandscapeLeft) || (orientation == UIDeviceOrientationLandscapeRight)) {
        NSLog(@&quot;Landscape Left or Right !&quot;);
    } else if (orientation == UIDeviceOrientationPortrait){
        NSLog(@&quot;Landscape portrait!&quot;);
    }
    CGSize selectionIndicatorImageSize = CGSizeMake(CYLTabBarItemWidth, [self cyl_tabBarController].tabBar.bounds.size.height);
    [[self cyl_tabBarController].tabBar setSelectionIndicatorImage:[[self class]
                                                                    imageFromColor:[UIColor yellowColor]
                                                                    forSize:selectionIndicatorImageSize
                                                                    withCornerRadius:0]];
}
</code></pre>

<p><img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_13">访问初始化好的 CYLTabBarController 对象</h4>

<p>对于任意 <code>NSObject</code> 对象：</p>

<p><code>CYLTabBarController.h</code>  中为 <code>NSObject</code> 提供了分类方法 <code>-cyl_tabBarController</code> ，所以在任意对象中，一行代码就可以访问到一个初始化好的  <code>CYLTabBarController</code>  对象，<code>-cyl_tabBarController</code> 的作用你可以这样理解：与获取单例对象的  <code>+shareInstance</code> 方法作用一样。</p>

<p>接口如下：</p>

<pre><code class="language-Objective-C">// CYLTabBarController.h

@interface NSObject (CYLTabBarController)

/**
 * If `self` is kind of `UIViewController`, this method will return the nearest ancestor in the view controller hierarchy that is a tab bar controller. If `self` is not kind of `UIViewController`, it will return the `rootViewController` of the `rootWindow` as long as you have set the `CYLTabBarController` as the  `rootViewController`. Otherwise return nil. (read-only)
 */
@property (nonatomic, readonly) CYLTabBarController *cyl_tabBarController;

@end
</code></pre>

<p>用法：</p>

<pre><code class="language-Objective-C">//导入 CYLTabBarController.h
#import &quot;CYLTabBarController.h&quot;

- (void)viewDidLoad {
    [super viewDidLoad];
    CYLTabBarController *tabbarController = [self cyl_tabBarController];
    /*...*/
}
</code></pre>

<h4 id="toc_14">点击 PlusButton 跳转到指定 UIViewController</h4>

<p>提供了一个协议方法来完成本功能：</p>

<p><img src="http://i68.tinypic.com/2who9rs.jpg" alt="enter image description here"/></p>

<p>实现该方法后，能让 PlusButton 的点击效果与跟点击其他 TabBar 按钮效果一样，跳转到该方法指定的 UIViewController 。</p>

<p>注意：必须同时实现 <code>+indexOfPlusButtonInTabBar</code> 来指定 PlusButton 的位置。</p>

<p>遵循几个协议：</p>

<p><img src="http://i64.tinypic.com/14jw5zt.jpg" alt="enter image description here"/></p>

<p>另外你可以通过下面这个方法获取到 <code>PlusButton</code> 的点击事件：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>用法如下：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController {
    BOOL isSelected = CYLExternPlusButton.selected;
    if (isSelected) {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is selected&quot;);
    } else {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is not selected&quot;);
    }
    return YES;
}

</code></pre>

<h4 id="toc_15">让TabBarItem仅显示图标，并使图标垂直居中</h4>

<p>要想实现该效果，只需要在设置 <code>tabBarItemsAttributes</code>该属性时不传 title 即可。</p>

<p>比如：在Demo的基础上，注释掉图中红框部分：<br/>
<img src="http://i64.tinypic.com/2cwu8ok.jpg" alt="enter image description here"/></p>

<table>
<thead>
<tr>
<th>注释前</th>
<th>注释后</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i66.tinypic.com/2z3rj0z.jpg" alt="enter image description here"/></td>
<td><img src="http://i65.tinypic.com/29cp1r9.jpg" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>可以通过这种方式来达到 Airbnb-app 的效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<p>如果想手动设置偏移量来达到该效果：<br/>
可以在 <code>-setViewControllers:</code> 方法前设置 <code>CYLTabBarController</code> 的 <code>imageInsets</code> 和 <code>titlePositionAdjustment</code> 属性</p>

<p>这里注意：设置这两个属性后，<code>TabBar</code> 中所有的 <code>TabBarItem</code> 都将被设置。并且第一种做法的逻辑将不会执行，也就是说该做法优先级要高于第一种做法。</p>

<p>做法如下：<br/>
<img src="http://i66.tinypic.com/4rq8ap.jpg" alt="enter image description here"/></p>

<p>但是想达到Airbnb-app的效果只有这个接口是不行的，还需要自定义下 <code>TabBar</code> 的高度，你需要设置 <code>CYLTabBarController</code> 的 <code>tabBarHeight</code> 属性。你可以在Demo的 <code>CYLTabBarControllerConfig.m</code> 中的 <code>-customizeTabBarAppearance:</code> 方法中设置。</p>

<p>注：“仅显示图标，并使图标垂直居中”这里所指的“图标”，其所属的类是私有类： <code>UITabBarSwappableImageView</code>，所以 <code>CYLTabBarController</code> 在相关的接口命名时会包含 <code>SwappableImageView</code> 字样。另外，使用该特性需要 <code>pod update</code> 到 1.5.5以上的版本。</p>

<h4 id="toc_16">多TabBar嵌套，并指定PlusButton位置</h4>

<p>该功能的版本需要 &gt;= v1.17.4。</p>

<p>效果图：</p>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fmn3005isfg308r0iltl6.gif" alt="enter image description here"/></p>

<p>实现 PlusButton 的如下协议方法指定 context：</p>

<pre><code class="language-Objective-C">//CYLPlusButtonSubclassing
+ (NSString *)tabBarContext;

</code></pre>

<p>当该值与 TabBarController 的 context 能够匹配上，PlusButton 将会展示。如果 PlusButton 与 TabBarController 均未制定 context 值，那么默认 context 值是相等的。</p>

<p>目前仅支持一个 PlusButton 展示一次，不限层级。如果与多个 TabBarController 的 context 能够匹配上，仅展示在最先一次的匹配上的 TabBarController 上。</p>

<h4 id="toc_17">在 Swift 项目中使用 CYLTabBarController</h4>

<p>仓库中给出了一个Swift Demo，文件夹叫做 Example-Swift。</p>

<p>具体的编写步骤参考热心网友提供的教程： <a href="http://www.jianshu.com/p/c5bc2eae0f55?nomobile=yes">《从头开始swift2.1 仿搜材通项目（三） 主流框架Tabbed的搭建》</a> </p>

<p>这里注意，文章的示例代码有问题，少了设置 PlusButton 大小的代码：<br/>
这将导致 PlusButton 点击事件失效，具体修改代码如下：<br/>
<img src="http://i67.tinypic.com/118ottv.jpg" alt="enter image description here"/></p>

<h4 id="toc_18">搭配 Storyboard 使用 CYLTabBarController</h4>

<p><a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor">这里</a> ，里面有个文件夹CYLTabBarControllerTestDemo，这个Demo演示了如何搭配 Storyboard 使用。</p>

<h4 id="toc_19">源码实现原理</h4>

<p>参考： <a href="http://www.jianshu.com/p/8758d8014f86">《[Note] CYLTabBarController》</a> </p>

<p>更多文档信息可查看 <a href="http://cocoadocs.org/docsets/CYLTabBarController/1.2.1/index.html"> <strong><em>CocoaDocs：CYLTabBarController</em></strong> </a> 。</p>

<h3 id="toc_20">FAQ</h3>

<p>更多Q-A内容，可以在这里查看： <a href="https://github.com/ChenYilong/CYLTabBarController/issues?utf8=%E2%9C%93&amp;q=+label%3AQ-A+">issue-FAQ</a> <br/>
Q：为什么放置6个TabBarItem会显示异常？</p>

<p>A：</p>

<p>Apple 规定：</p>

<blockquote>
<p>一个 <code>TabBar</code> 上只能出现最多5个 <code>TabBarItem</code> ，第六个及更多的将不被显示。</p>
</blockquote>

<p>另外注意，Apple检测的是 <code>UITabBarItem</code> 及其子类，所以放置“加号按钮”，这是 <code>UIButton</code> 不在“5个”里面。</p>

<p>最多只能添加5个 <code>TabBarItem</code> ，也就是说加上“加号按钮”，一共最多在一个 <code>TabBar</code> 上放置6个控件。否则第6个及之后出现 <code>TabBarItem</code> 会被自动屏蔽掉。而且就Apple的审核机制来说，超过5个也会被直接拒绝上架。</p>

<p>Q：我把 demo 两侧的 item 各去掉一个后，按钮的响应区域就变成下图的样子了：<br/>
 <img src="https://cloud.githubusercontent.com/assets/12152553/10725491/62600172-7c07-11e5-9e0a-0ec7d795d1e3.jpeg" alt="wechat_1445851872"/></p>

<p>A：v1.5.5 版本已经修复了该问题，现在不会出现类似的问题了：点击按钮区域却不响应，响应区域有偏移。</p>

<p>Q： 如何实现添加选中背景色的功能 ，像下面这样：<br/>
<img width="409" alt="screen shot 2015-10-28 at 9 21 56 am" src="https://cloud.githubusercontent.com/assets/7238866/10777333/5d7811c8-7d55-11e5-88be-8cb11bbeaf90.png"></p>

<p>A：我已经在 Demo 中添加了如何实现该功能的代码：<br/>
详情见 <code>CYLTabBarControllerConfig</code>  类中下面方法的实现：</p>

<pre><code class="language-Objective-C">/**
 *  更多TabBar自定义设置：比如：tabBarItem 的选中和不选中文字和背景图片属性、tabbar 背景图片属性
 */
- (void)customizeTabBarAppearance:(CYLTabBarController *)tabBarController;

</code></pre>

<p>效果如下：<br/>
<img src="https://cloud.githubusercontent.com/assets/2911921/10779397/34956b0a-7d6b-11e5-82d9-fa75aa34e8d0.png" alt="simulator screen shot 2015 10 28 11 44 32"/></p>

<p>Q: 当 <code>ViewController</code> 设置的 <code>self.title</code> 和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候，会出现如图的错误，排序不对了</p>

<p>A：在 v1.0.7 版本中已经修复了该 bug，但是也需要注意：</p>

<p>请勿使用 <code>self.title = @&quot;同城&quot;;</code> 这种方式，请使用 <code>self.navigationItem.title = @&quot;同城&quot;;</code> </p>

<p><code>self.title = @&quot;同城&quot;;</code> 这种方式，如果和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候可能会导致如下现象（不算 bug，但看起来也很奇怪）：</p>

<p><img src="http://i68.tinypic.com/282l3x4.jpg" alt="enter image description here"/></p>

<p>规则如下：</p>

<pre><code class="language-Objective-C">
    self.navigationItem.title = @&quot;同城&quot;;    //✅sets navigation bar title.The right way to set the title of the navigation
    self.tabBarItem.title = @&quot;同城23333&quot;;   //❌sets tab bar title. Even the `tabBarItem.title` changed, this will be ignored in  tabbar.
    self.title = @&quot;同城1&quot;;                  //❌sets both of these. Do not do this‼️‼️ This may cause something strange like this : http://i68.tinypic.com/282l3x4.jpg 

</code></pre>

<p>Q :  当使用这个方法时 <code>-[UIViewController cyl_popSelectTabBarChildViewControllerAtIndex:]</code> 系列方法时，会出现如下的黑边问题。</p>

<p><img src="http://i63.tinypic.com/bg766g.jpg" alt="enter image description here"/></p>

<p>A： 这个是 iOS 系统的BUG，经测试iOS9.3已经修复了，如果在更早起版本中出现了，可以通过下面将 <code>rootWindow</code> 的背景色改为白色来避免：比如你可以 <code>Appdelegate</code> 类里这样设置：</p>

<pre><code class="language-Objective-C">//#import &quot;CYLTabBarController.h&quot;
    [[self cyl_tabBarController] rootWindow].backgroundColor = [UIColor whiteColor];
</code></pre>

<p>Q:我现在已经做好了一个比较简单的中间凸起的 icon 但是超过了49这个高度的位置是不能效应的  我想请问你的demo哪个功能是可以使我超出的范围也可以响应的呢?</p>

<p>A: 这个是自动做的，但是 <code>CYLTabBarController</code> 只能保证的是：只要是 <code>UIButton</code> 的 frame 区域内就能响应。</p>

<p>请把 button 的背景颜色设置为显眼的颜色，比如红色，比如像下面的plus按钮，红色部分是能接收点击事件的，但是超出了红色按钮的，黄色的图片区域，依然是无法响应点击事件的。</p>

<p><img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>这是因为，在响应链上，<code>UIControl</code> 能响应点击事件， <code>UIImage</code> 无法响应。</p>

<p>Q：为什么在iOS10上会Crash，iOS9上不会？</p>

<p>A：<br/>
  在注册加号按钮时，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C"> + (void)load {
    [super registerPlusButton];
}
</code></pre>

<p>Q: 我的样式是点击 <code>plusButton</code> 后跳转到一个 <code>ViewController</code>，但是选中了一次中间的 <code>plusButton</code> 之后，再点别的 <code>tabItem</code> ，中间不会变成 <code>normal</code> 的状态。</p>

<p>A: 有两种情况会造成这个问题：</p>

<ol>
<li><p>应该是你的 <code>tabBar</code> 设置了 <code>delegate</code> 了，你要是 <code>tabBar</code> 的代理没设置的话，默认会有这个 <code>selected</code> 状态切换的处理。你设置代理后，会覆盖我的行为。所以手动加上就好了。</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
return YES;
}
</code></pre></li>
<li><p><code>plusButton</code> 添加了自定义点击事件或者自定义手势，因为这样会造成点击事件冲突或手势冲突，当需要 <code>pushViewController</code> 的时候，这个库会自动的添加点击事件，你这里重新加了点击事件所以冲突了；</p>

<p>在你项目的基础，把 <code>plusButton</code> 的点击事件取消掉,也就是 <code>addTarget</code> 这一行注释掉，手势事件也同理，应该就ok了</p></li>
</ol>

<p>A: <code>PlusButton</code> 与其他的 <code>TabBarItem</code> 距离没有平均分布 </p>

<p>(对应于 <a href="https://github.com/ChenYilong/CYLTabBarController/issues/36#issuecomment-269165471">issue#36</a> )</p>

<p>把这 Demo 里的这一行代码改下：</p>

<pre><code class="language-Objective-C">[button sizeToFit];
</code></pre>

<p>改成：</p>

<pre><code class="language-Objective-C">button.frame = CGRectMake(0.0, 0.0, w, h);
</code></pre>

<p>那么如果单是放一个照相机的图片，一般是多大的尺寸？</p>

<p>这个要看设计图，通常情况下，你可以写死与其他TabBarItem一样大小：</p>

<pre><code class="language-Objective-C"> [UIScreen mainScreen].bounds.size.width / [CYLTabBarController allItemsInTabBarCount]
</code></pre>

<hr/>

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 2 ->]]></title>
    <link href="www.freefook.com/15142759656625.html"/>
    <updated>2017-12-26T16:12:45+08:00</updated>
    <id>www.freefook.com/15142759656625.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 3 ->]]></title>
    <link href="www.freefook.com/15142759962160.html"/>
    <updated>2017-12-26T16:13:16+08:00</updated>
    <id>www.freefook.com/15142759962160.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 4 ->]]></title>
    <link href="www.freefook.com/15142759959034.html"/>
    <updated>2017-12-26T16:13:15+08:00</updated>
    <id>www.freefook.com/15142759959034.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 5 ->]]></title>
    <link href="www.freefook.com/15142759955738.html"/>
    <updated>2017-12-26T16:13:15+08:00</updated>
    <id>www.freefook.com/15142759955738.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
</feed>
