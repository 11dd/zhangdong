<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[随心所欲之张东东篇]]></title>
  <link href="www.freefook.com/atom.xml" rel="self"/>
  <link href="www.freefook.com/"/>
  <updated>2018-04-20T15:58:07+08:00</updated>
  <id>www.freefook.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[小程序]]></title>
    <link href="www.freefook.com/15232437563217.html"/>
    <updated>2018-04-09T11:15:56+08:00</updated>
    <id>www.freefook.com/15232437563217.html</id>
    <content type="html"><![CDATA[
<p>介绍：<br/>
<a href="https://developers.weixin.qq.com/miniprogram/dev/index.html">https://developers.weixin.qq.com/miniprogram/dev/index.html</a></p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.31.04.png" alt="屏幕快照 2018-04-09 上午11.31.04"/></p>

<ol>
<li>打开公众平台 <a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></li>
<li>使用未绑定微信其他产品的邮箱注册</li>
<li>登录成功</li>
<li>查看小程序平台</li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.19.02.png" alt="屏幕快照 2018-04-09 上午11.19.02"/></p>

<ol>
<li>微信开发者工具首次打开需要AppID<br/>
官方工具：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.21.41.png" alt="屏幕快照 2018-04-09 上午11.21.41"/></p>

<ol>
<li>小程序开发必读项，教程 ，框架 ，组件 ，API , 工具<br/>
简易教程：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.23.50.png" alt="屏幕快照 2018-04-09 上午11.23.50"/></p>

<ol>
<li>当开始要做一个小程序时，需通读设计指南<br/>
设计指南：<a href="https://mp.weixin.qq.com/debug/wxadoc/design/index.html">https://mp.weixin.qq.com/debug/wxadoc/design/index.html</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.28.55.png" alt="屏幕快照 2018-04-09 上午11.28.55"/></p>

<ul>
<li>运营规范(在这里查看禁止事项)：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/index.html">https://mp.weixin.qq.com/debug/wxadoc/product/index.html</a></li>
<li>特殊行业所需资质材料：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714</a></li>
<li>支付文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1">https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1</a></li>
<li>客服消息：<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221">https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221</a> </li>
<li>数据分析：<a href="https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714</a></li>
</ul>

<p>疑难问题，请浏览👇<br/>
小程序社区：<a href="http://www.wxapp-union.com/">http://www.wxapp-union.com/</a></p>

<p>使用WePY框架开发小程序请移步👇<br/>
<a href="https://tencent.github.io/wepy/index.html">https://tencent.github.io/wepy/index.html</a></p>

<p>小程序企业认证3到5个工作日</p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-18%20%E4%B8%8A%E5%8D%8810.31.37.png" alt="屏幕快照 2018-04-18 上午10.31.37"/></p>

<p>企业小程序 侧边栏多了微信支付 支付设置 与小程序插件<br/>
<img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%881.54.00.png" alt="屏幕快照 2018-04-19 下午1.54.00"/></p>

<p>个人账号下截图：<br/>
<img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%881.54.43.png" alt="屏幕快照 2018-04-19 下午1.54.43"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CMMI3级评审]]></title>
    <link href="www.freefook.com/15238614357604.html"/>
    <updated>2018-04-16T14:50:35+08:00</updated>
    <id>www.freefook.com/15238614357604.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">十八个过程域</h3>

<h5 id="toc_1">过程管理</h5>

<h6 id="toc_2">组织过程改进（OPF）Organization Process Focus</h6>

<h6 id="toc_3">组织过程定义（OPD）Organization Process Definition</h6>

<h6 id="toc_4">组织培训（OT）Organization Training</h6>

<h5 id="toc_5">项目管理</h5>

<h6 id="toc_6">立项（PIM）</h6>

<h6 id="toc_7">集成项目管理（IPM）</h6>

<h6 id="toc_8">项目策划（PP）</h6>

<h6 id="toc_9">项目监督和控制（PMC）</h6>

<h6 id="toc_10">风险管理（RSKM）</h6>

<h6 id="toc_11">结项（PCM）</h6>

<h5 id="toc_12">项目研发</h5>

<h6 id="toc_13">需求开发与管理（RD）</h6>

<h6 id="toc_14">系统设计编码（SD）</h6>

<h6 id="toc_15">测试（TS）</h6>

<h6 id="toc_16">评审（TR）</h6>

<h6 id="toc_17">产品发布（PI）</h6>

<h6 id="toc_18">产品实施（PA）</h6>

<h5 id="toc_19">过程支持</h5>

<h6 id="toc_20">配置管理（CM）</h6>

<h6 id="toc_21">过程和产品质量保证（PPQA）</h6>

<h6 id="toc_22">度量与分析（MA）</h6>

<h6 id="toc_23">决策分析和决定（DAR）</h6>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序登录]]></title>
    <link href="www.freefook.com/15234367737951.html"/>
    <updated>2018-04-11T16:52:53+08:00</updated>
    <id>www.freefook.com/15234367737951.html</id>
    <content type="html"><![CDATA[
<ol>
<li>授权获取用户信息</li>
<li>得到code,iv,encryptedData,rawData,signature将code，iv，encryptedData传给服务器</li>
<li>服务器post请求接口<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></li>
</ol>

<pre><code>https://api.weixin.qq.com/sns/jscode2session  
参数{
    appid，
    secret，
    js_code = code，
    grant_type = authorization_code
} 
返回数据{
    session_key，
    openid
}

会话密钥session_key有效性

开发者如果遇到因为session_key不正确而校验签名失败或解密失败，请关注下面几个与session_key有关的注意事项。

    1.wx.login()调用时，用户的session_key会被更新而致使旧session_key失效。
    开发者应该在明确需要重新登录时才调用wx.login()，
    及时通过登录凭证校验接口更新服务器存储的session_key。

    2.微信不会把session_key的有效期告知开发者。
    我们会根据用户使用小程序的行为对session_key进行续期。
    用户越频繁使用小程序，session_key有效期越长。

    3.开发者在session_key失效时，可以通过重新执行登录流程获取有效的session_key。
    使用接口wx.checkSession()可以校验session_key是否有效，
    从而避免小程序反复执行登录流程。

    4.当开发者在实现自定义登录态时，
    可以考虑以session_key有效期作为自身登录态有效期，
    也可以实现自定义的时效性策略。


</code></pre>

<ol>
<li>服务端解密数据encryptedData</li>
</ol>

<pre><code>    对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
    对称解密的目标密文为 Base64_Decode(encryptedData)。
    对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
    对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。
    
解密encryptedData数据
{
　　&quot;openId&quot;:&quot;&quot;,
　　&quot;nickName&quot;:&quot;ZIM東&quot;,
　　&quot;gender&quot;:1,
　　&quot;language&quot;:&quot;zh_CN&quot;,
　　&quot;city&quot;:&quot;&quot;,
　　&quot;province&quot;:&quot;&quot;,
　　&quot;country&quot;:&quot;&quot;,
　　&quot;avatarUrl&quot;:&quot;&quot;,
　　&quot;unionId&quot;:&quot;&quot;,
　　&quot;watermark&quot;:{
　　　　&quot;timestamp&quot;:1523433831,
　　　　&quot;appid&quot;:&quot;&quot;
　　}
}

在登录小程序之前，既没有关注过公众号，也没有登录过公众号，
更没有使用微信登录的方式登录过app。
通过 wx.login 的到的 code 解密后未返回 unionid

划重点：
     初次尝试小程序登录未拿到unionid
     小程序里关联了公众号，用微信关注了公众号未获取到unionid
     小程序关联微信开放平台，再次登录得到了unionid

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )
appid 敏感数据归属appid，开发者可校验此参数与自身appid是否一致
timestamp 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

</code></pre>

<p><img src="media/15234367737951/%E6%B5%81%E7%A8%8B.png" alt="流程"/></p>

<p>👆原图地址：<a href="https://blog.csdn.net/dingjianmin/article/details/75137934">https://blog.csdn.net/dingjianmin/article/details/75137934</a></p>

<p>注意：开发者后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。 </p>

<p><img src="media/15234367737951/%E6%95%B0%E6%8D%AE.png" alt="数据"/></p>

<pre><code>签名校验以及数据加解密涉及用户的会话密钥session_key。 开发者应该事先通过 wx.login 登录流程获取会话密钥 session_key 并保存在服务器。为了数据不被篡改，开发者不应该把session_key传到小程序客户端等服务器外的环境。

数据签名校验

为了确保 开放接口 返回用户数据的安全性，微信会对明文数据进行签名。
开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。

    通过调用接口（如 wx.getUserInfo）获取数据时，接口会同时返回 rawData、signature，
    其中 signature = sha1( rawData + session_key )
    
    开发者将 signature、rawData 发送到开发者服务器进行校验。
    服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，
    比对 signature 与 signature2 即可校验数据的完整性。

</code></pre>

<p>官方数据签名校验<br/>
<a href="https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject">https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序View的布局]]></title>
    <link href="www.freefook.com/15242100404510.html"/>
    <updated>2018-04-20T15:40:40+08:00</updated>
    <id>www.freefook.com/15242100404510.html</id>
    <content type="html"><![CDATA[
<pre><code>小程序 View 支持两种布局方式：Block 和 Flex
所有 View 默认都是 block
要使用 flex 布局的话需要显式的声明：

display:flex;
</code></pre>

<h5 id="toc_0">在wxml文件里写如下代码：</h5>

<pre><code> &lt;view class=&quot;main&quot;&gt;
    &lt;view class=&quot;item item1&quot;&gt;1&lt;/view&gt;
    &lt;view class=&quot;item item2&quot;&gt;2&lt;/view&gt;
    &lt;view class=&quot;item item3&quot;&gt;3&lt;/view&gt;
  &lt;/view&gt;
</code></pre>

<h5 id="toc_1">在wxss文件里写如下代码：</h5>

<pre><code>.main {
  width: 100%;
  background-color: antiquewhite;
}
.item {
  height: 100rpx;
  width: 100rpx;
}
.item1 {
  background-color: red;
}
.item2 {
  background-color: dodgerblue;
}
.item3 {
  background-color: greenyellow;
}
</code></pre>

<h5 id="toc_2">运行效果如下：</h5>

<p><img src="media/15242100404510/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%883.44.35.png" alt="屏幕快照 2018-04-20 下午3.44.35"/></p>

<h5 id="toc_3">接下来便可以在.main里尝试如下属性：</h5>

<pre><code>//使用 flex 布局
display: flex;
//横向布局or竖向布局=&gt;设置属性 flex-direction
flex-direction: row;
{
row：从左到右的水平方向为主轴
row-reverse：从右到左的水平方向为主轴
column：从上到下的垂直方向为主轴
column-reverse：从下到上的垂直方向为主轴
}
//设置元素在横向上的布局方向，需要设置 justify-content 属性
justify-content: space-around;
{
flex-start：主轴起点对齐(默认值)  
flex-end：主轴结束点对齐  
center：在主轴中居中对齐  
space-between：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等  
space-around：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同  
}
//设置元素在纵向上的布局方向，需要设置 align-items 属性
align-items: center;
{
stretch 填充整个容器(默认值)
flex-start 侧轴的起点对齐
flex-end 侧轴的终点对齐
center 在侧轴中居中对齐
baseline 以子元素的第一行文字对齐
}
//用于控制子 View 是否换行=&gt;设置flex-wrap 属性，
flex-wrap: wrap;
{
nowrap：不换行（默认）
wrap：换行
wrap-reverse：换行，第一行在最下面
}

</code></pre>

<p>转载：<a href="https://blog.csdn.net/weixin_36065510/article/details/73203720">https://blog.csdn.net/weixin_36065510/article/details/73203720</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序TabBar]]></title>
    <link href="www.freefook.com/15235114845539.html"/>
    <updated>2018-04-12T13:38:04+08:00</updated>
    <id>www.freefook.com/15235114845539.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">创建一个标准小程序空项目</h4>

<h5 id="toc_1">在app.json文件里写入如下代码</h5>

<pre><code> &quot;tabBar&quot;: {
    &quot;color&quot;: &quot;#a9b7b7&quot;,
    &quot;selectedColor&quot;: &quot;#000000&quot;,
    &quot;borderStyle&quot;: &quot;black&quot;,
    &quot;list&quot;: [
      {
        &quot;selectedIconPath&quot;: &quot;image/home.png&quot;,
        &quot;iconPath&quot;: &quot;image/home.png&quot;,
        &quot;pagePath&quot;: &quot;pages/home/home&quot;,
        &quot;text&quot;: &quot;首页&quot;
      },
      {
        &quot;selectedIconPath&quot;: &quot;image/index.png&quot;,
        &quot;iconPath&quot;: &quot;image/index.png&quot;,
        &quot;pagePath&quot;: &quot;pages/index/index&quot;,
        &quot;text&quot;: &quot;专题&quot;
      }
    ]
  }
   
</code></pre>

<h4 id="toc_2">运行界面 tabbar</h4>

<p><img src="media/15235114845539/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%881.41.36.png" alt="屏幕快照 2018-04-12 下午1.41.36"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序轮播]]></title>
    <link href="www.freefook.com/15235125175960.html"/>
    <updated>2018-04-12T13:55:17+08:00</updated>
    <id>www.freefook.com/15235125175960.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">第一步：在.wxml文件里写入如下代码</h4>

<pre><code>&lt;swiper indicator-dots=&quot;{{indicatorDots}}&quot;  
        autoplay=&quot;{{autoplay}}&quot; 
        interval=&quot;{{interval}}&quot; 
        duration=&quot;{{duration}}&quot; 
        circular=&quot;true&quot;&gt;  

      &lt;block wx:for=&quot;{{imgUrls}}&quot; wx:for-index=&quot;index&quot;&gt;  
        &lt;swiper-item&gt;  
            &lt;navigator url=&quot;{{item.link}}&quot; hover-class=&quot;navigator-hover&quot;&gt; 
            &lt;image src=&quot;{{item.url}}&quot; 
                   class=&quot;slide-image&quot;/&gt;  
            &lt;/navigator&gt;  
        &lt;/swiper-item&gt;  
      &lt;/block&gt;  

&lt;/swiper&gt; 

</code></pre>

<h4 id="toc_1">第二步：在.wxss文件里设置如下属性</h4>

<pre><code>   swiper{
    height: 220px;
   } 

    .slide-image{  
        width: 100%;  
        height: 180px;
    }  
</code></pre>

<h4 id="toc_2">第三步：在.js文件里设置如下数据 和轮播属性设置</h4>

<pre><code> imgUrls: [
      {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&#39;
      }, {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&#39;
      }, {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&#39;
      }   

    ],
    indicatorDots: true,
    autoplay: true,
    
    interval: 3000,
    duration: 500,

</code></pre>

<h4 id="toc_3">运行界面如下：</h4>

<p><img src="media/15235125175960/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%882.07.56.png" alt="屏幕快照 2018-04-12 下午2.07.56"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序列表list]]></title>
    <link href="www.freefook.com/15235133751593.html"/>
    <updated>2018-04-12T14:09:35+08:00</updated>
    <id>www.freefook.com/15235133751593.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">在创建的home.wxml文件里写入如下布局</h5>

<pre><code>&lt;view&gt;  
  &lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height:100%&quot; &gt;  
    &lt;view wx:for=&quot;{{array}}&quot; style=&quot;width:100%&quot;&gt;  
    &lt;image id =&quot;{{index}}&quot; 
           src =&quot;{{item}}&quot; 
           mode =&quot;aspectFill&quot; 
           style =&quot;width:100%;height:150px&quot;      
           bindtap =&quot;tapName&quot; 
           data-img =&quot;{{item}}&quot;&gt;&lt;/image&gt; 
    &lt;/view&gt;  
  &lt;/scroll-view&gt;  
&lt;/view&gt; 
</code></pre>

<h5 id="toc_1">在home.js 文件里放入数据</h5>

<pre><code>/**
   * 页面的初始数据
   */
  data: {
    array: [
    &quot;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&quot;,
    &quot;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&quot;,
    &quot;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&quot;
    ]  
  },

  //列表上图片点击方法，跳转详情页面
  tapName: function (event) {
    console.log(event.target.dataset.img)
    wx.navigateTo({
      url: &#39;../detail/detail&#39;
    })
  },
  
  
/**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {

    console.log(&quot;打印参数，上个页面传过来的参数id---&gt;&quot;)
    console.log(options.id)  

  },
  
</code></pre>

<h5 id="toc_2">在home.json文件里写上navigationBarTitleText</h5>

<pre><code>{
  &quot;navigationBarTitleText&quot;: &quot;知之为知之&quot;
}
</code></pre>

<h4 id="toc_3">运行界面 列表 list</h4>

<p><img src="media/15235114845539/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%881.50.12.png" alt="屏幕快照 2018-04-12 下午1.50.12"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序网格布局]]></title>
    <link href="www.freefook.com/15236096586360.html"/>
    <updated>2018-04-13T16:54:18+08:00</updated>
    <id>www.freefook.com/15236096586360.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">第一步：wxml文件代码：</h4>

<pre><code>&lt;view class=&quot;layout_horizontal&quot;&gt;
  &lt;view style=&quot;flex:1;background-color:red&quot;&gt;View1&lt;/view&gt;
  &lt;view style=&quot;flex:1;background-color:blue&quot;&gt;View2&lt;/view&gt;
&lt;/view&gt;
</code></pre>

<h4 id="toc_1">第二步：wxss文件代码：</h4>

<pre><code>.layout_horizontal{
  height: 100rpx;
  display: flex;
  /*row 横向  column 列表  */
  flex-direction: row;
}
</code></pre>

<h4 id="toc_2">运行界面：</h4>

<p><img src="media/15236096586360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%884.57.13.png" alt="屏幕快照 2018-04-13 下午4.57.13"/></p>

<h3 id="toc_3">网格布局</h3>

<h5 id="toc_4">在wxml里加入如下代码：</h5>

<pre><code>
&lt;view class=&#39;content&#39;&gt;
    &lt;block wx:for=&quot;{{new_products}}&quot; wx:for-item=&quot;item&quot;&gt;
      &lt;view class=&#39;templateContainer&#39; catchtap=&#39;onGoodsTap&#39; data-goodsid=&#39;{{item.id}}&#39;&gt;
        &lt;view class=&#39;goods-container&#39;&gt;
          &lt;image mode=&#39;aspectFill&#39; class=&#39;goods-img&#39; src=&#39;{{item.images.large}}&#39;&gt;&lt;/image&gt;
          &lt;text class=&#39;goods-title&#39;&gt;{{item.title}}&lt;/text&gt;
          &lt;view class=&#39;price&#39;&gt;
            &lt;text class=&#39;goods-price&#39;&gt;￥{{item.rating.average}}&lt;/text&gt;
            &lt;text class=&#39;pre-goods-price&#39;&gt;￥{{item.rating.max}}&lt;/text&gt;
          &lt;/view&gt; 
        &lt;/view&gt;
      &lt;/view&gt;
    &lt;/block&gt;
  &lt;/view&gt;

</code></pre>

<h5 id="toc_5">在wxss里加入如下代码：</h5>

<pre><code>
.content {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  width: auto;
  background-color: #f2f2f2;
}


.templateContainer {
  width: 47%;
  background-color: white;
  margin: 10rpx;
}


.goods-container {
  display: flex;
  flex-direction: column;
  margin-top: 30rpx;
  text-align: center;
}

.goods-img {
  width: 310rpx;
  height: 310rpx;
  padding-bottom: 20rpx;
  margin: 0 auto;
}

.goods-title{
    margin-bottom: 16rpx;
    font-size: 24rpx;
}

.price{
  display: flex;
  flex-direction: row;
  margin: 0 auto;
}

.goods-price{
    margin-bottom: 16rpx;
    font-size: 24rpx;
    color: red;
}

.pre-goods-price{
  text-decoration: line-through;
  margin-left: 10rpx;
}

</code></pre>

<h5 id="toc_6">在.js里加入如下代码：</h5>

<pre><code>
/**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
  
    var that = this;
    wx.request({
      url: &#39;http://t.yushu.im/v2/movie/in_theaters?start=0&amp;count=4&#39;,
      method: &#39;GET&#39;,
      header: {
        &quot;Content-Type&quot;: &quot;json&quot;
      },
      success: function (res) {
        that.setData({
          new_products: res.data.subjects,
        })
        console.log(&quot;这里打印点数据出来呗！！！&quot;);
        console.log(res.data.subjects);
      },
      fail: function (error) {
        console.log(error)
      }
    })
    
  },

</code></pre>

<h5 id="toc_7">运行效果</h5>

<p><img src="media/15236096586360/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8B%E5%8D%883.12.29.png" alt="屏幕快照 2018-04-17 下午3.12.29"/></p>

<p>请求地址：来源项目 <a href="https://github.com/YhAllen/WeChat-applet-mall">https://github.com/YhAllen/WeChat-applet-mall</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序网络请求]]></title>
    <link href="www.freefook.com/15235164843984.html"/>
    <updated>2018-04-12T15:01:24+08:00</updated>
    <id>www.freefook.com/15235164843984.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1.在wxml文件里加上按钮点击事件 和list</h4>

<pre><code>&lt;button bindtap=&quot;RequestData&quot; value=&quot;Button&quot;&gt;request&lt;/button&gt; 

&lt;view&gt;  
  &lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height:100%&quot; &gt;  
    &lt;view wx:for=&quot;{{textdata}}&quot; style=&quot;width:100%&quot;&gt;  
      &lt;label style=&quot;width:100%;height:50px;font-family:&#39;微软雅黑&#39;&quot;&gt;  {{item.name}}&lt;/label&gt;  
    &lt;/view&gt;  
  &lt;/scroll-view&gt;  
&lt;/view&gt;   

</code></pre>

<h4 id="toc_1">2.在.js 文件添加网络请求，点击按钮后执行代码如下：</h4>

<pre><code> RequestData: function () {
    var that = this;
    wx.request({
      url: &#39;http://.../serve/api/v1.0/service/communityLst&#39;,

      data: {},
      method: &#39;GET&#39;, 
      // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT 
      // header: {}, // 设置请求的 header 默认是application/json  

      success: function (res) {  
        //划重点---&gt;setData 
        that.setData({ textdata: res.data.query});
        
        // 操作json数据 遍历打印数组里name字段数据  
        for (var i in res.data.query) {
          console.log(res.data.query[i].name);
        }
      },
      fail: function () {
        // fail  
      },
      complete: function () {
        // complete  
      }
    })
  },  
</code></pre>

<h4 id="toc_2">3.setData 后页面如下：</h4>

<p><img src="media/15235164843984/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%882.26.02.png" alt="屏幕快照 2018-04-12 下午2.26.02"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARKit 看我就受够了]]></title>
    <link href="www.freefook.com/15139220095625.html"/>
    <updated>2017-12-22T13:53:29+08:00</updated>
    <id>www.freefook.com/15139220095625.html</id>
    <content type="html"><![CDATA[
<p>因为有项目需求ARKit，查询后反馈的文档<br/>
现发布出来，还没注明转载出自哪里，见谅，找到地址时补齐；</p>

<p><a href="https://developer.apple.com/documentation/arkit">https://developer.apple.com/documentation/arkit</a><br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-3bdc5004b7ecbc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>截图</p>

<h3 id="toc_0">AR增强现实技术</h3>

<p>在即将发布的iOS11系统上，ARKit正式成为iOS系统框架，让开发者能够使用OC或swift语言开发AR类型的APP。<br/>
ARKit的大部分计算都是在CPU上处理的，在A8处理器上的性能损耗在15%~ 25%,<br/>
在A9处理器上的性能损耗在10% ~ 15%。为了更好的体验，所以苹果仅支持 A9 及以上处理器<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-2eaafcbc013d5c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>AR支持系列</p>

<h4 id="toc_1">ARKit 实现测量尺功能：</h4>

<p>实现该功能原理:收集相机的视觉信息，以及手机中传感器，包括陀螺仪、罗盘和加速度计来计算并确定设备的位置。<br/>
当然，这都是基于ARKit开发的，不想深入，想深入，深入，入...</p>

<blockquote>
<p>•多媒体捕捉现实图像:如摄像头<br/>
•三维建模:3D立体模型<br/>
•传感器追踪:主要追踪现实世界动态物体的六轴变化，这六轴分别是X、Y、Z轴位移及旋转。其中位移三轴决定物体的方位和大小，旋转三轴决定物体显示的区域。<br/>
•坐标识别及转换:3D模型显示在现实图像中不是单纯的坐标点，而是一个三维的矩阵坐标</p>
</blockquote>

<h4 id="toc_2">注意:</h4>

<ol>
<li><p>如果手机中的场景越丰富，那么测量的结果也就越精确。如果想要测量一面白墙的长度，暂时还不是很准确。AR应用是通过“特征点”进行识别的,也因为是三维矩阵坐标，要求测量时必须很稳的在同一个 Z 轴高度上测量平面的长度;</p></li>
<li><p>不要期望 AR检测的平面会完全贴合表面，虽然检测到了平面但角度可能不完全正确，所以如果开发的AR app需要获得非常精确的几何体来提供更好的效果，可能会出现问题</p></li>
<li><p>边缘检测不是特别好，实际的平面范围有时会太大或太小，所以不要尝试做需要准确边缘的 ARapp</p></li>
</ol>

<h4 id="toc_3">ARKit还存在一些问题:</h4>

<blockquote>
<p>ARKit是基于惯性-视觉来做空间定位的，这项技术会将iOS设备的动作感测硬件信息，加上对可见场景的计算机视觉分析功能，然后与设备的摄像头相结合，需要平稳缓慢的移动+转向手机，才能构建更加准确的世界，这对用户来说是一种考验，需要积极提示。</p>

<p>一旦刚开始检测平面失败，出现时间久，飘逸的现象，后期很难再正确检测，要强制重启。</p>

<p>AVFoudation与ARSession之间的切换会有轻微的卡顿，切换后ARSession就停止摄像头采集了，但3D渲染会继续，只是丧失了空间定位与检测识别的能力.</p>

<p>不支持前置摄像头。ARKit并不是一个用于前置摄像头环境的技术，因为空间有限，能提供的信息也非常有限。100米左右是ARKit在保持较好用户体验的最大测量距离。</p>

<p>ARKit没有计划支持连接两个不同ARKit世界。</p>
</blockquote>

<h4 id="toc_4">要建立高品质的 AR 体验，那么请注意下述这些注意事项和提示:</h4>

<blockquote>
<p>全局追踪是一项不精确的科学 (inexact science)。<br/>
尽管在这个过程当中，经常会产生可观的准确度，从而让AR 的体验更加真实。然而，它严重依赖于设备物理环境的相关细节，而这些细节并不总是一致，有些时候也难以实时测量，这也就导致这些物理细节往往都会存在某种程度的错误。</p>

<p>基于可见的照明条件来设计AR场景。<br/>
全局追踪涉及到了图像分析的相关内容，因此就需要我们提供清晰的图像。如果摄像头没有办法看到相关的物理细节，比如说摄像头拍到的是一面空空如也的墙壁，或者场景的光线实在太暗的话，那么全局追踪的质量就会大大降低。</p>

<p>根据追踪质量的相关信息来给用户进行反馈提示。<br/>
全局追踪会将图像分析与设备的动作模式关联起来。如果设备正在移动的话，那么ARKit 就可以更好地对场景进行建模，这样即便设备只是略微晃动，也不会影响追踪质量。但是一旦用户的动作过多、过快或者晃动过于激烈，就会导致图像变得模糊，或者导致视频帧中要追踪的特征之间的距离过大，从而致使追踪质量的降低。ARCamera类能够提供追踪状态，此外还能提供导致该状态出现的相关原因，您可以在 UI 上展示这些信息，告诉用户如何解决追踪质量低这个问题。</p>

<p>给水平面检测预留点时间来生成清晰的结果，一旦您获得所需的结果后，就禁用水平面检测。一开始对水平面进行检测的时候，所检测到的水平面位置和范围很可能不准确。不过随着时间的推移，只要水平面仍然保持在场景当中，<br/>
那么 ARKit 就能够较为精确地估计水平面的位置和范围。当场景中有一个比较大的平坦表面的话，就算您已经使用过这个水平面来放置内容，那么 ARKit 可能还会继续对水平面的锚点位置、范围和变换点进行修正 。</p>
</blockquote>

<p>综上所述:ARKit 实现测量尺功能，对物理环境要求较高，<br/>
第一，环境光检测，清晰的获取摄像头的帧图像;<br/>
第二，平面检测，准确的获取水平面，如果精确测量，需要边缘化检测准确;<br/>
第三，运动追踪稳定准确等外部因素，对环境和用户操作要求较高;</p>

<h4 id="toc_5">后记补充：</h4>

<p>ARKit是有环境光估计的，这个功能会通过摄像头捕捉并计算捕捉到的场景中的光的总量，来给虚拟物体施加正确的光照条件，渲染效果更加真实。环境光的模拟对于AR出来的画面的真实感，还是有非常大的影响的。</p>

<h5 id="toc_6">在此说一下ARKit没有提供图像识别方面的功能，所以平时可能看到身边有的AR场景是可以识别特定的图像做其他操作类型的App，用ARKit是不能实现的；</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 字符串操作方法说明]]></title>
    <link href="www.freefook.com/15139214218497.html"/>
    <updated>2017-12-22T13:43:41+08:00</updated>
    <id>www.freefook.com/15139214218497.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">属性字符串常用操作</h5>

<pre><code>- (NSMutableAttributedString *)stringToAttributedString:(NSString*)tempStr NSMakeRange:(int)num
{
    NSMutableAttributedString *attrString = [[NSMutableAttributedString alloc] initWithString:tempStr];
    //颜色
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(num,tempStr.length-num)];
    //字体
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(14)] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(16)] range:NSMakeRange(num,tempStr.length-num)];  
    return attrString;
}
</code></pre>

<h5 id="toc_1">将字符串分隔成数组</h5>

<pre><code>    NSString* str = @&quot;one,two,three,four,five&quot;;
    //分割字符创为数组，下例以“，”分割
    NSArray* array = [str componentsSeparatedByString:@&quot;,&quot;];
    for(NSString* obj in array)
    {
        NSLog(@&quot;%@&quot;, obj);
    }

    //链接字符串,下例以空格连接
    str = [array componentsJoinedByString:@&quot; &quot;];
    NSLog(@&quot;%@&quot;, str);
</code></pre>

<h5 id="toc_2">判断字符串是否包含另一个字符串</h5>

<pre><code>//判断”abcd” 是否含有@&quot;ab&quot;
 NSString *tempStr = @&quot;abcd&quot;;
    if([tempStr rangeOfString:@&quot;ab&quot;].location !=NSNotFound){
        NSLog(@&quot;yes&quot;);
    }else {
        NSLog(@&quot;no&quot;);
    }
</code></pre>

<h5 id="toc_3">字符串去掉特殊符号或改成去除数字/字母的笨方法</h5>

<pre><code>NSString * string111 = @&quot;1234、[]{}#%-*+=_\\|~＜&quot;;
NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;@／：；（）¥「」＂、[]{}#%-*+=_\\|~＜＞$€^•&#39;@#$%^&amp;*()_+&#39;\&quot;&quot;];
NSString *string222 = [string111 stringByTrimmingCharactersInSet:set];
</code></pre>

<h5 id="toc_4">从字符串的开头一直截取到指定的位置，但不包括该位置的字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringToIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_5">以指定位置开始（包括指定位置的字符），并包括之后的全部字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringFromIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_6">按照所给出的位置，长度（截取几位而不是到哪），任意地从字符串中截取子串</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringWithRange:NSMakeRange(0, 4)];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_7">替换字符串中字符,该方法做了copy操作，原字符串没变，需要重新赋值给原字符串</h5>

<pre><code>    NSString* tempstr4 = [tempstr3 stringByReplacingOccurrencesOfString:@&quot;:&quot; withString:@&quot;&quot;];
    NSString* tempstr5 = [tempstr4 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];
    NSString* tempstr6 = [tempstr5 stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;&quot;];
</code></pre>

<h5 id="toc_8">字符串大小写</h5>

<pre><code>//   将字符串中的英文字符由小写转换为大写
    NSString *bigString = [string uppercaseString];
    NSLog(@&quot;string = %@, bigstring = %@&quot;, string, bigString); 
       
//   将字符串中的英文字符由大写转换为小写
    NSString *smallString = [string lowercaseString];
    NSLog(@&quot;string = %@, smallString = %@&quot;, string, smallString);
    
//  将字符串的首字母改为大写
    NSString *firstBigString = [string capitalizedString];
    NSLog(@&quot;%@&quot;, firstBigString);
</code></pre>

<h5 id="toc_9">字符串拼接</h5>

<pre><code>//  字符串拼接:将两个字符串拼在一起后形成一个新的字符串,原来两个字符串并未发生改变
    NSString *string1 = @&quot;abc&quot;;
    NSString *string2 = @&quot;123&quot;;
    NSString *addString = [string1 stringByAppendingString:string2];
    NSLog(@&quot;%@&quot;, addString);
</code></pre>

<h4 id="toc_10">字符串查找</h4>

<pre><code>    NSString * string = @&quot;1234&quot;;
    //  字符串查找：判断是否以参数给定的字符串开头。是，返回真 1 ；否，返回假 0。
    BOOL result1 = [string hasPrefix:@&quot;1&quot;];
    NSLog(@&quot;%d&quot;, result1);
    
    //  字符串查找：判断是否以参数给定的字符串结尾。是，返回真 1 ；否，返回假 0。
    BOOL result2 = [string hasSuffix:@&quot;4&quot;];
    NSLog(@&quot;%d&quot;, result2);
</code></pre>

<h4 id="toc_11">反转字符串</h4>

<pre><code>/**
 *  @brief  反转字符串
 *
 *  @param strSrc 被反转字符串
 *
 *  @return 反转后字符串
 */
+ (NSString *)jk_reverseString:(NSString *)strSrc
{
    NSMutableString* reverseString = [[NSMutableString alloc] init];
    NSInteger charIndex = [strSrc length];
    while (charIndex &gt; 0) {
        charIndex --;
        NSRange subStrRange = NSMakeRange(charIndex, 1);
        [reverseString appendString:[strSrc substringWithRange:subStrRange]];
    }
    return reverseString;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 数组操作方法说明]]></title>
    <link href="www.freefook.com/15139214500331.html"/>
    <updated>2017-12-22T13:44:10+08:00</updated>
    <id>www.freefook.com/15139214500331.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">获取数组的正序迭代器</h5>

<pre><code>    NSEnumerator *enu1 = [tempArr objectEnumerator];
</code></pre>

<h5 id="toc_1">获取数组的反序迭代器</h5>

<pre><code>    NSEnumerator *enu2 = [tempArr reverseObjectEnumerator];
    //数组倒序输出
    dataArray=(NSMutableArray *)[[dataArray reverseObjectEnumerator] allObjects];
</code></pre>

<h5 id="toc_2">数组排序</h5>

<pre><code>    // 返回一个排好序的数组，原来数组的元素顺序不会改变
    // 指定元素的比较方法：compare:
    NSArray *array1 = [NSArray arrayWithObjects:@&quot;2&quot;, @&quot;3&quot;, @&quot;1&quot;, @&quot;4&quot;, nil];
    NSArray *array2 = [array1 sortedArrayUsingSelector:@selector(compare:)];
    NSLog(@&quot;array2:%@&quot;, array2);(1,2,3,4)
</code></pre>

<h5 id="toc_3">选择排序-iOS常用模式tempLogArr数组里每一元素是字典，根据字典里的dic[Index]排序</h5>

<pre><code>    for (int i=0; i&lt;tempLogArr.count; i++) {
        
        for (int j=i+1; j&lt;tempLogArr.count; j++) {
            
            if ([tempLogArr[i][@&quot;Index&quot;] intValue] &lt; [tempLogArr[j][@&quot;Index&quot;] intValue]) {
                
                [tempLogArr exchangeObjectAtIndex:i withObjectAtIndex:j];
            }
        }
    }
</code></pre>

<h5 id="toc_4">数组tempLogArr元素是字典“遍历所有”去掉重复信息用（ i--）方式，避免数组越界</h5>

<pre><code>    int x;
    int y;
    for (int i = (int)tempLogArr.count - 1; i &gt;=0 ; i--) {
        NSString * tempStr = [NSString stringWithFormat:@&quot;%@&quot;,tempLogArr[i][@&quot;Index&quot;]];
        x = [tempStr intValue];
        for (int j = i-1; j &gt;=0 ; j--) {
            y = [tempLogArr[j][@&quot;Index&quot;] intValue];
            if (x == y) {
                [tempLogArr removeObjectAtIndex:j];
            }
        }
    }

</code></pre>

<h5 id="toc_5">数组historyArray元素是字典 遍历遇到重复信息删除，停止遍历</h5>

<p>不遍历全部，针对每次增加信息的时候，都会调用这个方法，不会出现重复两次的情况</p>

<pre><code>//tempStr 信息的唯一标识，tempDic是全部信息内容
-(void)saveSearchData:(NSString*)tempStr infoDic:(NSDictionary *)tempDic
{
    /**该模块为判断浏览的信息是否已经存在历史记录里,如果存在则删除过去的,重新添加最新的搜索记录*/
    
    if (self.historyArray.count&gt;0) {
        //第一种遍历方法，数组元素为字典，字典是每条信息的全部内容
        [self.historyArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            
            //NSLog(@&quot;idx=%lu, id=%@&quot;, (unsigned long)idx, obj);
            
            if ([obj[@&quot;info_id&quot;] isEqualToString:tempStr]) {
                [self.historyArray removeObjectAtIndex:idx];
                *stop = YES;//停止遍历
            }
        }];
    }
    [self.historyArray addObject:tepDic];
}
</code></pre>

<h5 id="toc_6">遍历方法:快速枚举</h5>

<pre><code>    for(NSString* obj in tempArr)
    {
        NSLog(@&quot;%@&quot;, obj);
    }
</code></pre>

<h5 id="toc_7">遍历方法:快速遍历</h5>

<pre><code>//顺序遍历
[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = YES;//停止遍历,也可以在此增加if判断idx = 3 的时候停止。
 }];
//倒序遍历
[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = NO;//继续遍历
}];
</code></pre>

<h5 id="toc_8">动态数组NSMutableArray的add操作</h5>

<pre><code>    NSArray * array = [NSArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;, nil];
    
    //方法一
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list addObjectsFromArray: array]];
    NSLog(@&quot;%@&quot;,list);//(1,2)
    
    //方法二arrayByAddingObjectsFromArray 该方法做了copy原数据不变
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list arrayByAddingObjectsFromArray: array]
    NSLog(@&quot;%@&quot;,list);//()
    
</code></pre>

<h5 id="toc_9">数组的简单操作</h5>

<pre><code>//插入索引为几的位置
[tempArr insertObject:@&quot;two&quot; atIndex:1];

//修改数组中第2个元素的内容
[tempArr replaceObjectAtIndex:2 withObject:@&quot;aaa&quot;];

//交换数组中得内容
[tempArr exchangeObjectAtIndex:1 withObjectAtIndex:3];

//取出连续范围的元素作为子集内容
NSArray *sub1 = [tempArr subarrayWithRange:NSMakeRange(1, 3)];
</code></pre>

<h5 id="toc_10">数组的删除操作</h5>

<pre><code>//1.删除最后一个元素
 [array removeLastObject];
 NSLog(@&quot;%@&quot;,array);

//2.删除指定下标的元素
[array removeObjectAtIndex:5];
 NSLog(@&quot;%@&quot;,array);

//3.直接删除元素
[array removeObject:@&quot;e&quot;];
 NSLog(@&quot;%@&quot;,array);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC plist文件管理(代码方式)]]></title>
    <link href="www.freefook.com/15142856319824.html"/>
    <updated>2017-12-26T18:53:51+08:00</updated>
    <id>www.freefook.com/15142856319824.html</id>
    <content type="html"><![CDATA[
<pre><code>//获取本地沙盒路径
NSArray *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);

//获取完整路径
NSString *documentsPath = [path objectAtIndex:0];
NSString *plistPath = [documentsPath stringByAppendingPathComponent:@&quot;Test.plist&quot;];

//创建数据
NSMutableDictionary *dataDict = [NSMutableDictionary dictionary];

[dataDict setObject:@&quot;zhangd&quot; forKey:@&quot;name&quot;];
[dataDict setObject:@&quot;26&quot; forKey:@&quot;age&quot;];
[dataDict setObject:@&quot;man&quot; forKey:@&quot;sex&quot;];

//写入plist文件
[dataDict writeToFile:plistPath atomically:YES];

//读取plist文件
//文件是什么类型，就用什么类型的数据来接收
NSMutableDictionary *dataDict1 = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];
NSLog((@&quot;**start**\n[function name:%s]\n&quot; &quot;[Lines:%d]\n&quot; &quot;data-&gt;%@\n**end**\n\n&quot;), __FUNCTION__, __LINE__,dataDict1);

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 从AppDelegate说起]]></title>
    <link href="www.freefook.com/15142851543985.html"/>
    <updated>2017-12-26T18:45:54+08:00</updated>
    <id>www.freefook.com/15142851543985.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">创建程序窗口</h5>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
self.window.backgroundColor = [UIColor whiteColor];
[self.window setRootViewController:self.tabbarVC];
[self.window makeKeyAndVisible];
</code></pre>

<h5 id="toc_1">生命周期</h5>

<pre><code>- (void)applicationWillEnterForeground:(UIApplication *)application {
    NSLog(@&quot;将要进入前台：%s&quot;,__func__);
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    
    NSLog(@&quot;已经获得焦点：%s&quot;,__func__);
}

- (void)applicationWillResignActive:(UIApplication *)application {
    
    NSLog(@&quot;将要释放焦点：%s&quot;,__func__);
}
- (void)applicationWillTerminate:(UIApplication *)application {
    
    NSLog(@&quot;程序将要退出：%s&quot;,__func__);
}
- (void)applicationDidEnterBackground:(UIApplication *)application {
    
    NSLog(@&quot;已经进入后台：%s&quot;,__func__);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 基础使用说明]]></title>
    <link href="www.freefook.com/15139214660338.html"/>
    <updated>2017-12-22T13:44:26+08:00</updated>
    <id>www.freefook.com/15139214660338.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">pragma - mark - tableview列表初始化</h5>

<pre><code>-(UITableView *)tableView
{
    if (!_tableView) {
        
        _tableView = [[UITableView alloc]initWithFrame:
                      CGRectMake(, , , ) style:UITableViewStylePlain];
        _tableView.delegate = self;
        _tableView.dataSource = self;
        _tableView.backgroundColor = ;
        //分割线的颜色
        _tableView.separatorColor = ;
        //隐藏滚动条
        _tableView.showsVerticalScrollIndicator = NO;
        _tableView.tableFooterView = [[UIView alloc]init];
        
    }
    return _tableView;
}
</code></pre>

<h5 id="toc_1">tableview 代理方法实现如下：</h5>

<h6 id="toc_2">tableview解决常规配置的重复问题。。。</h6>

<pre><code>//当页面拉动需要显示新数据的时候，把最后一个cell进行删除 此方案即可避免重复显示，又重用了cell相对内存管理来说是好的方案 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @&quot;Cell&quot;;
    // 通过唯一标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免
    {
        while ([cell.contentView.subviews lastObject] != nil) {
            [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview];
        }
    }
    
//点击没有选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;  

// 对cell 进行简单地数据配置
cell.textLabel.text = @&quot;text&quot;;
   
return cell;
}
</code></pre>

<h5 id="toc_3">other</h5>

<pre><code>//行
-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    
    return &lt;#@#&gt;;
}
//行高
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return &lt;#@#&gt;;
}

#pragma - mark - 点击cell方法

-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    
}
</code></pre>

<h5 id="toc_4">tableview header与footer</h5>

<pre><code>#pragma - mark - tableview_Header and Footer

-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    
    return 0;
}

-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section
{
    
    return 0;
    
}
</code></pre>

<p>tableview 侧滑删除方法</p>

<pre><code>//先要设Cell可编辑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    
    return NO;
}

//定义编辑样式
- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    return UITableViewCellEditingStyleDelete;
}

//修改编辑按钮文字
- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath {
    return @&quot;删除&quot;;
}

//设置进入编辑状态时，Cell不会缩进
- (BOOL)tableView: (UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath {
    return NO;
}

//点击删除
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    /**一定是先删除了数据，再执行删除的动画或者其他操作，否则会出现崩溃*/
    
    [self deleteData:indexPath];//单个删除接口
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 常用属性与方法]]></title>
    <link href="www.freefook.com/15142851756052.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851756052.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">tableview 常用属性如下：</h5>

<pre><code>//获取手势点击的是哪一个cell的坐标
NSIndexPath *indexPath = [self.tableView indexPathForCell:((UITableViewCell *)longPress.view)];

//点击button时获取button所在的cell的indexpath
UIButton *button = sender;
tempTableViewCell *cell = (tempTableViewCell *)[[button superview] superview];
NSIndexPath *indexPath = [_tableView indexPathForCell:cell];

//局部刷新一个section刷新    
NSIndexSet *indexSet=[[NSIndexSet alloc]initWithIndex:1];    
[tableview reloadSections:indexSet withRowAnimation:UITableViewRowAnimationAutomatic];    

//局部刷新一个cell刷新   
NSIndexPath *indexPath=[NSIndexPath indexPathForRow:1 inSection:0];   
[tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:indexPath,nil] withRowAnimation:UITableViewRowAnimationNone]; 

//不显示分割线
_tableView.separatorStyle = UITableViewCellSeparatorStyleNone;

//显示箭头
cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;

//无选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;

//自适应单元格高度
tableView.rowHeight = UITableViewAutomaticDimension; 
//先估计一个高度
tableView.estimatedRowHeight = 50; 
</code></pre>

<pre><code></code></pre>

<pre><code></code></pre>

<h5 id="toc_1">tableview 常用方法如下：</h5>

<h6 id="toc_2">tableview 选中第几行</h6>

<pre><code>NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView selectRowAtIndexPath:indexpath animated:YES scrollPosition:UITableViewScrollPositionMiddle];  //选中第5行
</code></pre>

<h6 id="toc_3">滚动到指定位置</h6>

<pre><code>//滚动到指定位置_偏移量
[self.rizhiTableView setContentOffset:CGPointMake(0, OffsetY) animated:NO];
//滚动到第几行
NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionTop animated:NO];
</code></pre>

<h6 id="toc_4">pragma mark  - 滑到最底部</h6>

<pre><code>- (void)scrollTableToFoot
{
    
    dispatch_async(dispatch_get_main_queue(), ^{
        
        NSInteger s = [self.tableView numberOfSections];  //有多少组
        if (s&lt;1) return;  //无数据时不执行 要不会crash
        NSInteger r = [self.tableView numberOfRowsInSection:s-1]; //最后一组有多少行
        if (r&lt;1) return;
        NSIndexPath *indexpath = [NSIndexPath indexPathForRow:r-1 inSection:s-1];  //取最后一行数据
        [self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionBottom animated:NO]; //滚动到最后一行
        
    });
  
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UICollectionView使用详解]]></title>
    <link href="www.freefook.com/15142851752080.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851752080.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">添加代理</h5>

<pre><code>&lt;UICollectionViewDataSource,UICollectionViewDelegate&gt;
</code></pre>

<h5 id="toc_1">初始化</h5>

<pre><code> UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
    flowLayout.minimumInteritemSpacing = 0;
    flowLayout.minimumLineSpacing = 0;
    flowLayout.sectionInset  = UIEdgeInsetsMake(0, 5, 0, 5);
    
_collectionView = [[UICollectionView alloc] initWithFrame:
CGRectMake(0, 0, self.view.frame.size.with,self.view.frame.size.height) 
collectionViewLayout:flowLayout];
    
    //一定要注册
    [_collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;colletionCell&quot;];
    [_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;HeaderIdentifier&quot;];
    
    _collectionView.backgroundColor = [UIColor whiteColor];
    _collectionView.dataSource = self;
    _collectionView.delegate = self;
    
    _collectionView.alwaysBounceVertical = YES;
    _collectionView.showsVerticalScrollIndicator = NO;
    [self.view addSubview:_collectionView];
    
    if (@available(iOS 11.0, *)) {
    }else{
        self.automaticallyAdjustsScrollViewInsets = NO;
    }
</code></pre>

<h5 id="toc_2">设置_collectionView的组数</h5>

<pre><code>-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 3;
}
</code></pre>

<h5 id="toc_3">设置每组cell的个数</h5>

<pre><code>//返回每组的个数
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    if (section == 0) {
        return 3;
    }else if (section == 1){
        return 4;
    }else if (section == 2){
        return 3;
    }
    return 0;
} 

</code></pre>

<h5 id="toc_4">设置每组cell的大小</h5>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    if (indexPath.section == 0) {
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
        
    }else if (indexPath.section == 1){
        return  CGSizeMake((KScreenWidth-10)/2, KScreenWidth/2+60);

    }else{
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
    }
}
</code></pre>

<h5 id="toc_5">布局cell</h5>

<pre><code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *reuseIdetify = @&quot;colletionCell&quot;;
    
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdetify forIndexPath:indexPath];
    
    cell.contentView.backgroundColor = [UIColor whiteColor];
    //这句是每次都移除view上的控件,从新添加的;
    [cell.contentView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
    
    /***********布局cell*********/


    /***************************/ 
       
    return cell;
}
</code></pre>

<h5 id="toc_6">设置_collectionView头部header高度</h5>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section {
    
    if (section == 0) {
        CGSize size={KScreenWidth,cycHeight + 240};
        return size;
        
    }else if (section == 1){
        CGSize size={KScreenWidth,140};
        return size;

    }else{
        CGSize size={KScreenWidth,40};
        return size;

    }
}
</code></pre>

<h5 id="toc_7">布局_collectionView上的头部UI</h5>

<pre><code>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView
           viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath
{
    
    UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader
                                                                            withReuseIdentifier:@&quot;HeaderIdentifier&quot;
                                                                                   forIndexPath:indexPath];

    [headView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];

    if (indexPath.section == 0) {
        
        if(kind ==UICollectionElementKindSectionHeader){
            
        }
     }
    
    return headView;
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS请求方式]]></title>
    <link href="www.freefook.com/15142851750375.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851750375.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">AFN请求</h5>

<pre><code> AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];
 
    //向服务器发送JSON形式的二进制数据
    sessionManager.requestSerializer = [AFJSONRequestSerializer serializer];
    //设置默认只返回原始的二进制数据,程序猿自己解析
    //manager.responseSerializer = [AFHTTPResponseSerializer serializer];
    
     //设置非校验证书模式
     manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];
     manager.securityPolicy.allowInvalidCertificates = YES;
    [manager.securityPolicy setValidatesDomainName:NO];
           
    sessionManager.requestSerializer.timeoutInterval = 10.f;
    sessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;,@&quot;text/javascript&quot;, @&quot;text/html&quot;, @&quot;text/plain&quot;,  nil];
    
   //设置请求头 参数
    [sessionManager.requestSerializer setValue:@&quot;Token&quot;] forHTTPHeaderField:@&quot;Authorization&quot;];
    
    [sessionManager POST:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {
        
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        
    
     NSDictionary * dic=[[NetworkTool sharedNetworkTool] changeType: responseObject] ;
        
                
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        failure(error);
    }];
</code></pre>

<pre><code>-(id)changeType:(id)myObj
{
    if ([myObj isKindOfClass:[NSDictionary class]])
    {
        return [self nullDic:myObj];
    }
    else if([myObj isKindOfClass:[NSArray class]])
    {
        return [self nullArr:myObj];
    }
    else if([myObj isKindOfClass:[NSString class]])
    {
        return [self stringToString:myObj];
    }
    else if([myObj isKindOfClass:[NSNull class]])
    {
        return [self nullToString];
    }
    else
    {
        return myObj;
    }
}

//将NSDictionary中的Null类型的项目转化成@&quot;&quot;
-(NSDictionary *)nullDic:(NSDictionary *)myDic
{
    NSArray *keyArr = [myDic allKeys];
    NSMutableDictionary *resDic = [[NSMutableDictionary alloc]init];
    for (int i = 0; i &lt; keyArr.count; i ++)
    {
        id obj = [myDic objectForKey:keyArr[i]];
        obj = [self changeType:obj];
        [resDic setObject:obj forKey:keyArr[i]];
    }
    return resDic;
}

//将NSArray中的Null类型的项目转化成@&quot;&quot;
-(NSArray *)nullArr:(NSArray *)myArr
{
    NSMutableArray *resArr = [[NSMutableArray alloc] init];
    for (int i = 0; i &lt; myArr.count; i ++)
    {
        id obj = myArr[i];
        obj = [self changeType:obj];
        [resArr addObject:obj];
    }
    return resArr;
}

//将NSString类型的原路返回
-(NSString *)stringToString:(NSString *)string
{
    return string;
}

//将Null类型的项目转化成@&quot;&quot;
-(NSString *)nullToString
{
    return @&quot;&quot;;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS导航 与pop]]></title>
    <link href="www.freefook.com/15142851748774.html"/>
    <updated>2017-12-26T18:46:14+08:00</updated>
    <id>www.freefook.com/15142851748774.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">BaseVC里写入</h5>

<pre><code>    [self.navigationController.navigationBar setHidden:NO];
    
    UIBarButtonItem *backBtn = [[UIBarButtonItem alloc] init];
    backBtn.title = @&quot;&quot;;//返回
    self.navigationItem.backBarButtonItem = backBtn;
    self.navigationController.navigationBar.tintColor = [UIColor blackColor];
    
    [self.navigationController.navigationBar setBackgroundImage:[Helper imageWithColor:rgba(246, 246, 246, 1.0)] forBarMetrics:(UIBarMetricsDefault)];
    
    //设置字体大小和颜色
    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:18]}];
    
</code></pre>

<h5 id="toc_1">移除navigationController.viewControllers 栈里的类</h5>

<pre><code> NSMutableArray*tempMarr =[NSMutableArray arrayWithArray:self.navigationController.viewControllers];
        NSMutableArray* temp = [[NSMutableArray alloc]init];
        for (int i = 0; i &lt; tempMarr.count; i++) {
            
            if ([tempMarr[i] isKindOfClass:[SubmitOrderViewController class]]) {
                [tempMarr removeObjectAtIndex:i];
                
            }else if ([tempMarr[i] isKindOfClass:[PayOrderViewController class]]) {
                [tempMarr removeObjectAtIndex:i];
                
            }else{
                [temp addObject:tempMarr[i]];
            }
        }
        [self.navigationController setViewControllers:temp animated:YES];
</code></pre>

<h5 id="toc_2">pop到navigationController栈里指定的页面</h5>

<pre><code> for (UIViewController *controller in self.navigationController.viewControllers) {
         if ([controller isKindOfClass:[ShopDetailViewController class]]) {
                    ShopDetailViewController *A =(ShopDetailViewController *)controller;
                    [self.navigationController popToViewController:A animated:YES];

         }
 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发说明]]></title>
    <link href="www.freefook.com/15139213651453.html"/>
    <updated>2017-12-22T13:42:45+08:00</updated>
    <id>www.freefook.com/15139213651453.html</id>
    <content type="html"><![CDATA[
<pre><code>what？

项目分配下来后，针对一些疑问的解释说明。
针对一些项目中开发事宜，做一些解释说明。
针对一些项目中重复代码，做一些记录，不管在哪个电脑，哪个项目，写的时候，可以copy。

why?

避免一些情况 “开发做了很多，布局调整导致缝缝补补的局面”。
所以有经验的开发人员总会说一句，就是“不管简单或复杂的页面，都不要写死了。
谁知道哪天甲方/产品说这里很简单，改一下吧，那个很简单，改一下吧”
如果你没时间改，那别给队友带刀啊。
所以统一规范，统一大块的思路，在程序中增加说明文件，减少上班带刀的同事，避免做地铁过安检的问题。

how?

建项开始:
1. 项目问题汇总
2. 建项使用三方管理工具cocoapods
3. 建项创建.pch文件
4. 建项那些.pch里写了些什么
5. 建项权限、网络问题
6. 建项屏幕适配问题
</code></pre>

<h4 id="toc_0">程序的“通用性”</h4>

<pre><code>用简单的代码去解决的问题，不要过分的关注了“通用性”，
“可维护性”和“可扩展性”，被搞得绕来绕去，让人琢磨不透。
不用装逼搞酷炫，不是在搞复杂性的东西，不要一个东西调了四五层去解决问题；
“考虑”到了通用性，并不等于你就准确地“把握”住了通用性；

如果在第一次的设计中就过早的考虑到将来，由此带来的多余的复杂性，
有可能让初期的设计就出现问题。所以这种对于将来的变化的考虑，实际上帮了倒忙。
尽量不要大段 大段的留下注释代码，留下以后说可能会用，
其实在打开注释用到的可能性有多少，少之又少。

代码需要被“重用”的场合，实际上比你想象的要少。所以尽可能的简单
因为简单的东西每个项目重复性的、大量的会去写，
所以有些东西，可以放在xcode 的代码块里；

最后不要极端的追求所谓“程序的正确性”畏首畏尾的写程序，
正确不等于直接，高效，放手写吧。。。

</code></pre>

<h4 id="toc_1">简单的编码中规范说明</h4>

<p>程序开始增加说明文件</p>

<pre><code>说明文件，记录项目功能实现的思维说明：
1.MVC  MVVM MVCS 等放荡不羁的模式
2.复杂UI的实现说明或使用了他人封装类库，注明使用方法示例；
3.网络请求方式，加密方式，部数据处理方式；
4.本地数据的存储方式
5.复杂业务逻辑的流程说明，与实现后遗留缺陷。
6.写出你认为程序中还遗留的缺陷， bug，改进，优化的地方
</code></pre>

<h4 id="toc_2">程序开发过程中命名方式</h4>

<blockquote>
<p>大家公认无岐义的缩写(比如：nav，bg，btn等)<br/>
写在哪些命名里都可以</p>
</blockquote>

<h5 id="toc_3">类命名：前缀+描述+类型</h5>

<pre><code>1.创建一个类时，增加自己名字首字母的简写例如：张东 ZDLoginViewController
2.ViewController 是处理业务逻辑，UI 代码 数据请求与处理 尽量不要写太多
3.view的生命周期的几个方法 在类中方法的最上方
4.类中方法增加Mark（#pragma - mark - 点击登录，请求登录接口 ）

</code></pre>

<h5 id="toc_4">属性命名：描述性单词+变量类型</h5>

<pre><code>UILabel* nameLabel;
</code></pre>

<h5 id="toc_5">方法命名</h5>

<pre><code>一个规范的方法读起来应该像一句完整的话，读过之后便知函数的作用。
返回性的方法应该以返回的内容开头，但之前不要加get。
不要各种缩写，写完猜不出意思。保持完整性

</code></pre>

<h5 id="toc_6">函数命名</h5>

<pre><code>一些典型操作应该使用约定的动词，如initWith,insert,remove,replace,add等等。
</code></pre>

<h5 id="toc_7">程序中使用的图片命名</h5>

<pre><code>在Assets.xcassets里创建相应使用的功能模块文件夹
例如：personalCenter 文件里放登录、注册、我的信息用到的图片
图片命名 类型+模块/功能 例如：btn/bg_login_normal@3x.png 
</code></pre>

<h5 id="toc_8">代码注释</h5>

<pre><code>代码的注释问题:很多人的注释过于粗糙,有些甚至都没有注释习惯,导致代码可读性差,
版本迭代或是需求变更的时候不能及时定位到具体代码；

注释方式例如：
/** 名字 */
@property(nonatomic,strong)NSString* name;

这样注释的好处是:
当你调用这个属性时会具有相关备注提示

</code></pre>

<h5 id="toc_9">代码中的循环与判断</h5>

<pre><code>在任何情况下 for 语句和 if 语句之后必须写花括号，
即使允许你在其只包含一行代码的时候可以省略
for (int i=0; i &lt; n; i++)
   function(i);
   
for (int i=0; i &lt; n; i++) {
   function(i);
 }
</code></pre>

]]></content>
  </entry>
  
</feed>
