<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[随心所欲之张东东篇]]></title>
  <link href="www.freefook.com/atom.xml" rel="self"/>
  <link href="www.freefook.com/"/>
  <updated>2018-04-12T15:27:36+08:00</updated>
  <id>www.freefook.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[小程序]]></title>
    <link href="www.freefook.com/15232437563217.html"/>
    <updated>2018-04-09T11:15:56+08:00</updated>
    <id>www.freefook.com/15232437563217.html</id>
    <content type="html"><![CDATA[
<p>介绍：<br/>
<a href="https://developers.weixin.qq.com/miniprogram/dev/index.html">https://developers.weixin.qq.com/miniprogram/dev/index.html</a></p>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.31.04.png" alt="屏幕快照 2018-04-09 上午11.31.04"/></p>

<ol>
<li>打开公众平台 <a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></li>
<li>使用未绑定微信其他产品的邮箱注册</li>
<li>登录成功</li>
<li>查看小程序平台</li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.19.02.png" alt="屏幕快照 2018-04-09 上午11.19.02"/></p>

<ol>
<li>微信开发者工具首次打开需要AppID<br/>
官方工具：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=201714</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.21.41.png" alt="屏幕快照 2018-04-09 上午11.21.41"/></p>

<ol>
<li>小程序开发必读项，教程 ，框架 ，组件 ，API , 工具<br/>
简易教程：<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/">https://mp.weixin.qq.com/debug/wxadoc/dev/</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.23.50.png" alt="屏幕快照 2018-04-09 上午11.23.50"/></p>

<ol>
<li>当开始要做一个小程序时，需通读设计指南<br/>
设计指南：<a href="https://mp.weixin.qq.com/debug/wxadoc/design/index.html">https://mp.weixin.qq.com/debug/wxadoc/design/index.html</a></li>
</ol>

<p><img src="media/15232437563217/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-09%20%E4%B8%8A%E5%8D%8811.28.55.png" alt="屏幕快照 2018-04-09 上午11.28.55"/></p>

<ul>
<li>运营规范(在这里查看禁止事项)：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/index.html">https://mp.weixin.qq.com/debug/wxadoc/product/index.html</a></li>
<li>特殊行业所需资质材料：<a href="https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/product/material.html?t=201714</a></li>
<li>支付文档：<a href="https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1">https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&amp;index=1</a></li>
<li>客服消息：<a href="https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221">https://mp.weixin.qq.com/debug/wxadoc/introduction/custom.html?t=20161221</a> </li>
<li>数据分析：<a href="https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714">https://mp.weixin.qq.com/debug/wxadoc/analysis/index.html?t=201714</a></li>
</ul>

<p>疑难问题，请浏览👇<br/>
小程序社区：<a href="http://www.wxapp-union.com/">http://www.wxapp-union.com/</a></p>

<p>使用WePY框架开发小程序请移步👇<br/>
<a href="https://tencent.github.io/wepy/index.html">https://tencent.github.io/wepy/index.html</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序登录]]></title>
    <link href="www.freefook.com/15234367737951.html"/>
    <updated>2018-04-11T16:52:53+08:00</updated>
    <id>www.freefook.com/15234367737951.html</id>
    <content type="html"><![CDATA[
<ol>
<li>授权获取用户信息</li>
<li>得到code,iv,encryptedData,rawData,signature将code，iv，encryptedData传给服务器</li>
<li>服务器post请求接口<a href="https://api.weixin.qq.com/sns/jscode2session">https://api.weixin.qq.com/sns/jscode2session</a></li>
</ol>

<pre><code>https://api.weixin.qq.com/sns/jscode2session  
参数{
    appid，
    secret，
    js_code = code，
    grant_type = authorization_code
} 
返回数据{
    session_key，
    openid
}

会话密钥session_key有效性

开发者如果遇到因为session_key不正确而校验签名失败或解密失败，请关注下面几个与session_key有关的注意事项。

    1.wx.login()调用时，用户的session_key会被更新而致使旧session_key失效。
    开发者应该在明确需要重新登录时才调用wx.login()，
    及时通过登录凭证校验接口更新服务器存储的session_key。

    2.微信不会把session_key的有效期告知开发者。
    我们会根据用户使用小程序的行为对session_key进行续期。
    用户越频繁使用小程序，session_key有效期越长。

    3.开发者在session_key失效时，可以通过重新执行登录流程获取有效的session_key。
    使用接口wx.checkSession()可以校验session_key是否有效，
    从而避免小程序反复执行登录流程。

    4.当开发者在实现自定义登录态时，
    可以考虑以session_key有效期作为自身登录态有效期，
    也可以实现自定义的时效性策略。


</code></pre>

<ol>
<li>服务端解密数据encryptedData</li>
</ol>

<pre><code>    对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。
    对称解密的目标密文为 Base64_Decode(encryptedData)。
    对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。
    对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。
    
解密encryptedData数据
{
　　&quot;openId&quot;:&quot;&quot;,
　　&quot;nickName&quot;:&quot;ZIM東&quot;,
　　&quot;gender&quot;:1,
　　&quot;language&quot;:&quot;zh_CN&quot;,
　　&quot;city&quot;:&quot;&quot;,
　　&quot;province&quot;:&quot;&quot;,
　　&quot;country&quot;:&quot;&quot;,
　　&quot;avatarUrl&quot;:&quot;&quot;,
　　&quot;unionId&quot;:&quot;&quot;,
　　&quot;watermark&quot;:{
　　　　&quot;timestamp&quot;:1523433831,
　　　　&quot;appid&quot;:&quot;&quot;
　　}
}

在登录小程序之前，既没有关注过公众号，也没有登录过公众号，
更没有使用微信登录的方式登录过app。
通过 wx.login 的到的 code 解密后未返回 unionid

划重点：
     初次尝试小程序登录未拿到unionid
     小程序里关联了公众号，用微信关注了公众号未获取到unionid
     小程序关联微信开放平台，再次登录得到了unionid

另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark )
appid 敏感数据归属appid，开发者可校验此参数与自身appid是否一致
timestamp 敏感数据获取的时间戳, 开发者可以用于数据时效性校验

</code></pre>

<p><img src="media/15234367737951/%E6%B5%81%E7%A8%8B.png" alt="流程"/></p>

<p>👆原图地址：<a href="https://blog.csdn.net/dingjianmin/article/details/75137934">https://blog.csdn.net/dingjianmin/article/details/75137934</a></p>

<p>注意：开发者后台拿到开放数据后可以对数据进行校验签名和解密，来保证数据不被篡改。 </p>

<p><img src="media/15234367737951/%E6%95%B0%E6%8D%AE.png" alt="数据"/></p>

<pre><code>签名校验以及数据加解密涉及用户的会话密钥session_key。 开发者应该事先通过 wx.login 登录流程获取会话密钥 session_key 并保存在服务器。为了数据不被篡改，开发者不应该把session_key传到小程序客户端等服务器外的环境。

数据签名校验

为了确保 开放接口 返回用户数据的安全性，微信会对明文数据进行签名。
开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。

    通过调用接口（如 wx.getUserInfo）获取数据时，接口会同时返回 rawData、signature，
    其中 signature = sha1( rawData + session_key )
    
    开发者将 signature、rawData 发送到开发者服务器进行校验。
    服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，
    比对 signature 与 signature2 即可校验数据的完整性。

</code></pre>

<p>官方数据签名校验<br/>
<a href="https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject">https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序TabBar]]></title>
    <link href="www.freefook.com/15235114845539.html"/>
    <updated>2018-04-12T13:38:04+08:00</updated>
    <id>www.freefook.com/15235114845539.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">创建一个标准小程序空项目</h4>

<h5 id="toc_1">在app.json文件里写入如下代码</h5>

<pre><code> &quot;tabBar&quot;: {
    &quot;color&quot;: &quot;#a9b7b7&quot;,
    &quot;selectedColor&quot;: &quot;#000000&quot;,
    &quot;borderStyle&quot;: &quot;black&quot;,
    &quot;list&quot;: [
      {
        &quot;selectedIconPath&quot;: &quot;image/home.png&quot;,
        &quot;iconPath&quot;: &quot;image/home.png&quot;,
        &quot;pagePath&quot;: &quot;pages/home/home&quot;,
        &quot;text&quot;: &quot;首页&quot;
      },
      {
        &quot;selectedIconPath&quot;: &quot;image/index.png&quot;,
        &quot;iconPath&quot;: &quot;image/index.png&quot;,
        &quot;pagePath&quot;: &quot;pages/index/index&quot;,
        &quot;text&quot;: &quot;专题&quot;
      }
    ]
  }
   
</code></pre>

<h4 id="toc_2">运行界面 tabbar</h4>

<p><img src="media/15235114845539/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%881.41.36.png" alt="屏幕快照 2018-04-12 下午1.41.36"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序轮播]]></title>
    <link href="www.freefook.com/15235125175960.html"/>
    <updated>2018-04-12T13:55:17+08:00</updated>
    <id>www.freefook.com/15235125175960.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">第一步：在.wxml文件里写入如下代码</h4>

<pre><code>&lt;swiper indicator-dots=&quot;{{indicatorDots}}&quot;  
        autoplay=&quot;{{autoplay}}&quot; 
        interval=&quot;{{interval}}&quot; 
        duration=&quot;{{duration}}&quot; 
        circular=&quot;true&quot;&gt;  

      &lt;block wx:for=&quot;{{imgUrls}}&quot; wx:for-index=&quot;index&quot;&gt;  
        &lt;swiper-item&gt;  
            &lt;navigator url=&quot;{{item.link}}&quot; hover-class=&quot;navigator-hover&quot;&gt; 
            &lt;image src=&quot;{{item.url}}&quot; 
                   class=&quot;slide-image&quot;/&gt;  
            &lt;/navigator&gt;  
        &lt;/swiper-item&gt;  
      &lt;/block&gt;  

&lt;/swiper&gt; 

</code></pre>

<h4 id="toc_1">第二步：在.wxss文件里设置如下属性</h4>

<pre><code>   swiper{
    height: 220px;
   } 

    .slide-image{  
        width: 100%;  
        height: 180px;
    }  
</code></pre>

<h4 id="toc_2">第三步：在.js文件里设置如下数据 和轮播属性设置</h4>

<pre><code> imgUrls: [
      {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg&#39;
      }, {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&#39;
      }, {
        link: &#39;/pages/logs/logs&#39;,
        url: &#39;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&#39;
      }   

    ],
    indicatorDots: true,
    autoplay: true,
    
    interval: 3000,
    duration: 500,

</code></pre>

<h4 id="toc_3">运行界面如下：</h4>

<p><img src="media/15235125175960/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%882.07.56.png" alt="屏幕快照 2018-04-12 下午2.07.56"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序列表list]]></title>
    <link href="www.freefook.com/15235133751593.html"/>
    <updated>2018-04-12T14:09:35+08:00</updated>
    <id>www.freefook.com/15235133751593.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">在创建的home.wxml文件里写入如下布局</h5>

<pre><code>&lt;view&gt;  
  &lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height:100%&quot; &gt;  
    &lt;view wx:for=&quot;{{array}}&quot; style=&quot;width:100%&quot;&gt;  
    &lt;image id =&quot;{{index}}&quot; 
           src =&quot;{{item}}&quot; 
           mode =&quot;aspectFill&quot; 
           style =&quot;width:100%;height:150px&quot;      
           bindtap =&quot;tapName&quot; 
           data-img =&quot;{{item}}&quot;&gt;&lt;/image&gt; 
    &lt;/view&gt;  
  &lt;/scroll-view&gt;  
&lt;/view&gt; 
</code></pre>

<h5 id="toc_1">在home.js 文件里放入数据</h5>

<pre><code>/**
   * 页面的初始数据
   */
  data: {
    array: [
    &quot;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&quot;,
    &quot;http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg&quot;,
    &quot;http://img0.imgtn.bdimg.com/it/u=3069472720,3661376600&amp;fm=214&amp;gp=0.jpg&quot;
    ]  
  },

  //列表上图片点击方法，跳转详情页面
  tapName: function (event) {
    console.log(event.target.dataset.img)
    wx.navigateTo({
      url: &#39;../detail/detail&#39;
    })
  },
  
  
/**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {

    console.log(&quot;打印参数，上个页面传过来的参数id---&gt;&quot;)
    console.log(options.id)  

  },
  
</code></pre>

<h5 id="toc_2">在home.json文件里写上navigationBarTitleText</h5>

<pre><code>{
  &quot;navigationBarTitleText&quot;: &quot;知之为知之&quot;
}
</code></pre>

<h4 id="toc_3">运行界面 列表 list</h4>

<p><img src="media/15235114845539/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%881.50.12.png" alt="屏幕快照 2018-04-12 下午1.50.12"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小程序网络请求]]></title>
    <link href="www.freefook.com/15235164843984.html"/>
    <updated>2018-04-12T15:01:24+08:00</updated>
    <id>www.freefook.com/15235164843984.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">1.在wxml文件里加上按钮点击事件 和list</h4>

<pre><code>&lt;button bindtap=&quot;RequestData&quot; value=&quot;Button&quot;&gt;request&lt;/button&gt; 

&lt;view&gt;  
  &lt;scroll-view scroll-y=&quot;true&quot; style=&quot;height:100%&quot; &gt;  
    &lt;view wx:for=&quot;{{textdata}}&quot; style=&quot;width:100%&quot;&gt;  
      &lt;label style=&quot;width:100%;height:50px;font-family:&#39;微软雅黑&#39;&quot;&gt;  {{item.name}}&lt;/label&gt;  
    &lt;/view&gt;  
  &lt;/scroll-view&gt;  
&lt;/view&gt;   

</code></pre>

<h4 id="toc_1">2.在.js 文件添加网络请求，点击按钮后执行代码如下：</h4>

<pre><code> RequestData: function () {
    var that = this;
    wx.request({
      url: &#39;http://.../serve/api/v1.0/service/communityLst&#39;,

      data: {},
      method: &#39;GET&#39;, 
      // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT 
      // header: {}, // 设置请求的 header 默认是application/json  

      success: function (res) {  
        //划重点---&gt;setData 
        that.setData({ textdata: res.data.query});
        
        // 操作json数据 遍历打印数组里name字段数据  
        for (var i in res.data.query) {
          console.log(res.data.query[i].name);
        }
      },
      fail: function () {
        // fail  
      },
      complete: function () {
        // complete  
      }
    })
  },  
</code></pre>

<h4 id="toc_2">3.setData 后页面如下：</h4>

<p><img src="media/15235164843984/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-12%20%E4%B8%8B%E5%8D%882.26.02.png" alt="屏幕快照 2018-04-12 下午2.26.02"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS ARKit 看我就受够了]]></title>
    <link href="www.freefook.com/15139220095625.html"/>
    <updated>2017-12-22T13:53:29+08:00</updated>
    <id>www.freefook.com/15139220095625.html</id>
    <content type="html"><![CDATA[
<p>因为有项目需求ARKit，查询后反馈的文档<br/>
现发布出来，还没注明转载出自哪里，见谅，找到地址时补齐；</p>

<p><a href="https://developer.apple.com/documentation/arkit">https://developer.apple.com/documentation/arkit</a><br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-3bdc5004b7ecbc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>截图</p>

<h3 id="toc_0">AR增强现实技术</h3>

<p>在即将发布的iOS11系统上，ARKit正式成为iOS系统框架，让开发者能够使用OC或swift语言开发AR类型的APP。<br/>
ARKit的大部分计算都是在CPU上处理的，在A8处理器上的性能损耗在15%~ 25%,<br/>
在A9处理器上的性能损耗在10% ~ 15%。为了更好的体验，所以苹果仅支持 A9 及以上处理器<br/>
<img src="http://upload-images.jianshu.io/upload_images/670820-2eaafcbc013d5c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""/>AR支持系列</p>

<h4 id="toc_1">ARKit 实现测量尺功能：</h4>

<p>实现该功能原理:收集相机的视觉信息，以及手机中传感器，包括陀螺仪、罗盘和加速度计来计算并确定设备的位置。<br/>
当然，这都是基于ARKit开发的，不想深入，想深入，深入，入...</p>

<blockquote>
<p>•多媒体捕捉现实图像:如摄像头<br/>
•三维建模:3D立体模型<br/>
•传感器追踪:主要追踪现实世界动态物体的六轴变化，这六轴分别是X、Y、Z轴位移及旋转。其中位移三轴决定物体的方位和大小，旋转三轴决定物体显示的区域。<br/>
•坐标识别及转换:3D模型显示在现实图像中不是单纯的坐标点，而是一个三维的矩阵坐标</p>
</blockquote>

<h4 id="toc_2">注意:</h4>

<ol>
<li><p>如果手机中的场景越丰富，那么测量的结果也就越精确。如果想要测量一面白墙的长度，暂时还不是很准确。AR应用是通过“特征点”进行识别的,也因为是三维矩阵坐标，要求测量时必须很稳的在同一个 Z 轴高度上测量平面的长度;</p></li>
<li><p>不要期望 AR检测的平面会完全贴合表面，虽然检测到了平面但角度可能不完全正确，所以如果开发的AR app需要获得非常精确的几何体来提供更好的效果，可能会出现问题</p></li>
<li><p>边缘检测不是特别好，实际的平面范围有时会太大或太小，所以不要尝试做需要准确边缘的 ARapp</p></li>
</ol>

<h4 id="toc_3">ARKit还存在一些问题:</h4>

<blockquote>
<p>ARKit是基于惯性-视觉来做空间定位的，这项技术会将iOS设备的动作感测硬件信息，加上对可见场景的计算机视觉分析功能，然后与设备的摄像头相结合，需要平稳缓慢的移动+转向手机，才能构建更加准确的世界，这对用户来说是一种考验，需要积极提示。</p>

<p>一旦刚开始检测平面失败，出现时间久，飘逸的现象，后期很难再正确检测，要强制重启。</p>

<p>AVFoudation与ARSession之间的切换会有轻微的卡顿，切换后ARSession就停止摄像头采集了，但3D渲染会继续，只是丧失了空间定位与检测识别的能力.</p>

<p>不支持前置摄像头。ARKit并不是一个用于前置摄像头环境的技术，因为空间有限，能提供的信息也非常有限。100米左右是ARKit在保持较好用户体验的最大测量距离。</p>

<p>ARKit没有计划支持连接两个不同ARKit世界。</p>
</blockquote>

<h4 id="toc_4">要建立高品质的 AR 体验，那么请注意下述这些注意事项和提示:</h4>

<blockquote>
<p>全局追踪是一项不精确的科学 (inexact science)。<br/>
尽管在这个过程当中，经常会产生可观的准确度，从而让AR 的体验更加真实。然而，它严重依赖于设备物理环境的相关细节，而这些细节并不总是一致，有些时候也难以实时测量，这也就导致这些物理细节往往都会存在某种程度的错误。</p>

<p>基于可见的照明条件来设计AR场景。<br/>
全局追踪涉及到了图像分析的相关内容，因此就需要我们提供清晰的图像。如果摄像头没有办法看到相关的物理细节，比如说摄像头拍到的是一面空空如也的墙壁，或者场景的光线实在太暗的话，那么全局追踪的质量就会大大降低。</p>

<p>根据追踪质量的相关信息来给用户进行反馈提示。<br/>
全局追踪会将图像分析与设备的动作模式关联起来。如果设备正在移动的话，那么ARKit 就可以更好地对场景进行建模，这样即便设备只是略微晃动，也不会影响追踪质量。但是一旦用户的动作过多、过快或者晃动过于激烈，就会导致图像变得模糊，或者导致视频帧中要追踪的特征之间的距离过大，从而致使追踪质量的降低。ARCamera类能够提供追踪状态，此外还能提供导致该状态出现的相关原因，您可以在 UI 上展示这些信息，告诉用户如何解决追踪质量低这个问题。</p>

<p>给水平面检测预留点时间来生成清晰的结果，一旦您获得所需的结果后，就禁用水平面检测。一开始对水平面进行检测的时候，所检测到的水平面位置和范围很可能不准确。不过随着时间的推移，只要水平面仍然保持在场景当中，<br/>
那么 ARKit 就能够较为精确地估计水平面的位置和范围。当场景中有一个比较大的平坦表面的话，就算您已经使用过这个水平面来放置内容，那么 ARKit 可能还会继续对水平面的锚点位置、范围和变换点进行修正 。</p>
</blockquote>

<p>综上所述:ARKit 实现测量尺功能，对物理环境要求较高，<br/>
第一，环境光检测，清晰的获取摄像头的帧图像;<br/>
第二，平面检测，准确的获取水平面，如果精确测量，需要边缘化检测准确;<br/>
第三，运动追踪稳定准确等外部因素，对环境和用户操作要求较高;</p>

<h4 id="toc_5">后记补充：</h4>

<p>ARKit是有环境光估计的，这个功能会通过摄像头捕捉并计算捕捉到的场景中的光的总量，来给虚拟物体施加正确的光照条件，渲染效果更加真实。环境光的模拟对于AR出来的画面的真实感，还是有非常大的影响的。</p>

<h5 id="toc_6">在此说一下ARKit没有提供图像识别方面的功能，所以平时可能看到身边有的AR场景是可以识别特定的图像做其他操作类型的App，用ARKit是不能实现的；</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 字符串操作方法说明]]></title>
    <link href="www.freefook.com/15139214218497.html"/>
    <updated>2017-12-22T13:43:41+08:00</updated>
    <id>www.freefook.com/15139214218497.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">属性字符串常用操作</h5>

<pre><code>- (NSMutableAttributedString *)stringToAttributedString:(NSString*)tempStr NSMakeRange:(int)num
{
    NSMutableAttributedString *attrString = [[NSMutableAttributedString alloc] initWithString:tempStr];
    //颜色
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor blackColor] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(num,tempStr.length-num)];
    //字体
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(14)] range:NSMakeRange(0,num)];
    [attrString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:kh(16)] range:NSMakeRange(num,tempStr.length-num)];  
    return attrString;
}
</code></pre>

<h5 id="toc_1">将字符串分隔成数组</h5>

<pre><code>    NSString* str = @&quot;one,two,three,four,five&quot;;
    //分割字符创为数组，下例以“，”分割
    NSArray* array = [str componentsSeparatedByString:@&quot;,&quot;];
    for(NSString* obj in array)
    {
        NSLog(@&quot;%@&quot;, obj);
    }

    //链接字符串,下例以空格连接
    str = [array componentsJoinedByString:@&quot; &quot;];
    NSLog(@&quot;%@&quot;, str);
</code></pre>

<h5 id="toc_2">判断字符串是否包含另一个字符串</h5>

<pre><code>//判断”abcd” 是否含有@&quot;ab&quot;
 NSString *tempStr = @&quot;abcd&quot;;
    if([tempStr rangeOfString:@&quot;ab&quot;].location !=NSNotFound){
        NSLog(@&quot;yes&quot;);
    }else {
        NSLog(@&quot;no&quot;);
    }
</code></pre>

<h5 id="toc_3">字符串去掉特殊符号或改成去除数字/字母的笨方法</h5>

<pre><code>NSString * string111 = @&quot;1234、[]{}#%-*+=_\\|~＜&quot;;
NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@&quot;@／：；（）¥「」＂、[]{}#%-*+=_\\|~＜＞$€^•&#39;@#$%^&amp;*()_+&#39;\&quot;&quot;];
NSString *string222 = [string111 stringByTrimmingCharactersInSet:set];
</code></pre>

<h5 id="toc_4">从字符串的开头一直截取到指定的位置，但不包括该位置的字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringToIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_5">以指定位置开始（包括指定位置的字符），并包括之后的全部字符</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringFromIndex:3];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_6">按照所给出的位置，长度（截取几位而不是到哪），任意地从字符串中截取子串</h5>

<pre><code>    NSString *string1 = @&quot;This is a string&quot;;
    NSString *string2 = [string1 substringWithRange:NSMakeRange(0, 4)];
    NSLog(@&quot;string2:%@&quot;,string2);
</code></pre>

<h5 id="toc_7">替换字符串中字符,该方法做了copy操作，原字符串没变，需要重新赋值给原字符串</h5>

<pre><code>    NSString* tempstr4 = [tempstr3 stringByReplacingOccurrencesOfString:@&quot;:&quot; withString:@&quot;&quot;];
    NSString* tempstr5 = [tempstr4 stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];
    NSString* tempstr6 = [tempstr5 stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;&quot;];
</code></pre>

<h5 id="toc_8">字符串大小写</h5>

<pre><code>//   将字符串中的英文字符由小写转换为大写
    NSString *bigString = [string uppercaseString];
    NSLog(@&quot;string = %@, bigstring = %@&quot;, string, bigString); 
       
//   将字符串中的英文字符由大写转换为小写
    NSString *smallString = [string lowercaseString];
    NSLog(@&quot;string = %@, smallString = %@&quot;, string, smallString);
    
//  将字符串的首字母改为大写
    NSString *firstBigString = [string capitalizedString];
    NSLog(@&quot;%@&quot;, firstBigString);
</code></pre>

<h5 id="toc_9">字符串拼接</h5>

<pre><code>//  字符串拼接:将两个字符串拼在一起后形成一个新的字符串,原来两个字符串并未发生改变
    NSString *string1 = @&quot;abc&quot;;
    NSString *string2 = @&quot;123&quot;;
    NSString *addString = [string1 stringByAppendingString:string2];
    NSLog(@&quot;%@&quot;, addString);
</code></pre>

<h4 id="toc_10">字符串查找</h4>

<pre><code>    NSString * string = @&quot;1234&quot;;
    //  字符串查找：判断是否以参数给定的字符串开头。是，返回真 1 ；否，返回假 0。
    BOOL result1 = [string hasPrefix:@&quot;1&quot;];
    NSLog(@&quot;%d&quot;, result1);
    
    //  字符串查找：判断是否以参数给定的字符串结尾。是，返回真 1 ；否，返回假 0。
    BOOL result2 = [string hasSuffix:@&quot;4&quot;];
    NSLog(@&quot;%d&quot;, result2);
</code></pre>

<h4 id="toc_11">反转字符串</h4>

<pre><code>/**
 *  @brief  反转字符串
 *
 *  @param strSrc 被反转字符串
 *
 *  @return 反转后字符串
 */
+ (NSString *)jk_reverseString:(NSString *)strSrc
{
    NSMutableString* reverseString = [[NSMutableString alloc] init];
    NSInteger charIndex = [strSrc length];
    while (charIndex &gt; 0) {
        charIndex --;
        NSRange subStrRange = NSMakeRange(charIndex, 1);
        [reverseString appendString:[strSrc substringWithRange:subStrRange]];
    }
    return reverseString;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC 数组操作方法说明]]></title>
    <link href="www.freefook.com/15139214500331.html"/>
    <updated>2017-12-22T13:44:10+08:00</updated>
    <id>www.freefook.com/15139214500331.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">获取数组的正序迭代器</h5>

<pre><code>    NSEnumerator *enu1 = [tempArr objectEnumerator];
</code></pre>

<h5 id="toc_1">获取数组的反序迭代器</h5>

<pre><code>    NSEnumerator *enu2 = [tempArr reverseObjectEnumerator];
    //数组倒序输出
    dataArray=(NSMutableArray *)[[dataArray reverseObjectEnumerator] allObjects];
</code></pre>

<h5 id="toc_2">数组排序</h5>

<pre><code>    // 返回一个排好序的数组，原来数组的元素顺序不会改变
    // 指定元素的比较方法：compare:
    NSArray *array1 = [NSArray arrayWithObjects:@&quot;2&quot;, @&quot;3&quot;, @&quot;1&quot;, @&quot;4&quot;, nil];
    NSArray *array2 = [array1 sortedArrayUsingSelector:@selector(compare:)];
    NSLog(@&quot;array2:%@&quot;, array2);(1,2,3,4)
</code></pre>

<h5 id="toc_3">选择排序-iOS常用模式tempLogArr数组里每一元素是字典，根据字典里的dic[Index]排序</h5>

<pre><code>    for (int i=0; i&lt;tempLogArr.count; i++) {
        
        for (int j=i+1; j&lt;tempLogArr.count; j++) {
            
            if ([tempLogArr[i][@&quot;Index&quot;] intValue] &lt; [tempLogArr[j][@&quot;Index&quot;] intValue]) {
                
                [tempLogArr exchangeObjectAtIndex:i withObjectAtIndex:j];
            }
        }
    }
</code></pre>

<h5 id="toc_4">数组tempLogArr元素是字典“遍历所有”去掉重复信息用（ i--）方式，避免数组越界</h5>

<pre><code>    int x;
    int y;
    for (int i = (int)tempLogArr.count - 1; i &gt;=0 ; i--) {
        NSString * tempStr = [NSString stringWithFormat:@&quot;%@&quot;,tempLogArr[i][@&quot;Index&quot;]];
        x = [tempStr intValue];
        for (int j = i-1; j &gt;=0 ; j--) {
            y = [tempLogArr[j][@&quot;Index&quot;] intValue];
            if (x == y) {
                [tempLogArr removeObjectAtIndex:j];
            }
        }
    }

</code></pre>

<h5 id="toc_5">数组historyArray元素是字典 遍历遇到重复信息删除，停止遍历</h5>

<p>不遍历全部，针对每次增加信息的时候，都会调用这个方法，不会出现重复两次的情况</p>

<pre><code>//tempStr 信息的唯一标识，tempDic是全部信息内容
-(void)saveSearchData:(NSString*)tempStr infoDic:(NSDictionary *)tempDic
{
    /**该模块为判断浏览的信息是否已经存在历史记录里,如果存在则删除过去的,重新添加最新的搜索记录*/
    
    if (self.historyArray.count&gt;0) {
        //第一种遍历方法，数组元素为字典，字典是每条信息的全部内容
        [self.historyArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            
            //NSLog(@&quot;idx=%lu, id=%@&quot;, (unsigned long)idx, obj);
            
            if ([obj[@&quot;info_id&quot;] isEqualToString:tempStr]) {
                [self.historyArray removeObjectAtIndex:idx];
                *stop = YES;//停止遍历
            }
        }];
    }
    [self.historyArray addObject:tepDic];
}
</code></pre>

<h5 id="toc_6">遍历方法:快速枚举</h5>

<pre><code>    for(NSString* obj in tempArr)
    {
        NSLog(@&quot;%@&quot;, obj);
    }
</code></pre>

<h5 id="toc_7">遍历方法:快速遍历</h5>

<pre><code>//顺序遍历
[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = YES;//停止遍历,也可以在此增加if判断idx = 3 的时候停止。
 }];
//倒序遍历
[array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSLog(@&quot;%@&quot;,array[idx]);
        *stop = NO;//继续遍历
}];
</code></pre>

<h5 id="toc_8">动态数组NSMutableArray的add操作</h5>

<pre><code>    NSArray * array = [NSArray arrayWithObjects:@&quot;1&quot;,@&quot;2&quot;, nil];
    
    //方法一
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list addObjectsFromArray: array]];
    NSLog(@&quot;%@&quot;,list);//(1,2)
    
    //方法二arrayByAddingObjectsFromArray 该方法做了copy原数据不变
    NSMutableArray * list = [[NSMutableArray alloc]init];
    [list arrayByAddingObjectsFromArray: array]
    NSLog(@&quot;%@&quot;,list);//()
    
</code></pre>

<h5 id="toc_9">数组的简单操作</h5>

<pre><code>//插入索引为几的位置
[tempArr insertObject:@&quot;two&quot; atIndex:1];

//修改数组中第2个元素的内容
[tempArr replaceObjectAtIndex:2 withObject:@&quot;aaa&quot;];

//交换数组中得内容
[tempArr exchangeObjectAtIndex:1 withObjectAtIndex:3];

//取出连续范围的元素作为子集内容
NSArray *sub1 = [tempArr subarrayWithRange:NSMakeRange(1, 3)];
</code></pre>

<h5 id="toc_10">数组的删除操作</h5>

<pre><code>//1.删除最后一个元素
 [array removeLastObject];
 NSLog(@&quot;%@&quot;,array);

//2.删除指定下标的元素
[array removeObjectAtIndex:5];
 NSLog(@&quot;%@&quot;,array);

//3.直接删除元素
[array removeObject:@&quot;e&quot;];
 NSLog(@&quot;%@&quot;,array);
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC plist文件管理(代码方式)]]></title>
    <link href="www.freefook.com/15142856319824.html"/>
    <updated>2017-12-26T18:53:51+08:00</updated>
    <id>www.freefook.com/15142856319824.html</id>
    <content type="html"><![CDATA[
<pre><code>//获取本地沙盒路径
NSArray *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);

//获取完整路径
NSString *documentsPath = [path objectAtIndex:0];
NSString *plistPath = [documentsPath stringByAppendingPathComponent:@&quot;Test.plist&quot;];

//创建数据
NSMutableDictionary *dataDict = [NSMutableDictionary dictionary];

[dataDict setObject:@&quot;zhangd&quot; forKey:@&quot;name&quot;];
[dataDict setObject:@&quot;26&quot; forKey:@&quot;age&quot;];
[dataDict setObject:@&quot;man&quot; forKey:@&quot;sex&quot;];

//写入plist文件
[dataDict writeToFile:plistPath atomically:YES];

//读取plist文件
//文件是什么类型，就用什么类型的数据来接收
NSMutableDictionary *dataDict1 = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];
NSLog((@&quot;**start**\n[function name:%s]\n&quot; &quot;[Lines:%d]\n&quot; &quot;data-&gt;%@\n**end**\n\n&quot;), __FUNCTION__, __LINE__,dataDict1);

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 从AppDelegate说起]]></title>
    <link href="www.freefook.com/15142851543985.html"/>
    <updated>2017-12-26T18:45:54+08:00</updated>
    <id>www.freefook.com/15142851543985.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">创建程序窗口</h5>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
self.window.backgroundColor = [UIColor whiteColor];
[self.window setRootViewController:self.tabbarVC];
[self.window makeKeyAndVisible];
</code></pre>

<h5 id="toc_1">生命周期</h5>

<pre><code>- (void)applicationWillEnterForeground:(UIApplication *)application {
    NSLog(@&quot;将要进入前台：%s&quot;,__func__);
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    
    NSLog(@&quot;已经获得焦点：%s&quot;,__func__);
}

- (void)applicationWillResignActive:(UIApplication *)application {
    
    NSLog(@&quot;将要释放焦点：%s&quot;,__func__);
}
- (void)applicationWillTerminate:(UIApplication *)application {
    
    NSLog(@&quot;程序将要退出：%s&quot;,__func__);
}
- (void)applicationDidEnterBackground:(UIApplication *)application {
    
    NSLog(@&quot;已经进入后台：%s&quot;,__func__);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 基础使用说明]]></title>
    <link href="www.freefook.com/15139214660338.html"/>
    <updated>2017-12-22T13:44:26+08:00</updated>
    <id>www.freefook.com/15139214660338.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">pragma - mark - tableview列表初始化</h5>

<pre><code>-(UITableView *)tableView
{
    if (!_tableView) {
        
        _tableView = [[UITableView alloc]initWithFrame:
                      CGRectMake(, , , ) style:UITableViewStylePlain];
        _tableView.delegate = self;
        _tableView.dataSource = self;
        _tableView.backgroundColor = ;
        //分割线的颜色
        _tableView.separatorColor = ;
        //隐藏滚动条
        _tableView.showsVerticalScrollIndicator = NO;
        _tableView.tableFooterView = [[UIView alloc]init];
        
    }
    return _tableView;
}
</code></pre>

<h5 id="toc_1">tableview 代理方法实现如下：</h5>

<h6 id="toc_2">tableview解决常规配置的重复问题。。。</h6>

<pre><code>//当页面拉动需要显示新数据的时候，把最后一个cell进行删除 此方案即可避免重复显示，又重用了cell相对内存管理来说是好的方案 
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 定义唯一标识
    static NSString *CellIdentifier = @&quot;Cell&quot;;
    // 通过唯一标识创建cell实例
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    // 判断为空进行初始化  --（当拉动页面显示超过主页面内容的时候就会重用之前的cell，而不会再次初始化）
    if (!cell) {
        cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:CellIdentifier];
    }
    else//当页面拉动的时候 当cell存在并且最后一个存在 把它进行删除就出来一个独特的cell我们在进行数据配置即可避免
    {
        while ([cell.contentView.subviews lastObject] != nil) {
            [(UIView *)[cell.contentView.subviews lastObject] removeFromSuperview];
        }
    }
    
//点击没有选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;  

// 对cell 进行简单地数据配置
cell.textLabel.text = @&quot;text&quot;;
   
return cell;
}
</code></pre>

<h5 id="toc_3">other</h5>

<pre><code>//行
-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    
    return &lt;#@#&gt;;
}
//行高
-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    return &lt;#@#&gt;;
}

#pragma - mark - 点击cell方法

-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
    
}
</code></pre>

<h5 id="toc_4">tableview header与footer</h5>

<pre><code>#pragma - mark - tableview_Header and Footer

-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
    
    return 0;
}

-(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section
{
    UIView * view = [[UIView alloc]init];
    
    return view;
}

-(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section
{
    
    return 0;
    
}
</code></pre>

<p>tableview 侧滑删除方法</p>

<pre><code>//先要设Cell可编辑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    
    return NO;
}

//定义编辑样式
- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    return UITableViewCellEditingStyleDelete;
}

//修改编辑按钮文字
- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath {
    return @&quot;删除&quot;;
}

//设置进入编辑状态时，Cell不会缩进
- (BOOL)tableView: (UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath {
    return NO;
}

//点击删除
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    /**一定是先删除了数据，再执行删除的动画或者其他操作，否则会出现崩溃*/
    
    [self deleteData:indexPath];//单个删除接口
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS tableView 常用属性与方法]]></title>
    <link href="www.freefook.com/15142851756052.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851756052.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">tableview 常用属性如下：</h5>

<pre><code>//获取手势点击的是哪一个cell的坐标
NSIndexPath *indexPath = [self.tableView indexPathForCell:((UITableViewCell *)longPress.view)];

//点击button时获取button所在的cell的indexpath
UIButton *button = sender;
tempTableViewCell *cell = (tempTableViewCell *)[[button superview] superview];
NSIndexPath *indexPath = [_tableView indexPathForCell:cell];

//局部刷新一个section刷新    
NSIndexSet *indexSet=[[NSIndexSet alloc]initWithIndex:1];    
[tableview reloadSections:indexSet withRowAnimation:UITableViewRowAnimationAutomatic];    

//局部刷新一个cell刷新   
NSIndexPath *indexPath=[NSIndexPath indexPathForRow:1 inSection:0];   
[tableView reloadRowsAtIndexPaths:[NSArray arrayWithObjects:indexPath,nil] withRowAnimation:UITableViewRowAnimationNone]; 

//不显示分割线
_tableView.separatorStyle = UITableViewCellSeparatorStyleNone;

//显示箭头
cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;

//无选中状态
cell.selectionStyle = UITableViewCellSelectionStyleNone;

//自适应单元格高度
tableView.rowHeight = UITableViewAutomaticDimension; 
//先估计一个高度
tableView.estimatedRowHeight = 50; 
</code></pre>

<pre><code></code></pre>

<pre><code></code></pre>

<h5 id="toc_1">tableview 常用方法如下：</h5>

<h6 id="toc_2">tableview 选中第几行</h6>

<pre><code>NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView selectRowAtIndexPath:indexpath animated:YES scrollPosition:UITableViewScrollPositionMiddle];  //选中第5行
</code></pre>

<h6 id="toc_3">滚动到指定位置</h6>

<pre><code>//滚动到指定位置_偏移量
[self.rizhiTableView setContentOffset:CGPointMake(0, OffsetY) animated:NO];
//滚动到第几行
NSIndexPath *indexpath = [NSIndexPath indexPathForRow:0 inSection:0];
[self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionTop animated:NO];
</code></pre>

<h6 id="toc_4">pragma mark  - 滑到最底部</h6>

<pre><code>- (void)scrollTableToFoot
{
    
    dispatch_async(dispatch_get_main_queue(), ^{
        
        NSInteger s = [self.tableView numberOfSections];  //有多少组
        if (s&lt;1) return;  //无数据时不执行 要不会crash
        NSInteger r = [self.tableView numberOfRowsInSection:s-1]; //最后一组有多少行
        if (r&lt;1) return;
        NSIndexPath *indexpath = [NSIndexPath indexPathForRow:r-1 inSection:s-1];  //取最后一行数据
        [self.tableView scrollToRowAtIndexPath:indexpath atScrollPosition:UITableViewScrollPositionBottom animated:NO]; //滚动到最后一行
        
    });
  
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UICollectionView使用详解]]></title>
    <link href="www.freefook.com/15142851752080.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851752080.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">添加代理</h5>

<pre><code>&lt;UICollectionViewDataSource,UICollectionViewDelegate&gt;
</code></pre>

<h5 id="toc_1">初始化</h5>

<pre><code> UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
    flowLayout.minimumInteritemSpacing = 0;
    flowLayout.minimumLineSpacing = 0;
    flowLayout.sectionInset  = UIEdgeInsetsMake(0, 5, 0, 5);
    
_collectionView = [[UICollectionView alloc] initWithFrame:
CGRectMake(0, 0, self.view.frame.size.with,self.view.frame.size.height) 
collectionViewLayout:flowLayout];
    
    //一定要注册
    [_collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;colletionCell&quot;];
    [_collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;HeaderIdentifier&quot;];
    
    _collectionView.backgroundColor = [UIColor whiteColor];
    _collectionView.dataSource = self;
    _collectionView.delegate = self;
    
    _collectionView.alwaysBounceVertical = YES;
    _collectionView.showsVerticalScrollIndicator = NO;
    [self.view addSubview:_collectionView];
    
    if (@available(iOS 11.0, *)) {
    }else{
        self.automaticallyAdjustsScrollViewInsets = NO;
    }
</code></pre>

<h5 id="toc_2">设置_collectionView的组数</h5>

<pre><code>-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView
{
    return 3;
}
</code></pre>

<h5 id="toc_3">设置每组cell的个数</h5>

<pre><code>//返回每组的个数
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    if (section == 0) {
        return 3;
    }else if (section == 1){
        return 4;
    }else if (section == 2){
        return 3;
    }
    return 0;
} 

</code></pre>

<h5 id="toc_4">设置每组cell的大小</h5>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
    if (indexPath.section == 0) {
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
        
    }else if (indexPath.section == 1){
        return  CGSizeMake((KScreenWidth-10)/2, KScreenWidth/2+60);

    }else{
        return  CGSizeMake((KScreenWidth-10)/3, KScreenWidth/3+60);
    }
}
</code></pre>

<h5 id="toc_5">布局cell</h5>

<pre><code>- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    NSString *reuseIdetify = @&quot;colletionCell&quot;;
    
    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdetify forIndexPath:indexPath];
    
    cell.contentView.backgroundColor = [UIColor whiteColor];
    //这句是每次都移除view上的控件,从新添加的;
    [cell.contentView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];
    
    /***********布局cell*********/


    /***************************/ 
       
    return cell;
}
</code></pre>

<h5 id="toc_6">设置_collectionView头部header高度</h5>

<pre><code>- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section {
    
    if (section == 0) {
        CGSize size={KScreenWidth,cycHeight + 240};
        return size;
        
    }else if (section == 1){
        CGSize size={KScreenWidth,140};
        return size;

    }else{
        CGSize size={KScreenWidth,40};
        return size;

    }
}
</code></pre>

<h5 id="toc_7">布局_collectionView上的头部UI</h5>

<pre><code>- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView
           viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath
{
    
    UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader
                                                                            withReuseIdentifier:@&quot;HeaderIdentifier&quot;
                                                                                   forIndexPath:indexPath];

    [headView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];

    if (indexPath.section == 0) {
        
        if(kind ==UICollectionElementKindSectionHeader){
            
        }
     }
    
    return headView;
    
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS请求方式]]></title>
    <link href="www.freefook.com/15142851750375.html"/>
    <updated>2017-12-26T18:46:15+08:00</updated>
    <id>www.freefook.com/15142851750375.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">AFN请求</h5>

<pre><code> AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];
 
    //向服务器发送JSON形式的二进制数据
    sessionManager.requestSerializer = [AFJSONRequestSerializer serializer];
    //设置默认只返回原始的二进制数据,程序猿自己解析
    //manager.responseSerializer = [AFHTTPResponseSerializer serializer];
    
     //设置非校验证书模式
     manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];
     manager.securityPolicy.allowInvalidCertificates = YES;
    [manager.securityPolicy setValidatesDomainName:NO];
           
    sessionManager.requestSerializer.timeoutInterval = 10.f;
    sessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;,@&quot;text/javascript&quot;, @&quot;text/html&quot;, @&quot;text/plain&quot;,  nil];
    
   //设置请求头 参数
    [sessionManager.requestSerializer setValue:@&quot;Token&quot;] forHTTPHeaderField:@&quot;Authorization&quot;];
    
    [sessionManager POST:URLString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {
        
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        
    
     NSDictionary * dic=[[NetworkTool sharedNetworkTool] changeType: responseObject] ;
        
                
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        failure(error);
    }];
</code></pre>

<pre><code>-(id)changeType:(id)myObj
{
    if ([myObj isKindOfClass:[NSDictionary class]])
    {
        return [self nullDic:myObj];
    }
    else if([myObj isKindOfClass:[NSArray class]])
    {
        return [self nullArr:myObj];
    }
    else if([myObj isKindOfClass:[NSString class]])
    {
        return [self stringToString:myObj];
    }
    else if([myObj isKindOfClass:[NSNull class]])
    {
        return [self nullToString];
    }
    else
    {
        return myObj;
    }
}

//将NSDictionary中的Null类型的项目转化成@&quot;&quot;
-(NSDictionary *)nullDic:(NSDictionary *)myDic
{
    NSArray *keyArr = [myDic allKeys];
    NSMutableDictionary *resDic = [[NSMutableDictionary alloc]init];
    for (int i = 0; i &lt; keyArr.count; i ++)
    {
        id obj = [myDic objectForKey:keyArr[i]];
        obj = [self changeType:obj];
        [resDic setObject:obj forKey:keyArr[i]];
    }
    return resDic;
}

//将NSArray中的Null类型的项目转化成@&quot;&quot;
-(NSArray *)nullArr:(NSArray *)myArr
{
    NSMutableArray *resArr = [[NSMutableArray alloc] init];
    for (int i = 0; i &lt; myArr.count; i ++)
    {
        id obj = myArr[i];
        obj = [self changeType:obj];
        [resArr addObject:obj];
    }
    return resArr;
}

//将NSString类型的原路返回
-(NSString *)stringToString:(NSString *)string
{
    return string;
}

//将Null类型的项目转化成@&quot;&quot;
-(NSString *)nullToString
{
    return @&quot;&quot;;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS导航 与pop]]></title>
    <link href="www.freefook.com/15142851748774.html"/>
    <updated>2017-12-26T18:46:14+08:00</updated>
    <id>www.freefook.com/15142851748774.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">BaseVC里写入</h5>

<pre><code>    [self.navigationController.navigationBar setHidden:NO];
    
    UIBarButtonItem *backBtn = [[UIBarButtonItem alloc] init];
    backBtn.title = @&quot;&quot;;//返回
    self.navigationItem.backBarButtonItem = backBtn;
    self.navigationController.navigationBar.tintColor = [UIColor blackColor];
    
    [self.navigationController.navigationBar setBackgroundImage:[Helper imageWithColor:rgba(246, 246, 246, 1.0)] forBarMetrics:(UIBarMetricsDefault)];
    
    //设置字体大小和颜色
    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor blackColor],NSFontAttributeName:[UIFont systemFontOfSize:18]}];
    
</code></pre>

<h5 id="toc_1">移除navigationController.viewControllers 栈里的类</h5>

<pre><code> NSMutableArray*tempMarr =[NSMutableArray arrayWithArray:self.navigationController.viewControllers];
        NSMutableArray* temp = [[NSMutableArray alloc]init];
        for (int i = 0; i &lt; tempMarr.count; i++) {
            
            if ([tempMarr[i] isKindOfClass:[SubmitOrderViewController class]]) {
                [tempMarr removeObjectAtIndex:i];
                
            }else if ([tempMarr[i] isKindOfClass:[PayOrderViewController class]]) {
                [tempMarr removeObjectAtIndex:i];
                
            }else{
                [temp addObject:tempMarr[i]];
            }
        }
        [self.navigationController setViewControllers:temp animated:YES];
</code></pre>

<h5 id="toc_2">pop到navigationController栈里指定的页面</h5>

<pre><code> for (UIViewController *controller in self.navigationController.viewControllers) {
         if ([controller isKindOfClass:[ShopDetailViewController class]]) {
                    ShopDetailViewController *A =(ShopDetailViewController *)controller;
                    [self.navigationController popToViewController:A animated:YES];

         }
 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发说明]]></title>
    <link href="www.freefook.com/15139213651453.html"/>
    <updated>2017-12-22T13:42:45+08:00</updated>
    <id>www.freefook.com/15139213651453.html</id>
    <content type="html"><![CDATA[
<pre><code>what？

项目分配下来后，针对一些疑问的解释说明。
针对一些项目中开发事宜，做一些解释说明。
针对一些项目中重复代码，做一些记录，不管在哪个电脑，哪个项目，写的时候，可以copy。

why?

避免一些情况 “开发做了很多，布局调整导致缝缝补补的局面”。
所以有经验的开发人员总会说一句，就是“不管简单或复杂的页面，都不要写死了。
谁知道哪天甲方/产品说这里很简单，改一下吧，那个很简单，改一下吧”
如果你没时间改，那别给队友带刀啊。
所以统一规范，统一大块的思路，在程序中增加说明文件，减少上班带刀的同事，避免做地铁过安检的问题。

how?

建项开始:
1. 项目问题汇总
2. 建项使用三方管理工具cocoapods
3. 建项创建.pch文件
4. 建项那些.pch里写了些什么
5. 建项权限、网络问题
6. 建项屏幕适配问题
</code></pre>

<h4 id="toc_0">程序的“通用性”</h4>

<pre><code>用简单的代码去解决的问题，不要过分的关注了“通用性”，
“可维护性”和“可扩展性”，被搞得绕来绕去，让人琢磨不透。
不用装逼搞酷炫，不是在搞复杂性的东西，不要一个东西调了四五层去解决问题；
“考虑”到了通用性，并不等于你就准确地“把握”住了通用性；

如果在第一次的设计中就过早的考虑到将来，由此带来的多余的复杂性，
有可能让初期的设计就出现问题。所以这种对于将来的变化的考虑，实际上帮了倒忙。
尽量不要大段 大段的留下注释代码，留下以后说可能会用，
其实在打开注释用到的可能性有多少，少之又少。

代码需要被“重用”的场合，实际上比你想象的要少。所以尽可能的简单
因为简单的东西每个项目重复性的、大量的会去写，
所以有些东西，可以放在xcode 的代码块里；

最后不要极端的追求所谓“程序的正确性”畏首畏尾的写程序，
正确不等于直接，高效，放手写吧。。。

</code></pre>

<h4 id="toc_1">简单的编码中规范说明</h4>

<p>程序开始增加说明文件</p>

<pre><code>说明文件，记录项目功能实现的思维说明：
1.MVC  MVVM MVCS 等放荡不羁的模式
2.复杂UI的实现说明或使用了他人封装类库，注明使用方法示例；
3.网络请求方式，加密方式，部数据处理方式；
4.本地数据的存储方式
5.复杂业务逻辑的流程说明，与实现后遗留缺陷。
6.写出你认为程序中还遗留的缺陷， bug，改进，优化的地方
</code></pre>

<h4 id="toc_2">程序开发过程中命名方式</h4>

<blockquote>
<p>大家公认无岐义的缩写(比如：nav，bg，btn等)<br/>
写在哪些命名里都可以</p>
</blockquote>

<h5 id="toc_3">类命名：前缀+描述+类型</h5>

<pre><code>1.创建一个类时，增加自己名字首字母的简写例如：张东 ZDLoginViewController
2.ViewController 是处理业务逻辑，UI 代码 数据请求与处理 尽量不要写太多
3.view的生命周期的几个方法 在类中方法的最上方
4.类中方法增加Mark（#pragma - mark - 点击登录，请求登录接口 ）

</code></pre>

<h5 id="toc_4">属性命名：描述性单词+变量类型</h5>

<pre><code>UILabel* nameLabel;
</code></pre>

<h5 id="toc_5">方法命名</h5>

<pre><code>一个规范的方法读起来应该像一句完整的话，读过之后便知函数的作用。
返回性的方法应该以返回的内容开头，但之前不要加get。
不要各种缩写，写完猜不出意思。保持完整性

</code></pre>

<h5 id="toc_6">函数命名</h5>

<pre><code>一些典型操作应该使用约定的动词，如initWith,insert,remove,replace,add等等。
</code></pre>

<h5 id="toc_7">程序中使用的图片命名</h5>

<pre><code>在Assets.xcassets里创建相应使用的功能模块文件夹
例如：personalCenter 文件里放登录、注册、我的信息用到的图片
图片命名 类型+模块/功能 例如：btn/bg_login_normal@3x.png 
</code></pre>

<h5 id="toc_8">代码注释</h5>

<pre><code>代码的注释问题:很多人的注释过于粗糙,有些甚至都没有注释习惯,导致代码可读性差,
版本迭代或是需求变更的时候不能及时定位到具体代码；

注释方式例如：
/** 名字 */
@property(nonatomic,strong)NSString* name;

这样注释的好处是:
当你调用这个属性时会具有相关备注提示

</code></pre>

<h5 id="toc_9">代码中的循环与判断</h5>

<pre><code>在任何情况下 for 语句和 if 语句之后必须写花括号，
即使允许你在其只包含一行代码的时候可以省略
for (int i=0; i &lt; n; i++)
   function(i);
   
for (int i=0; i &lt; n; i++) {
   function(i);
 }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[建项-快速开发 1 ->TabBar]]></title>
    <link href="www.freefook.com/15142722458623.html"/>
    <updated>2017-12-26T15:10:45+08:00</updated>
    <id>www.freefook.com/15142722458623.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">学习优秀的封装</h4>

<p>CYLTabBarController</p>

<pre><code>【中国特色 TabBar】最低只需传两个数组即可完成主流App框架搭建【iPhoneX supported】 

 （转载 https://github.com/ChenYilong）

</code></pre>

<h5 id="toc_1">CYLTabBarController【低耦合集成TabBarController】</h5>

<h5 id="toc_2">集成后的效果：</h5>

<table>
<thead>
<tr>
<th>既支持默认样式</th>
<th>同时也支持创建自定义的形状不规则加号按钮</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i62.tinypic.com/rvcbit.jpg?192x251_130" alt="enter image description here"/></td>
<td><img src="http://i58.tinypic.com/24d4t3p.jpg?192x251_130" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>支持横竖屏<br/>
 <img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_3">使用<a href="https://github.com/ChenYilong/CYLTabBarController">CYLTabBarController</a></h4>

<p>四步完成主流App框架搭建：</p>

<ol>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8cocoapods%E5%AF%BC%E5%85%A5cyltabbarcontroller"> 第一步：使用CocoaPods导入CYLTabBarController </a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E8%AE%BE%E7%BD%AEcyltabbarcontroller%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8E%A7%E5%88%B6%E5%99%A8%E6%95%B0%E7%BB%84%E5%92%8Ctabbar%E5%B1%9E%E6%80%A7%E6%95%B0%E7%BB%84">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%B0%86cyltabbarcontroller%E8%AE%BE%E7%BD%AE%E4%B8%BAwindow%E7%9A%84rootviewcontroller">第三步：将CYLTabBarController设置为window的RootViewController</a> </li>
<li> <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E5%8F%AF%E9%80%89%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BD%A2%E7%8A%B6%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A0%E5%8F%B7%E6%8C%89%E9%92%AE">第四步（可选）：创建自定义的形状不规则加号按钮</a> </li>
</ol>

<h5 id="toc_4">第一步：省略使用CocoaPods导入CYLTabBarController</h5>

<h5 id="toc_5">第二步：设置CYLTabBarController的两个数组：控制器数组和TabBar属性数组</h5>

<pre><code class="language-Objective-C"> - (void)setupViewControllers {
    CYLHomeViewController *firstViewController = [[CYLHomeViewController alloc] init];
    UIViewController *firstNavigationController = [[UINavigationController alloc]
                                                   initWithRootViewController:firstViewController];
    
    CYLSameFityViewController *secondViewController = [[CYLSameFityViewController alloc] init];
    UIViewController *secondNavigationController = [[UINavigationController alloc]
                                                    initWithRootViewController:secondViewController];
    

    CYLTabBarController *tabBarController = [[CYLTabBarController alloc] init];
    [self customizeTabBarForController:tabBarController];
    
    [tabBarController setViewControllers:@[
                                           firstNavigationController,
                                           secondNavigationController,
                                           ]];
    self.tabBarController = tabBarController;
}

/*
 *
 在`-setViewControllers:`之前设置TabBar的属性，
 *
 */
- (void)customizeTabBarForController:(CYLTabBarController *)tabBarController {
    
    NSDictionary *dict1 = @{
                            CYLTabBarItemTitle : @&quot;首页&quot;,
                            CYLTabBarItemImage : @&quot;home_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;home_highlight&quot;,
                            };
    NSDictionary *dict2 = @{
                            CYLTabBarItemTitle : @&quot;同城&quot;,
                            CYLTabBarItemImage : @&quot;mycity_normal&quot;,
                            CYLTabBarItemSelectedImage : @&quot;mycity_highlight&quot;,
                            };

    NSArray *tabBarItemsAttributes = @[ dict1, dict2 ];
    tabBarController.tabBarItemsAttributes = tabBarItemsAttributes;
}
</code></pre>

<p>在这个字典中，<code>CYLTabBarItemImage</code> 和 <code>CYLTabBarItemSelectedImage</code> 支持 <code>NSString</code>、<code>UIImage</code><br/>
两种格式。<code>CYLTabBarItemTitle</code> 不设置将只展示图标，并会对布局作出居中处理。</p>

<h5 id="toc_6">第三步：将CYLTabBarController设置为window的RootViewController</h5>

<pre><code class="language-Objective-C"> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window setRootViewController:self.tabBarController];
 /* *省略部分：   * */
    return YES;
}
</code></pre>

<h5 id="toc_7">第四步（可选）：创建自定义的形状不规则加号按钮</h5>

<p>创建一个继承于 CYLPlusButton 的类，要求和步骤：</p>

<ol>
<li><p>实现  <code>CYLPlusButtonSubclassing</code>  协议 </p></li>
<li><p>子类将自身类型进行注册，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C">+ (void)load {
[super registerPlusButton];
}
</code></pre></li>
</ol>

<p>协议提供了可选方法：</p>

<pre><code class="language-Objective-C">+ (NSUInteger)indexOfPlusButtonInTabBar;
+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
+ (UIViewController *)plusChildViewController;
+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>作用分别是：</p>

<pre><code class="language-Objective-C"> + (NSUInteger)indexOfPlusButtonInTabBar;
</code></pre>

<p>用来自定义加号按钮的位置，如果不实现默认居中，但是如果 <code>tabbar</code> 的个数是奇数则必须实现该方法，否则 <code>CYLTabBarController</code> 会抛出 <code>exception</code> 来进行提示。</p>

<p>主要适用于如下情景：</p>

<p><img src="http://a64.tinypic.com/2mo0h.jpg" alt="enter image description here"/></p>

<p>Airbnb-app效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<pre><code class="language-Objective-C">+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>该方法是为了调整自定义按钮中心点Y轴方向的位置，建议在按钮超出了 <code>tabbar</code> 的边界时实现该方法。返回值是自定义按钮中心点Y轴方向的坐标除以 <code>tabbar</code> 的高度，如果不实现，会自动进行比对，预设一个较为合适的位置，如果实现了该方法，预设的逻辑将失效。</p>

<p>内部实现时，会使用该返回值来设置 PlusButton 的 centerY 坐标，公式如下：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说：如果 constantOfPlusButtonCenterYOffset 为0，同时 multiplierOfTabBarHeight 的值是0.5，表示 PlusButton 居中，小于0.5表示 PlusButton 偏上，大于0.5则表示偏下。</p>

<pre><code class="language-Objective-C">+ (CGFloat)constantOfPlusButtonCenterYOffsetForTabBarHeight:(CGFloat)tabBarHeight;
</code></pre>

<p>参考 <code>+multiplierOfTabBarHeight:</code> 中的公式：</p>

<p><code>PlusButtonCenterY = multiplierOfTabBarHeight * taBarHeight + constantOfPlusButtonCenterYOffset;</code></p>

<p>也就是说： constantOfPlusButtonCenterYOffset 大于0会向下偏移，小于0会向上偏移。</p>

<p>注意：实现了该方法，但没有实现 <code>+multiplierOfTabBarHeight:</code> 方法，在这种情况下，会在预设逻辑的基础上进行偏移。</p>

<p>详见Demo中的 <code>CYLPlusButtonSubclass</code> 类的实现。</p>

<pre><code class="language-Objective-C">+ (UIViewController *)plusChildViewController;
</code></pre>

<p>详见： <a href="https://github.com/ChenYilong/CYLTabBarController#%E7%82%B9%E5%87%BB-plusbutton-%E8%B7%B3%E8%BD%AC%E5%88%B0%E6%8C%87%E5%AE%9A-uiviewcontroller">点击 PlusButton 跳转到指定 UIViewController</a> </p>

<p>另外，如果加号按钮超出了边界，一般需要手动调用如下代码取消 tabbar 顶部默认的阴影，可在 AppDelegate 类中调用：</p>

<pre><code class="language-Objective-C">    //去除 TabBar 自带的顶部阴影
    [[UITabBar appearance] setShadowImage:[[UIImage alloc] init]];        
</code></pre>

<p>// iOS10 后 需要使用 <code>-[CYLTabBarController hideTabBadgeBackgroundSeparator]</code> 见 AppDelegate 类中的演示;</p>

<p>如何调整、自定义 <code>PlusButton</code> 与其它 <code>TabBarItem</code> 的宽度？</p>

<p><code>CYLTabBarController</code> 规定：</p>

<pre><code class="language-Objective-C"> TabBarItem 宽度 ＝  ( TabBar 总宽度 －  PlusButton 宽度  ) / (TabBarItem 个数)
</code></pre>

<p>所以想自定义宽度，只需要修改 <code>PlusButton</code> 的宽度即可。</p>

<p>比如你就可以在 Demo中的 <code>CYLPlusButtonSubclass.m</code> 类里：</p>

<p>把</p>

<pre><code class="language-Objective-C"> [button sizeToFit]; 
</code></pre>

<p>改为</p>

<pre><code class="language-Objective-C"> button.frame = CGRectMake(0.0, 0.0, 250, 100);
 button.backgroundColor = [UIColor redColor];
</code></pre>

<p>效果如下，<br/>
1.17.4<br/>
<img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>同时你也可以顺便测试下 <code>CYLTabBarController</code> 的这一个特性：</p>

<blockquote>
<p>即使加号按钮超出了tabbar的区域，超出部分依然能响应点击事件</p>
</blockquote>

<p>并且你可以在项目中的任意位置读取到 <code>PlusButton</code> 的宽度，借助 <code>CYLTabBarController.h</code> 定义的 <code>CYLPlusButtonWidth</code> 这个extern。可参考 <code>+[CYLTabBarControllerConfig customizeTabBarAppearance:]</code> 里的用法。</p>

<h3 id="toc_8">补充说明</h3>

<h4 id="toc_9">自定义 <code>TabBar</code> 样式</h4>

<p>如果想更进一步的自定义 <code>TabBar</code> 样式可在 <code>-application:didFinishLaunchingWithOptions:</code> 方法中设置</p>

<pre><code class="language-Objective-C"> /**
 *  tabBarItem 的选中和不选中文字属性、背景图片
 */
- (void)customizeInterface {
    
    // 普通状态下的文字属性
    NSMutableDictionary *normalAttrs = [NSMutableDictionary dictionary];
    normalAttrs[NSForegroundColorAttributeName] = [UIColor grayColor];
    
    // 选中状态下的文字属性
    NSMutableDictionary *selectedAttrs = [NSMutableDictionary dictionary];
    selectedAttrs[NSForegroundColorAttributeName] = [UIColor darkGrayColor];
    
    // 设置文字属性
    UITabBarItem *tabBar = [UITabBarItem appearance];
    [tabBar setTitleTextAttributes:normalAttrs forState:UIControlStateNormal];
    [tabBar setTitleTextAttributes:selectedAttrs forState:UIControlStateSelected];
    
    // 设置背景图片
    UITabBar *tabBarAppearance = [UITabBar appearance];
    [tabBarAppearance setBackgroundImage:[UIImage imageNamed:@&quot;tabbar_background&quot;]];
}

 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 /* *省略部分：   * */
    [self.window makeKeyAndVisible];
    [self customizeInterface];
    return YES;
}
</code></pre>

<h4 id="toc_10">捕获 TabBar 点击事件</h4>

<p>实现 CYLTabBarController 的如下几个代理方法即可捕获点击事件。 </p>

<p>下面这个方法能捕获当前点击的 <code>TabBar</code> 上的控件，可以是 <code>UITabBarButton</code>、也可以 <code>PlusButton</code>、也可以是添加到 <code>TabBar</code> 上的任意 <code>UIControl</code> 的子类。但是如果 <code>PlusButton</code> 也添加了点击事件，那么点击 <code>PlusButton</code> 将不会被触发这个代理方法。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 * @attention If PlusButton also add an action, then this delegate method will not be invoked when the PlusButton is selected.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>下面这个方法能捕获跳转前所在的控制器，以及跳转到的目标控制器。</p>

<pre><code class="language-Objective-C">//UITabBarController.h
@protocol UITabBarControllerDelegate &lt;NSObject&gt;
@optional
- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController NS_AVAILABLE_IOS(3_0);
@end

</code></pre>

<p>注意：在调用该方法时应该始终调用<br/>
<code>[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];</code> 来确保 <code>PlusButton</code> 的选中状态。示例如下：</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
    [[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
    return YES;
}
</code></pre>

<p>相关用法已经在 Demo 中展示。</p>

<p>遵循协议的方式如下：</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //...
        tabBarControllerConfig.tabBarController.delegate = self;
    //...
    return YES;
}
</code></pre>

<h4 id="toc_11">点击 TabBarButton 时添加动画</h4>

<p>Demo 演示的效果图：</p>

<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fg9hu6qnwbg308v0gctcc.gif" alt=""/></p>

<p>实现如下代理方法，就能得到对应的选中控件，可以在控件上直接添加动画。</p>

<pre><code class="language-Objective-C">//CYLTabBarController.h

@protocol CYLTabBarControllerDelegate &lt;NSObject&gt;

/*!
 * @param tabBarController The tab bar controller containing viewController.
 * @param control Selected UIControl in TabBar.
 */
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control;

@end

</code></pre>

<p>Demo 中示例代码如下：</p>

<p>遵循协议</p>

<pre><code class="language-Objective-C">@interface AppDelegate ()&lt;UITabBarControllerDelegate, CYLTabBarControllerDelegate&gt;

@end
</code></pre>

<pre><code class="language-Objective-C"> //AppDelegate.m
- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control {
    UIView *animationView;
    // 如果 PlusButton 也添加了点击事件，那么点击 PlusButton 后不会触发该代理方法。
    if ([control isKindOfClass:[CYLExternPlusButton class]]) {
        UIButton *button = CYLExternPlusButton;
        animationView = button.imageView;
    } else if ([control isKindOfClass:NSClassFromString(@&quot;UITabBarButton&quot;)]) {
        for (UIView *subView in control.subviews) {
            if ([subView isKindOfClass:NSClassFromString(@&quot;UITabBarSwappableImageView&quot;)]) {
                animationView = subView;
            }
        }
    }
    
    if ([self cyl_tabBarController].selectedIndex % 2 == 0) {
        [self addScaleAnimationOnView:animationView];
    } else {
        [self addRotateAnimationOnView:animationView];
    }
}

//缩放动画
- (void)addScaleAnimationOnView:(UIView *)animationView {
    //需要实现的帧动画，这里根据需求自定义
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;transform.scale&quot;;
    animation.values = @[@1.0,@1.3,@0.9,@1.15,@0.95,@1.02,@1.0];
    animation.duration = 1;
    animation.calculationMode = kCAAnimationCubic;
    [animationView.layer addAnimation:animation forKey:nil];
}

//旋转动画
- (void)addRotateAnimationOnView:(UIView *)animationView {
    [UIView animateWithDuration:0.32 delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{
        animationView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
    } completion:nil];
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        [UIView animateWithDuration:0.70 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0.2 options:UIViewAnimationOptionCurveEaseOut animations:^{
            animationView.layer.transform = CATransform3DMakeRotation(2 * M_PI, 0, 1, 0);
        } completion:nil];
    });
}
</code></pre>

<h4 id="toc_12">横竖屏适配</h4>

<p><code>TabBar</code> 横竖屏适配时，如果你添加了 <code>PlusButton</code>，且适配时用到了 <code>TabBarItem</code> 的宽度, 不建议使用系统的<code>UIDeviceOrientationDidChangeNotification</code> , 请使用库里的 <code>CYLTabBarItemWidthDidChangeNotification</code> 来更新 <code>TabBar</code> 布局，最典型的场景就是，根据 <code>TabBarItem</code> 在不同横竖屏状态下的宽度变化来切换选中的<code>TabBarItem</code> 的背景图片。Demo 里 <code>CYLTabBarControllerConfig.m</code> 给出了这一场景的用法:</p>

<p><code>CYLTabBarController.h</code>  中提供了 <code>CYLTabBarItemWidth</code> 这一extern常量，并且会在 <code>TabBarItem</code> 的宽度发生变化时，及时更新该值，所以用法就如下所示：</p>

<pre><code class="language-Objective-C">- (void)updateTabBarCustomizationWhenTabBarItemWidthDidUpdate {
    void (^deviceOrientationDidChangeBlock)(NSNotification *) = ^(NSNotification *notification) {
        [self tabBarItemWidthDidUpdate];
};
    [[NSNotificationCenter defaultCenter] addObserverForName:CYLTabBarItemWidthDidChangeNotification
                                                      object:nil
                                                       queue:[NSOperationQueue mainQueue]
                                                  usingBlock:deviceOrientationDidChangeBlock];
}

- (void)tabBarItemWidthDidUpdate {
    UIDeviceOrientation orientation = [[UIDevice currentDevice] orientation];
    if ((orientation == UIDeviceOrientationLandscapeLeft) || (orientation == UIDeviceOrientationLandscapeRight)) {
        NSLog(@&quot;Landscape Left or Right !&quot;);
    } else if (orientation == UIDeviceOrientationPortrait){
        NSLog(@&quot;Landscape portrait!&quot;);
    }
    CGSize selectionIndicatorImageSize = CGSizeMake(CYLTabBarItemWidth, [self cyl_tabBarController].tabBar.bounds.size.height);
    [[self cyl_tabBarController].tabBar setSelectionIndicatorImage:[[self class]
                                                                    imageFromColor:[UIColor yellowColor]
                                                                    forSize:selectionIndicatorImageSize
                                                                    withCornerRadius:0]];
}
</code></pre>

<p><img src="http://i67.tinypic.com/2u4snk7.jpg" alt="enter image description here"/></p>

<h4 id="toc_13">访问初始化好的 CYLTabBarController 对象</h4>

<p>对于任意 <code>NSObject</code> 对象：</p>

<p><code>CYLTabBarController.h</code>  中为 <code>NSObject</code> 提供了分类方法 <code>-cyl_tabBarController</code> ，所以在任意对象中，一行代码就可以访问到一个初始化好的  <code>CYLTabBarController</code>  对象，<code>-cyl_tabBarController</code> 的作用你可以这样理解：与获取单例对象的  <code>+shareInstance</code> 方法作用一样。</p>

<p>接口如下：</p>

<pre><code class="language-Objective-C">// CYLTabBarController.h

@interface NSObject (CYLTabBarController)

/**
 * If `self` is kind of `UIViewController`, this method will return the nearest ancestor in the view controller hierarchy that is a tab bar controller. If `self` is not kind of `UIViewController`, it will return the `rootViewController` of the `rootWindow` as long as you have set the `CYLTabBarController` as the  `rootViewController`. Otherwise return nil. (read-only)
 */
@property (nonatomic, readonly) CYLTabBarController *cyl_tabBarController;

@end
</code></pre>

<p>用法：</p>

<pre><code class="language-Objective-C">//导入 CYLTabBarController.h
#import &quot;CYLTabBarController.h&quot;

- (void)viewDidLoad {
    [super viewDidLoad];
    CYLTabBarController *tabbarController = [self cyl_tabBarController];
    /*...*/
}
</code></pre>

<h4 id="toc_14">点击 PlusButton 跳转到指定 UIViewController</h4>

<p>提供了一个协议方法来完成本功能：</p>

<p><img src="http://i68.tinypic.com/2who9rs.jpg" alt="enter image description here"/></p>

<p>实现该方法后，能让 PlusButton 的点击效果与跟点击其他 TabBar 按钮效果一样，跳转到该方法指定的 UIViewController 。</p>

<p>注意：必须同时实现 <code>+indexOfPlusButtonInTabBar</code> 来指定 PlusButton 的位置。</p>

<p>遵循几个协议：</p>

<p><img src="http://i64.tinypic.com/14jw5zt.jpg" alt="enter image description here"/></p>

<p>另外你可以通过下面这个方法获取到 <code>PlusButton</code> 的点击事件：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController;
</code></pre>

<p>用法如下：</p>

<pre><code class="language-Objective-C">+ (BOOL)shouldSelectPlusChildViewController {
    BOOL isSelected = CYLExternPlusButton.selected;
    if (isSelected) {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is selected&quot;);
    } else {
        NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;PlusButton is not selected&quot;);
    }
    return YES;
}

</code></pre>

<h4 id="toc_15">让TabBarItem仅显示图标，并使图标垂直居中</h4>

<p>要想实现该效果，只需要在设置 <code>tabBarItemsAttributes</code>该属性时不传 title 即可。</p>

<p>比如：在Demo的基础上，注释掉图中红框部分：<br/>
<img src="http://i64.tinypic.com/2cwu8ok.jpg" alt="enter image description here"/></p>

<table>
<thead>
<tr>
<th>注释前</th>
<th>注释后</th>
</tr>
</thead>

<tbody>
<tr>
<td><img src="http://i66.tinypic.com/2z3rj0z.jpg" alt="enter image description here"/></td>
<td><img src="http://i65.tinypic.com/29cp1r9.jpg" alt="enter image description here"/></td>
</tr>
</tbody>
</table>

<p>可以通过这种方式来达到 Airbnb-app 的效果：</p>

<p><img src="http://a63.tinypic.com/2mgk02v.gif" alt="enter image description here"/></p>

<p>如果想手动设置偏移量来达到该效果：<br/>
可以在 <code>-setViewControllers:</code> 方法前设置 <code>CYLTabBarController</code> 的 <code>imageInsets</code> 和 <code>titlePositionAdjustment</code> 属性</p>

<p>这里注意：设置这两个属性后，<code>TabBar</code> 中所有的 <code>TabBarItem</code> 都将被设置。并且第一种做法的逻辑将不会执行，也就是说该做法优先级要高于第一种做法。</p>

<p>做法如下：<br/>
<img src="http://i66.tinypic.com/4rq8ap.jpg" alt="enter image description here"/></p>

<p>但是想达到Airbnb-app的效果只有这个接口是不行的，还需要自定义下 <code>TabBar</code> 的高度，你需要设置 <code>CYLTabBarController</code> 的 <code>tabBarHeight</code> 属性。你可以在Demo的 <code>CYLTabBarControllerConfig.m</code> 中的 <code>-customizeTabBarAppearance:</code> 方法中设置。</p>

<p>注：“仅显示图标，并使图标垂直居中”这里所指的“图标”，其所属的类是私有类： <code>UITabBarSwappableImageView</code>，所以 <code>CYLTabBarController</code> 在相关的接口命名时会包含 <code>SwappableImageView</code> 字样。另外，使用该特性需要 <code>pod update</code> 到 1.5.5以上的版本。</p>

<h4 id="toc_16">多TabBar嵌套，并指定PlusButton位置</h4>

<p>该功能的版本需要 &gt;= v1.17.4。</p>

<p>效果图：</p>

<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fmn3005isfg308r0iltl6.gif" alt="enter image description here"/></p>

<p>实现 PlusButton 的如下协议方法指定 context：</p>

<pre><code class="language-Objective-C">//CYLPlusButtonSubclassing
+ (NSString *)tabBarContext;

</code></pre>

<p>当该值与 TabBarController 的 context 能够匹配上，PlusButton 将会展示。如果 PlusButton 与 TabBarController 均未制定 context 值，那么默认 context 值是相等的。</p>

<p>目前仅支持一个 PlusButton 展示一次，不限层级。如果与多个 TabBarController 的 context 能够匹配上，仅展示在最先一次的匹配上的 TabBarController 上。</p>

<h4 id="toc_17">在 Swift 项目中使用 CYLTabBarController</h4>

<p>仓库中给出了一个Swift Demo，文件夹叫做 Example-Swift。</p>

<p>具体的编写步骤参考热心网友提供的教程： <a href="http://www.jianshu.com/p/c5bc2eae0f55?nomobile=yes">《从头开始swift2.1 仿搜材通项目（三） 主流框架Tabbed的搭建》</a> </p>

<p>这里注意，文章的示例代码有问题，少了设置 PlusButton 大小的代码：<br/>
这将导致 PlusButton 点击事件失效，具体修改代码如下：<br/>
<img src="http://i67.tinypic.com/118ottv.jpg" alt="enter image description here"/></p>

<h4 id="toc_18">搭配 Storyboard 使用 CYLTabBarController</h4>

<p><a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor">这里</a> ，里面有个文件夹CYLTabBarControllerTestDemo，这个Demo演示了如何搭配 Storyboard 使用。</p>

<h4 id="toc_19">源码实现原理</h4>

<p>参考： <a href="http://www.jianshu.com/p/8758d8014f86">《[Note] CYLTabBarController》</a> </p>

<p>更多文档信息可查看 <a href="http://cocoadocs.org/docsets/CYLTabBarController/1.2.1/index.html"> <strong><em>CocoaDocs：CYLTabBarController</em></strong> </a> 。</p>

<h3 id="toc_20">FAQ</h3>

<p>更多Q-A内容，可以在这里查看： <a href="https://github.com/ChenYilong/CYLTabBarController/issues?utf8=%E2%9C%93&amp;q=+label%3AQ-A+">issue-FAQ</a> <br/>
Q：为什么放置6个TabBarItem会显示异常？</p>

<p>A：</p>

<p>Apple 规定：</p>

<blockquote>
<p>一个 <code>TabBar</code> 上只能出现最多5个 <code>TabBarItem</code> ，第六个及更多的将不被显示。</p>
</blockquote>

<p>另外注意，Apple检测的是 <code>UITabBarItem</code> 及其子类，所以放置“加号按钮”，这是 <code>UIButton</code> 不在“5个”里面。</p>

<p>最多只能添加5个 <code>TabBarItem</code> ，也就是说加上“加号按钮”，一共最多在一个 <code>TabBar</code> 上放置6个控件。否则第6个及之后出现 <code>TabBarItem</code> 会被自动屏蔽掉。而且就Apple的审核机制来说，超过5个也会被直接拒绝上架。</p>

<p>Q：我把 demo 两侧的 item 各去掉一个后，按钮的响应区域就变成下图的样子了：<br/>
 <img src="https://cloud.githubusercontent.com/assets/12152553/10725491/62600172-7c07-11e5-9e0a-0ec7d795d1e3.jpeg" alt="wechat_1445851872"/></p>

<p>A：v1.5.5 版本已经修复了该问题，现在不会出现类似的问题了：点击按钮区域却不响应，响应区域有偏移。</p>

<p>Q： 如何实现添加选中背景色的功能 ，像下面这样：<br/>
<img width="409" alt="screen shot 2015-10-28 at 9 21 56 am" src="https://cloud.githubusercontent.com/assets/7238866/10777333/5d7811c8-7d55-11e5-88be-8cb11bbeaf90.png"></p>

<p>A：我已经在 Demo 中添加了如何实现该功能的代码：<br/>
详情见 <code>CYLTabBarControllerConfig</code>  类中下面方法的实现：</p>

<pre><code class="language-Objective-C">/**
 *  更多TabBar自定义设置：比如：tabBarItem 的选中和不选中文字和背景图片属性、tabbar 背景图片属性
 */
- (void)customizeTabBarAppearance:(CYLTabBarController *)tabBarController;

</code></pre>

<p>效果如下：<br/>
<img src="https://cloud.githubusercontent.com/assets/2911921/10779397/34956b0a-7d6b-11e5-82d9-fa75aa34e8d0.png" alt="simulator screen shot 2015 10 28 11 44 32"/></p>

<p>Q: 当 <code>ViewController</code> 设置的 <code>self.title</code> 和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候，会出现如图的错误，排序不对了</p>

<p>A：在 v1.0.7 版本中已经修复了该 bug，但是也需要注意：</p>

<p>请勿使用 <code>self.title = @&quot;同城&quot;;</code> 这种方式，请使用 <code>self.navigationItem.title = @&quot;同城&quot;;</code> </p>

<p><code>self.title = @&quot;同城&quot;;</code> 这种方式，如果和 <code>tabBarItemsAttributes</code> 中对应的 <code>title</code> 不一致的时候可能会导致如下现象（不算 bug，但看起来也很奇怪）：</p>

<p><img src="http://i68.tinypic.com/282l3x4.jpg" alt="enter image description here"/></p>

<p>规则如下：</p>

<pre><code class="language-Objective-C">
    self.navigationItem.title = @&quot;同城&quot;;    //✅sets navigation bar title.The right way to set the title of the navigation
    self.tabBarItem.title = @&quot;同城23333&quot;;   //❌sets tab bar title. Even the `tabBarItem.title` changed, this will be ignored in  tabbar.
    self.title = @&quot;同城1&quot;;                  //❌sets both of these. Do not do this‼️‼️ This may cause something strange like this : http://i68.tinypic.com/282l3x4.jpg 

</code></pre>

<p>Q :  当使用这个方法时 <code>-[UIViewController cyl_popSelectTabBarChildViewControllerAtIndex:]</code> 系列方法时，会出现如下的黑边问题。</p>

<p><img src="http://i63.tinypic.com/bg766g.jpg" alt="enter image description here"/></p>

<p>A： 这个是 iOS 系统的BUG，经测试iOS9.3已经修复了，如果在更早起版本中出现了，可以通过下面将 <code>rootWindow</code> 的背景色改为白色来避免：比如你可以 <code>Appdelegate</code> 类里这样设置：</p>

<pre><code class="language-Objective-C">//#import &quot;CYLTabBarController.h&quot;
    [[self cyl_tabBarController] rootWindow].backgroundColor = [UIColor whiteColor];
</code></pre>

<p>Q:我现在已经做好了一个比较简单的中间凸起的 icon 但是超过了49这个高度的位置是不能效应的  我想请问你的demo哪个功能是可以使我超出的范围也可以响应的呢?</p>

<p>A: 这个是自动做的，但是 <code>CYLTabBarController</code> 只能保证的是：只要是 <code>UIButton</code> 的 frame 区域内就能响应。</p>

<p>请把 button 的背景颜色设置为显眼的颜色，比如红色，比如像下面的plus按钮，红色部分是能接收点击事件的，但是超出了红色按钮的，黄色的图片区域，依然是无法响应点击事件的。</p>

<p><img src="http://i64.tinypic.com/vx16r5.jpg" alt="enter image description here"/></p>

<p>这是因为，在响应链上，<code>UIControl</code> 能响应点击事件， <code>UIImage</code> 无法响应。</p>

<p>Q：为什么在iOS10上会Crash，iOS9上不会？</p>

<p>A：<br/>
  在注册加号按钮时，需要在 <code>-application:didFinishLaunchingWithOptions:</code> 方法里面调用 <code>[YourClass registerPlusButton]</code> </p>

<p>这里注意，不能在子类的 <code>+load</code> 方法中调用，比如像下面这样做，在 iOS10 系统上有 Crash 的风险：</p>

<pre><code class="language-Objective-C"> + (void)load {
    [super registerPlusButton];
}
</code></pre>

<p>Q: 我的样式是点击 <code>plusButton</code> 后跳转到一个 <code>ViewController</code>，但是选中了一次中间的 <code>plusButton</code> 之后，再点别的 <code>tabItem</code> ，中间不会变成 <code>normal</code> 的状态。</p>

<p>A: 有两种情况会造成这个问题：</p>

<ol>
<li><p>应该是你的 <code>tabBar</code> 设置了 <code>delegate</code> 了，你要是 <code>tabBar</code> 的代理没设置的话，默认会有这个 <code>selected</code> 状态切换的处理。你设置代理后，会覆盖我的行为。所以手动加上就好了。</p>

<pre><code class="language-Objective-C">- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
[[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
return YES;
}
</code></pre></li>
<li><p><code>plusButton</code> 添加了自定义点击事件或者自定义手势，因为这样会造成点击事件冲突或手势冲突，当需要 <code>pushViewController</code> 的时候，这个库会自动的添加点击事件，你这里重新加了点击事件所以冲突了；</p>

<p>在你项目的基础，把 <code>plusButton</code> 的点击事件取消掉,也就是 <code>addTarget</code> 这一行注释掉，手势事件也同理，应该就ok了</p></li>
</ol>

<p>A: <code>PlusButton</code> 与其他的 <code>TabBarItem</code> 距离没有平均分布 </p>

<p>(对应于 <a href="https://github.com/ChenYilong/CYLTabBarController/issues/36#issuecomment-269165471">issue#36</a> )</p>

<p>把这 Demo 里的这一行代码改下：</p>

<pre><code class="language-Objective-C">[button sizeToFit];
</code></pre>

<p>改成：</p>

<pre><code class="language-Objective-C">button.frame = CGRectMake(0.0, 0.0, w, h);
</code></pre>

<p>那么如果单是放一个照相机的图片，一般是多大的尺寸？</p>

<p>这个要看设计图，通常情况下，你可以写死与其他TabBarItem一样大小：</p>

<pre><code class="language-Objective-C"> [UIScreen mainScreen].bounds.size.width / [CYLTabBarController allItemsInTabBarCount]
</code></pre>

<hr/>

<p>Posted by <a href="http://weibo.com/luohanchenyilong/">微博@iOS程序犭袁</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[项目问题汇总]]></title>
    <link href="www.freefook.com/15139392949146.html"/>
    <updated>2017-12-22T18:41:34+08:00</updated>
    <id>www.freefook.com/15139392949146.html</id>
    <content type="html"><![CDATA[
<h5 id="toc_0">遇到的小问题却忽略的必然问题项如下：</h5>

<h6 id="toc_1">不明确问题：</h6>

<ol>
<li>项目都有哪些功能？不明确？</li>
<li>适配的系统与屏幕大小？</li>
<li>是否需要检测网络，无网络或者无数据页面如何处理？</li>
<li>例如：显示无数据页面，点击按钮重新请求？</li>
<li>某些数据内容展示不开时：显示一行即可/多行？</li>
<li>提示语的说明?</li>
<li>本地数据存储是否多？</li>
<li>业务复杂逻辑流程图？各端统一，麻烦也要统一做。</li>
</ol>

<h6 id="toc_2">不明确的功能项：</h6>

<ol>
<li>列表 tableview 是否有动态行高？</li>
<li>哪些是必须登录才可看的页面？</li>
<li>登录后是否有页面乱push 与pop 的情况？</li>
<li>热点问题是否有适配的价值，例如：京东曾不适配。</li>
</ol>

<h6 id="toc_3">必须有的功能项：</h6>

<ol>
<li>网络请求的日志信息，如何处理?和接口人员商议</li>
<li>需要增加闪退统计例如：集成极光。</li>
</ol>

<h6 id="toc_4">接口问题：</h6>

<ol>
<li>有通知功能时登录接口不是必传通知获取的token/channel_id？</li>
<li>接口返回问题返回数组的时候是空数组，还是空对象？</li>
</ol>

<h6 id="toc_5">UI问题:</h6>

<ol>
<li>设计图是根据多大屏幕作图？</li>
<li>不规则切图用规则型的透明背景切图.</li>
<li>如tabbar底部选项卡的图，大小统一.</li>
<li>个人中心等同位置图标 大小统一.</li>
</ol>

<p>以上问题会在下面 建项的各个阶段给出处理方式；</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发辅助地址一览]]></title>
    <link href="www.freefook.com/15142827596143.html"/>
    <updated>2017-12-26T18:05:59+08:00</updated>
    <id>www.freefook.com/15142827596143.html</id>
    <content type="html"><![CDATA[
<p>App Store<br/>
<a href="https://developer.apple.com/cn/app-store/">https://developer.apple.com/cn/app-store/</a></p>

<p>iTunes Connect 开发者指南<br/>
<a href="https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/OverviewofiTunesConnect.html#//apple_ref/doc/uid/TP40016325-CH12-SW1">https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide_zh_CN/Chapters/OverviewofiTunesConnect.html#//apple_ref/doc/uid/TP40016325-CH12-SW1</a></p>

<p>在线批量剪裁各种尺寸iOS、Android APP LOGO图标<br/>
<a href="http://www.atool.org/ios_logo.php">http://www.atool.org/ios_logo.php</a></p>

<p>json验证<br/>
<a href="http://www.json.cn/">http://www.json.cn/</a></p>

<p>极光推送：<br/>
<a href="https://docs.jiguang.cn/jpush/client/iOS/ios_sdk/">https://docs.jiguang.cn/jpush/client/iOS/ios_sdk/</a></p>

<p>接入支付宝支付：<br/>
<a href="https://docs.open.alipay.com/204/105295/">https://docs.open.alipay.com/204/105295/</a></p>

<p>接入微信支付：<br/>
<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5">https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_5</a></p>

<p>三方发布平台，蒲公英与firim<br/>
<a href="https://fir.im/">https://fir.im/</a><br/>
<a href="https://www.pgyer.com/">https://www.pgyer.com/</a></p>

<p>RabbitMQ 中文文档<br/>
<a href="http://rabbitmq.mr-ping.com/">http://rabbitmq.mr-ping.com/</a></p>

<p>网络请求及各类错误代码含义总结(Errors Code)<br/>
<a href="http://blog.csdn.net/wangyanchang21/article/details/50932191">http://blog.csdn.net/wangyanchang21/article/details/50932191</a></p>

<p>Mac端socket调试工具<br/>
<a href="https://www.jianshu.com/p/ca1910ac691a">https://www.jianshu.com/p/ca1910ac691a</a></p>

<p>iOS 系统与xcode Downloads<br/>
<a href="https://developer.apple.com/download/">https://developer.apple.com/download/</a></p>

<p>个人博客<br/>
<a href="http://colin1994.github.io/">http://colin1994.github.io/</a></p>

]]></content>
  </entry>
  
</feed>
